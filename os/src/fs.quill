
mod os::fs

fun make_err[T](code: Int) -> Result[T, os::Error] {
    return Result::Err(os::Error::unsafe_from_code(code))
}

fun make_ok[T](value: T) -> Result[T, os::Error] {
    return Result::Ok(value)
}

ext fun get_file_sep() -> String = "
    #ifdef _WIN32
        return quill_string_from_static_cstr(\"\\\\\");
    #else
        return quill_string_from_static_cstr(\"/\");
    #endif
"
val FILE_SEP: String = get_file_sep()

ext fun get_path_sep() -> String = "
    #ifdef _WIN32
        return quill_string_from_static_cstr(\";\");
    #else
        return quill_string_from_static_cstr(\":\");
    #endif
"
val PATH_SEP: String = get_path_sep()

pub ext fun set_cwd(path: String) -> Result[Unit, os::Error] = "
    #ifdef _WIN32
        QUILL_FS_STRING_AS_WIN_WIDE(#var(path), path_w, #fun(make_err[String]))
        if(!SetCurrentDirectoryW(path_w)) {
            return #fun(make_err[Unit])((quill_int_t) EINVAL);
        }
    #else
        QUILL_FS_STRING_AS_NT(#var(path), path_nt)
        if(chdir(path_nt) != 1) {
            return #fun(make_err[Unit])((quill_int_t) errno);
        }
    #endif
    return #fun(make_ok[Unit])(QUILL_UNIT);
"

pub fun get_cwd() -> String 
    = canonicalize(".") 
    |> expect("Failed to canonicalize current path")

pub ext fun canonicalize(path: String) -> Result[String, os::Error] = "
    // TODO!
"

pub ext fun file_exists(path: String) -> Bool = "
    #ifdef _WIN32
        QUILL_FS_STRING_AS_WIN_WIDE(#var(path), path_w, QUILL_FS_ERR_RET_FALSE)
        return GetFileAttributesW(path_w) != INVALID_FILE_ATTRIBUTES;
    #else
        QUILL_FS_STRING_AS_NT(path, path_nt)
        struct stat st;
        return stat(path_nt, &st) != -1;
    #endif
"

pub ext fun is_file(path: String) -> Bool = "
    #ifdef _WIN32
        QUILL_FS_STRING_AS_WIN_WIDE(#var(path), path_w, QUILL_FS_ERR_RET_FALSE)
        DWORD attr = GetFileAttributesW(path_w);
        if(attr == INVALID_FILE_ATTRIBUTES) { return QUILL_FALSE; }
        return (attr & FILE_ATTRIBUTE_DIRECTORY) == 0;
    #else
        QUILL_FS_STRING_AS_NT(path, path_nt);
        struct stat st;
        if(stat(path_nt, &st) == -1) { return QUILL_FALSE; }
        return S_ISREG(st.st_mode);
    #endif
"

pub ext fun write_file(content: String, path: String) -> Result[Unit, os::Error] = "
    // TODO!
"

pub ext fun read_file(path: String) -> Result[String, os::Error] = "
    FILE *f = NULL;
    #ifdef _WIN32
        QUILL_FS_STRING_AS_WIN_WIDE(#var(path), path_w, #fun(make_err[String]))
        f = _wfopen(path_w, L\"rb\");
    #else 
        QUILL_FS_STRING_AS_NT(#var(path), path_nt)
        f = fopen(path_nt, \"rb\");
    #endif
    if(f == NULL) {
        return #fun(make_err[String])((quill_int_t) errno);
    }
    if(fseek(f, 0, SEEK_END) != 0) {
        quill_int_t e = (quill_int_t) errno;
        fclose(f);
        return #fun(make_err[String])(e);
    }
    quill_string_t res;
    res.length_bytes = (quill_int_t) ftell(f);
    if(res.length_bytes < 0) {
        return #fun(make_err[String])((quill_int_t) errno);
    }
    res.length_points = 0;
    res.alloc = quill_malloc(res.length_bytes, NULL);
    res.data = res.alloc->data;
    rewind(f);
    quill_int_t read_bytes = fread(
        res.alloc->data, 
        1, (size_t) res.length_bytes, 
        f
    );
    if(read_bytes != res.length_bytes) {
        quill_int_t e = (quill_int_t) errno;
        quill_rc_dec(res.alloc);
        fclose(f);
        return #fun(make_err[String])(e);
    }
    if(fclose(f) != 0) {
        quill_int_t e = (quill_int_t) errno;
        quill_rc_dec(res.alloc);
        return #fun(make_err[String])(e);
    }
    for(quill_int_t o = 0; o < res.length_bytes; res.length_points += 1) {
        o += quill_point_decode_length(res.data[o]);
    }
    return #fun(make_ok[String])(res);
"

pub ext fun is_dir(path: String) -> Bool = "
    #ifdef _WIN32
        QUILL_FS_STRING_AS_WIN_WIDE(#var(path), path_w, QUILL_FS_ERR_RET_FALSE)
        DWORD attr = GetFileAttributesW(path_w);
        if(attr == INVALID_FILE_ATTRIBUTES) { return QUILL_FALSE; }
        return (attr & FILE_ATTRIBUTE_DIRECTORY) != 0;
    #else
        QUILL_FS_STRING_AS_NT(path, path_nt);
        struct stat st;
        if(stat(path_nt, &st) == -1) { return QUILL_FALSE; }
        return S_ISDIR(st.st_mode);
    #endif
"

pub ext fun create_dir(path: String) -> Result[Unit, os::Error] = "
    #ifdef _WIN32
        QUILL_FS_STRING_AS_WIN_WIDE(#var(path), path_w, QUILL_FS_ERR_RET_FALSE)
        if(!CreateDirectoryW(path_w, NULL)) {
            return #fun(make_err[Unit])((quill_int_t) EINVAL);
        }
    #else
        QUILL_FS_STRING_AS_NT(path, path_nt);
        struct stat st;
        if(stat(path_nt, &st) == -1) {
            if(mkdir(path_nt, DEFAULT_DIR_MODE) == -1) {
                return #fun(make_err[Unit])((quill_int_t) errno);
            }
        }
    #endif
    return #fun(make_ok[Unit])(QUILL_UNIT);
"

pub ext fun read_dir(path: String) -> Result[List[String], os::Error] = "
    // TODO!
"