
mod std

pub fun List::as_string[T](self: List[T]) -> String {
    val contents = self
        |> as_seq()
        |> map(T::as_string)
        |> join(", ")
    return "List(" |> concat(contents) |> concat(")")
}

pub fun List::as_hash[T](self: List[T]) -> Int = self
    |> as_seq()
    |> map(T::as_hash)
    |> reduce(hash::combine)
    |> unwrap_or(0)

pub fun List::of[T](...values: List[T]) -> List[T] = values

pub fun List::get[T](self: List[T], position: Int) -> Option[T] {
    mut idx = position
    if idx < 0 { idx = (self |> length()) + idx }
    if idx < 0 { return Option::None }
    if idx >= (self |> length()) { return Option::None }
    return Option::Some(self |> get_unchecked(idx))
}

pub fun List::at[T](self: List[T], position: Int) -> T = self
    |> get(position)
    |> unwrap_or_else(|| panic("Index " 
        |> concat(position |> as_string())
        |> concat(" is out of bounds for a list of range ")
        |> concat(self |> length() |> as_string())
    ))

pub fun List::as_seq[T](self: List[T]) -> Sequence[T]
    = range(0, self |> length())
    |> map[Int, T](|i| self |> at(i))

pub fun List::collect[T](from: Sequence[T]) -> List[T] {
    val r = List::of[T]()
    from |> for_each(|v| {
        r |> push(v)
    })
    return r
}