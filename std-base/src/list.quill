
mod std

pub fun List::as_string[T](self: List[T]) -> String {
    val contents = self
        |> values()
        |> map(T::as_string)
        |> join(", ")
    return "List(" |> concat(contents) |> concat(")")
}

pub fun List::as_hash[T](self: List[T]) -> Int = self
    |> values()
    |> map(T::as_hash)
    |> reduce(hash::combine)
    |> unwrap_or(0)

pub fun List::empty[T]() -> List[T] = List::of[T]()

pub fun List::of[T](...values: List[T]) -> List[T] = values

pub fun List::get[T](self: List[T], position: Int) -> Option[T] {
    mut idx = position
    if idx < 0 { idx = (self |> length()) + idx }
    if idx < 0 { return Option::None }
    if idx >= (self |> length()) { return Option::None }
    return Option::Some(self |> get_unchecked(idx))
}

pub fun List::at[T](self: List[T], position: Int) -> T = self
    |> get(position)
    |> unwrap_or_else(|| "Index " 
        |> concat(position |> as_string())
        |> concat(" is out of bounds for a list of range ")
        |> concat(self |> length() |> as_string())
        |> panic()
    )

pub fun List::slice_from[T](self: List[T], start: Int) -> List[T]
    = self |> slice(start, self |> length())

pub fun List::slice_to[T](self: List[T], end: Int) -> List[T]
    = self |> slice(0, end)

pub fun List::indices[T](self: List[T]) -> Sequence[Int] 
    = range(0, self |> length())

pub fun List::indices_rep[T](self: List[T]) -> Stream[Int] {
    if 0 == (self |> length()) {
        return panic("Attempt to get index stream from empty list!")
    }
    return count_from(0)
        |> map(|i| i % (self |> length()))
}

pub fun List::values[T](self: List[T]) -> Sequence[T]
    = range(0, self |> length())
    |> map[Int, T](|i| self |> get_unchecked(i % (self |> length())))

pub fun List::values_rep[T](self: List[T]) -> Stream[T] {
    if 0 == (self |> length()) {
        return panic("Attempt to get element stream from empty list!")
    }
    return count_from(0)
        |> map[Int, T](|i| self |> get_unchecked(i % (self |> length())))
}

pub fun List::reversed[T](self: List[T]) -> Sequence[T]
    = range_incl(1, self |> length())
    |> map[Int, T](|i| self |> get_unchecked((self |> length()) - i))

pub fun List::collect[T](from: Sequence[T]) -> List[T] {
    val r = List::of[T]()
    from |> for_each(|v| {
        r |> push(v)
    })
    return r
}

pub fun List::is_empty[T](self: List[T]) -> Bool = (self |> length()) == 0

pub fun List::remove[T](self: List[T], position: Int) -> T = self 
    |> splice(position, position + 1) 
    |> get_unchecked(0)

pub fun List::pop[T](self: List[T]) -> Option[T] {
    val l = self |> length()
    if l == 0 { return Option::None }
    return Option::Some(self |> splice(l - 1, l) |> get_unchecked(0))
}

pub fun List::clear[T](self: List[T]) -> List[T] {
    self |> splice(0, self |> length())
    return self
}