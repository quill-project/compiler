
mod std

struct Sequence[T](next: Fun() -> Option[T])

pub fun Sequence::new[T](next: Fun() -> Option[T]) -> Sequence[T] 
    = Sequence(next)

pub fun Sequence::of[T](value: T) -> Sequence[T] {
    mut had_value = false
    return Sequence(|| {
        if had_value { return Option::None }
        had_value = true
        return Option::Some(value)
    })
}

pub fun Sequence::empty[T]() -> Sequence[T] 
    = Sequence::new(|| Option::None)

pub fun Sequence::next[T](self: Sequence[T]) -> Option[T] = self.next()

pub fun Sequence::map[I, O](self: Sequence[I], f: Fun(I) -> O) -> Sequence[O]
    = Sequence::new(|| self |> next() |> map(f))

pub fun Sequence::take[T](self: Sequence[T], n: Int) -> Sequence[T] {
    mut i = 0
    return Sequence::new(|| {
        if i >= n { return Option::None }
        i = i + 1
        return self |> next()
    })
}

pub fun Sequence::take_while[T](self: Sequence[T], cond: Fun(T) -> Bool) -> Sequence[T] {
    mut ended = false
    return Sequence::new(|| {
        if ended { return Option::None }
        match self |> next() {
            None { return Option::None }
            Some(n) {
                ended = !cond(n)
                return if ended { Option::None } else { Option::Some(n) }
            }
        }
    })
}

pub fun Sequence::take_until[T](self: Sequence[T], cond: Fun(T) -> Bool) -> Sequence[T] {
    mut ended = false
    return Sequence::new(|| {
        if ended { return Option::None }
        match self |> next() {
            None { return Option::None }
            Some(n) {
                ended = cond(n)
                return if ended { Option::None } else { Option::Some(n) }
            }
        }
    })
}

pub fun Sequence::fold[I, O](
    self: Sequence[I], start: O, f: Fun(O, I) -> O
) -> O {
    mut acc = start
    self |> for_each(|c| {
        acc = f(acc, c)
    })
    return acc
}

pub fun Sequence::reduce[T](self: Sequence[T], f: Fun(T, T) -> T) -> Option[T]
    = self |> next() |> map(|start| self |> fold(start, f))

pub fun Sequence::filter[T](self: Sequence[T], cond: Fun(T) -> Bool) -> Sequence[T] 
    = Sequence::new(|| {
        mut found = self |> next()
        Sequence::new[Unit](|| {
            match found {
                None { return Option::None }
                Some(value) {
                    if cond(value) { return Option::None }
                    found = self |> next()
                    return Option::Some
                }
            }
        }) |> for_each(|n| {})
        return found
    })

pub fun Sequence::for_each[T](self: Sequence[T], f: Fun(T))
    = self |> for_each_until(f, Option::None)

pub fun Sequence::find[T](self: Sequence[T], cond: Fun(T) -> Bool) -> Option[T]
    = self |> filter(cond) |> next()