
mod std

struct Sequence[T](next: Fun() -> Option[T])

pub fun Sequence::new[T](next: Fun() -> Option[T]) -> Sequence[T] 
    = Sequence(next)

pub fun Sequence::next[T](self: Sequence[T]) -> Option[T] = self.next()

pub fun Sequence::map[I, O](self: Sequence[I], f: Fun(I) -> O) -> Sequence[O]
    = Sequence::new(|| self |> next() |> map(f))

pub fun Sequence::take[T](self: Sequence[T], n: Int) -> Sequence[T] {
    mut i = 0
    return Sequence::new(|| {
        if i >= n { return Option::None }
        i = i + 1
        return self |> next()
    })
}

pub fun Sequence::fold[I, O](
    self: Sequence[I], start: O, f: Fun(O, I) -> O
) -> O {
    mut acc = start
    self |> for_each(|c| {
        acc = f(acc, c)
    })
    return acc
}

pub fun Sequence::reduce[T](self: Sequence[T], f: Fun(T, T) -> T) -> Option[T]
    = self |> next() |> map(|start| self |> fold(start, f))

pub fun Sequence::filter[T](
    self: Sequence[T], f: Fun(T) -> Bool
) -> Sequence[T] = Sequence::new(|| {
    mut found = self |> next()
    Sequence::new[Unit](|| {
        match found {
            None { return Option::None }
            Some(value) {
                if f(value) { return Option::None }
                found = self |> next()
                return Option::Some
            }
        }
    }) |> for_each(|n| {})
    return found
})

ext fun Sequence::for_each_impl[T](self: Sequence[T], f: Fun(T), end: Option[T]) = "
    while(true) {
        const elem = self.next();
        if(elem.tag === end.tag) { return; }
        f(elem.value);
    }
"

pub fun Sequence::for_each[T](self: Sequence[T], f: Fun(T))
    = self |> for_each_impl(f, Option::None)