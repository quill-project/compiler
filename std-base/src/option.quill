
mod std

pub enum Option[T](Some: T, None)

pub fun Option::as_string[T](self: Option[T]) -> String = self 
    |> map[T, String](|v| "Some(" |> concat(T::as_string(v)) |> concat(")"))
    |> unwrap_or("None")

pub fun Option::expect[T](self: Option[T], reason: String) -> T {
    match self {
        Some(value) { return value }
        None { return panic(reason) }
    }
}

pub fun Option::unwrap_or[T](self: Option[T], fallback: T) -> T {
    match self {
        Some(value) { return value }
        None { return fallback }
    }
}

pub fun Option::unwrap_or_else[T](self: Option[T], fallback: Fun() -> T) -> T {
    match self {
        Some(value) { return value }
        None { return fallback() }
    }
}

pub fun Option::map[I, O](self: Option[I], f: Fun(I) -> O) -> Option[O] {
    match self {
        Some(value) { return Option::Some(f(value)) }
        None { return Option::None }
    }
}