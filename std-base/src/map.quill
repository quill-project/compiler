
mod std::map

pub struct Entry[K, V](key: K, value: V)

pub fun Entry::as_string[K, V](self: Entry[K, V]) -> String
    = K::as_string(self.key)
    |> concat(" -> ")
    |> concat(V::as_string(self.value))

pub fun Entry::as_hash[K, V](self: Entry[K, V]) -> Int
    = K::as_hash(self.key)
    |> hash::combine(V::as_hash(self.value))


mod std

struct Map[K, V](
    load_factor: Float,
    size: Int,
    buckets: List[List[Map::Entry[K, V]]]
)

// creation

pub fun Map::empty[K, V]() -> Map[K, V] 
    = Map[K, V](0.75, 0, List::empty())

pub fun Map::of[K, V](...entries: List[Map::Entry[K, V]]) -> Map[K, V]
    = entries |> as_seq() |> Map::collect[K, V]()

pub fun Map::collect[K, V](from: Sequence[Map::Entry[K, V]]) -> Map[K, V] {
    val r: Map[K, V] = Map::empty()
    from |> for_each(|entry| { r |> insert(entry) })
    return r
}

// modification

pub fun Map::with_load_factor[K, V](self: Map[K, V], load_factor: Float) -> Map[K, V] {
    self.load_factor = load_factor
    return self
}

pub fun Map::with_capacity[K, V](self: Map[K, V], capacity: Int) -> Map[K, V] {
    return panic("Not yet implemented!")
}

pub fun Map::insert[K, V](self: Map[K, V], entry: Map::Entry[K, V]) -> Option[V] {
    // TODO! RESIZE
    val bucket_i = Int::abs(K::as_hash(entry.key)) % (self.buckets |> length())
    val bucket = self.buckets |> at(bucket_i)
    return bucket |> as_seq()
        |> find(|e| e.key == entry.key)
        |> map(|e| {
            val replaced = e.value
            e.value = entry.value
            return Option::Some(replaced)
        })
        |> unwrap_or_else(|| {
            bucket |> push(entry)
            self.size = self.size + 1
            return Option::None
        })
}

pub fun Map::set[K, V](self: Map[K, V], key: K, value: V) -> Option[V]
    = self |> insert(Map::Entry(key, value))

// access

pub fun Map::as_string[K, V](self: Map[K, V]) -> String {
    val contents = self 
        |> entries() 
        |> map(Entry::as_string[K, V]) 
        |> join(", ")
    return "Map(" |> concat(contents) |> concat(")")
}

pub fun Map::as_hash[K, V](self: Map[K, V]) -> Int = self 
    |> entries() 
    |> map(Entry::as_hash[K, V]) 
    |> reduce(hash::combine) 
    |> unwrap_or(0)

pub fun Map::load_factor[K, V](self: Map[K, V]) -> Float = self.load_factor

pub fun Map::size[K, V](self: Map[K, V]) -> Int = self.size

pub fun Map::is_empty[K, V](self: Map[K, V]) -> Bool = self.size == 0

pub fun Map::get[K, V](self: Map[K, V], key: K) -> Option[V] {
    val bucket_i = Int::abs(K::as_hash(key)) % (self.buckets |> length())
    return self.buckets |> at(bucket_i) |> as_seq()
        |> find(|e| e.key == key)
        |> map(|e| e.value)
}

pub fun Map::has[K, V](self: Map[K, V], key: K) -> Bool
    = self |> get(key) |> is_some()

pub fun Map::keys[K, V](self: Map[K, V]) -> Sequence[K] {
    return panic("Not yet implemented!")
}

pub fun Map::keys_repeated[K, V](self: Map[K, V]) -> Stream[K] {
    return panic("Not yet implemented!")
}

pub fun Map::values[K, V](self: Map[K, V]) -> Sequence[V] = self
    |> keys()
    |> map(|k| self |> get(k) |> expect("Map modified during iteration!"))

pub fun Map::values_repeated[K, V](self: Map[K, V]) -> Stream[V] = self
    |> keys_repeated()
    |> map(|k| self |> get(k) |> expect("Map modified during iteration!"))


pub fun Map::entries[K, V](self: Map[K, V]) -> Sequence[Map::Entry[K, V]] = self 
    |> keys() 
    |> map(|k| {
        val v = self |> get(k) |> expect("Map modified during iteration!")
        return Map::Entry(k, v)
    })

pub fun Map::entries_repeated[K, V](self: Map[K, V]) -> Stream[Map::Entry[K, V]] = self 
    |> keys_repeated() 
    |> map(|k| {
        val v = self |> get(k) |> expect("Map modified during iteration!")
        return Map::Entry(k, v)
    })

// removal

pub fun Map::remove[K, V](self: Map[K, V], key: K) -> Option[K] {
    return panic("Not yet implemented!")
}

pub fun Map::clear[K, V](self: Map[K, V]) -> Map[K, V] {
    self.size = 0
    self.buckets = Stream::new(|| List::empty[Map::Entry[K, V]]()) 
        |> take(self.buckets |> length()) 
        |> List::collect()
    return self
}

