
mod std

struct Sequence[T](next: Fun() -> Option[T])

pub fun Sequence::new[T](next: Fun() -> Option[T]) -> Sequence[T] = Sequence(next)

pub fun Sequence::next[T](self: Sequence[T]) -> Option[T] = self.next()

pub fun Sequence::map[I, O](self: Sequence[I], f: Fun(I) -> O) -> Sequence[O]
    = Sequence::new(|| self |> next() |> map(f))

pub ext fun Sequence::for_each[T](self: Sequence[T], f: Fun(T)) = "
    while(true) {
        const value = self.next();
        if(value.value === undefined) { return; }
        f(value);
    }
"

pub fun Sequence::reduce[T](self: Sequence[T], f: Fun(T, T) -> T) -> Option[T]
    = self |> next() |> map(|start| {
        mut acc = start
        self |> for_each(|c| {
            acc = f(acc, c)
        })
        return acc
    })