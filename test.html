<!doctype html>
<html>
<head>
    <script src="quill.js"></script>
    <script>

    const print = thing => console.log(thing);
    const add = (a, b) => a + b;
    const sqrt = x => Math.sqrt(x);
    const rand = () => Math.random();
    const PI = Math.PI;

/*
    const sources = {
        "test.quill": `

mod js

pub ext fun print_int(n: Int) = print
pub ext fun print_float(x: Float) = print
pub ext fun print_bool(b: Bool) = print
pub ext fun rand() -> Float = rand
pub ext fun add_int(a: Int, b: Int) -> Int = add
pub ext fun add_float(a: Float, b: Float) -> Float = add
pub ext fun sqrt(x: Float) -> Float = sqrt
pub ext val PI: Float = PI


mod pet

struct Cat(age: Int, hunger: Float)

pub fun make_cat(age: Int, hunger: Float) -> Cat 
    = Cat(age, hunger)

pub fun feed(self: Cat) {
    self.hunger = 0.0
}

pub fun hunger_of(self: Cat) -> Float = self.hunger


mod dyn

pub enum Number(Int: Int, Float: Float)
pub enum Role(Guest, Member, Moderator, Admin)


pub struct Vec3(x: Float, y: Float, z: Float)


mod test

fun fib(n: Int) -> Int {
    match n {
        0 | 1 { return n }
        _ { return fib(n - 1) + fib(n - 2) }
    }
}

struct BoolPair(left: Bool, right: Bool)

fun xor(left: Bool, right: Bool) -> Bool {
    match BoolPair(left, right) {
        BoolPair(true, true) { return false }
        BoolPair(true, false) { return true }
        BoolPair(false, true) { return true }
        BoolPair(false, false) {  return false }
    }
}

fun main() {
    js::print_int(unwrap_or(double(OptionalInt::None), -1))
    js::print_bool(xor(true, false))
}

fun abs(n: Int) -> Int = if n < 0 { -n } else { n }

enum OptionalInt(Some: Int, None)

fun double(n: OptionalInt) -> OptionalInt {
    match n {
        OptionalInt::Some(69) { return OptionalInt::Some(420) }
        OptionalInt::Some(x) { return OptionalInt::Some(x * 2) }
        OptionalInt::None { return n }
    }
}

fun unwrap_or(self: OptionalInt, other: Int) -> Int {
    match self {
        OptionalInt::Some(x) { return x }
        _ { return other }
    }
}

        `
    };
    */

    const curryMultiply = a => b => a * b;

    const sources = {
        "test.quill": `
        
mod std

pub ext fun log_int(n: Int) = print
pub ext fun log_float(n: Float) = print
pub ext fun log(n: String) = print


mod test

fun main() {
    log("Hello, world!")
}

        `
    };

    const result = quill.compile(sources);
    if(result.success) {
        console.log(result.code);
        eval(result.code);
        test$main();
    } else {
        console.error(result.errors
            .map(e => quill.message.display(e, sources))
            .join("\n\n")
        );
    }
    </script>
</head>
<body></body>
</html>