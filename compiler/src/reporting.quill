
mod quill

use quill::token::(Token, TokenType)


pub struct Source(path: String, start: Int, end: Int)

// Creates a new source starting at 'start' and ending at 'end'.
// If the paths of the two sources differ, the path of the first
// source is used.
pub fun Source::range(start: Source, end: Source) -> Source 
    = Source(start.path, start.start, end.end)

pub fun Source::as_string(self: Source) -> String 
    = "_.._ in '_'" |> fmt(
        Int::as_string(self.start), Int::as_string(self.end), 
        self.path
    )


pub enum Message::Section(
    Error: String,
    Warning: String,
    Info: String,
    Code: Source
)

pub fun Message::Section::display(self: Message::Section, files: Map[String, String]) -> String {
    match self {
        Error(msg) { return "! error ! " |> concat(msg) }
        Warning(msg) { return "warning: " |> concat(msg) }
        Info(msg) { return "info: " |> concat(msg) }
        Code(at) { return "at " |> concat(Source::as_string(at)) }
    }
}

pub struct Message(sections: List[Message::Section])

pub fun Message::display(self: Message, files: Map[String, String]) -> String
    = self.sections 
    |> values()
    |> map[Message::Section, String](
        |s| s |> Message::Section::display(files)
    )
    |> join("\n")

// Tokenization

pub fun Message::invalid_character(invalid: String, at: Source) -> Message
    = Message(List::of(
        Message::Section::Error("Invalid character '_'" |> fmt(invalid)),
        Message::Section::Code(at)
    ))

pub fun Message::unclosed_string_literal(at: Source) -> Message
    = Message(List::of(
        Message::Section::Error("Unclosed string literal"),
        Message::Section::Code(at)
    ))

pub fun Message::invalid_hex_escape(at: Source) -> Message
    = Message(List::of(
        Message::Section::Error("Invalid hexadecimal in string escape sequence"),
        Message::Section::Code(at)
    ))

// Parsing

pub fun Message::unexpected_token(token: Token, exp_types: List[TokenType]) -> Message {
    val exp = exp_types |> slice(0, -1) |> values() 
        |> map(TokenType::as_string)
        |> join(", ") |> concat(" or ") 
        |> concat(exp_types |> at(-1) |> TokenType::as_string())
    val got = token.type |> TokenType::as_string()
    return Message(List::of(
        Message::Section::Error("Expected _, but got _" |> fmt(exp, got)),
        Message::Section::Code(token.source)
    ))
}

pub fun Message::unexpected_construct(
    token: Token, expected: String
) -> Message
    = Message(List::of(
        Message::Section::Error(
            "Expected _, but got _" |> fmt(expected, token.content)
        ),
        Message::Section::Code(token.source)
    ))

pub fun Message::non_call_pipe(at: Source) -> Message 
    = Message(List::of(
        Message::Section::Error("Pipe into non-call expression"),
        Message::Section::Code(at)
    ))