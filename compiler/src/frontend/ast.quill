
mod quill::ast

use quill::*

pub struct UntypedNode(value: Variant[UntypedNode], source: Source)

pub fun UntypedNode::as_string(self: UntypedNode) -> String 
    = self.value |> as_string()


pub struct FunctionType[N](args: List[N], ret: Option[N])

pub struct PathRef[N](path: List[String], t_args: Option[List[N]])
pub struct Closure[N](args: List[String], body: List[N])

pub struct Invocation[N](invoked: N, args: List[N])
pub struct PathInvocation[N](path: List[String], args: List[N], t_args: Option[List[N]])
pub struct IfExpr[N](cond: N, if_val: N, else_val: N)

pub struct LocalVariable[N](name: String, mutable: Bool, type: Option[N], value: N)
pub struct If[N](cond: N, if_body: List[N], else_body: List[N])
pub struct While[N](cond: N, body: List[N])
pub struct For[N](name: String, in: N, body: List[N])
pub struct Match[N](matched: N, branches: List[MatchBranch[N]])
pub struct MatchBranch[N](patterns: List[N], body: List[N])

pub struct GlobalVariable[N](
    path: List[String], public: Bool, mutable: Bool, type: Option[N]
)
pub struct Function[N](
    path: List[String], public: Bool, external: Bool,
    t_args: List[String], args: List[Pair[String, N]], return_type: N,
    body: List[N]    
)
pub struct CustomType[N](
    path: List[String], public: Bool,
    t_args: List[String], members: List[Pair[String, N]]
)

pub enum Variant[N](
    TypeRef: Pair[Bool, PathRef[N]],
    FunctionType: FunctionType[N],

    PathRef: PathRef[N],
    VariableRef: String,
    Int: Int,
    Float: Float,
    Bool: Bool,
    Unit,
    String: String,
    Closure: Closure[N],

    Add: Pair[N, N],
    Subtract: Pair[N, N],
    Multiply: Pair[N, N],
    Divide: Pair[N, N],
    Remainder: Pair[N, N],
    LessThan: Pair[N, N],
    LessThanEqual: Pair[N, N],
    Equal: Pair[N, N],
    NotEqual: Pair[N, N],
    Negate: N,
    Not: N,
    Member: Pair[N, String],
    Call: Invocation[N],
    PipedCall: Invocation[N],
    NamedCall: PathInvocation[N],
    StructInit: PathInvocation[N],
    EnumInit: PathInvocation[N],
    IfExpr: IfExpr[N],

    LocalVariable: LocalVariable[N],
    Assignment: Pair[N, N],
    Return: N,
    Continue,
    Break,
    If: If[N],
    While: While[N],
    For: For[N],
    Match: Match[N],

    Module: List[String],
    Usages: List[List[String]],
    GlobalVariable: GlobalVariable[N],
    Function: Function[N],
    Structure: CustomType[N],
    Enumeration: CustomType[N],

    Invalid
)

pub fun PathRef::as_string[N](self: PathRef[N]) -> String {
    val t_args_s = self.t_args
        |> map[List[N], String](|t| {
            val a = t |> values() |> map(N::as_string) |> join(", ")
            return "[" |> concat(a) |> concat("]")
        })
        |> unwrap_or("")
    return self.path |> values() |> join("::") |> concat(t_args_s)
}

pub fun PathInvocation::as_string[N](self: PathInvocation[N]) -> String {
    val path_s = self.path |> values() |> join("::")
    val args_s = self.args |> values() |> skip(1) 
        |> map(N::as_string) |> join(", ")
    val t_args_s = self.t_args
        |> map[List[N], String](|t| {
            val a = t |> values() |> map(N::as_string) |> join(", ")
            return "[" |> concat(a) |> concat("]")
        })
        |> unwrap_or("")
    return path_s |> concat(t_args_s) 
        |> concat("(") |> concat(args_s) |> concat(")")
}

pub fun MatchBranch::as_string[N](self: MatchBranch[N]) -> String
    = "_ -> { _ }" |> fmt(
        self.patterns |> values() |> map(N::as_string) |> join(" | "),
        self.body |> values() |> map(N::as_string) |> join("; ")
    )


pub fun Variant::as_string[N](self: Variant[N]) -> String {
    match self {
        Variant::TypeRef(Pair(mutable, ref)) {
            return "type"
                |> concat(if mutable { "+mut" } else { "" })
                |> concat("@")
                |> concat(PathRef::as_string(ref))
        }
        Variant::FunctionType(FunctionType(args, ret)) { 
            return "(Fun("
                |> concat(args |> values() |> map(N::as_string) |> join(", "))
                |> concat(")")
                |> concat(ret 
                    |> map[N, String](|n| " -> " |> concat(N::as_string(n))) 
                    |> unwrap_or("")
                )
                |> concat(")")
        }

        Variant::PathRef(ref) { return PathRef::as_string(ref) }
        Variant::VariableRef(name) { return "var@" |> concat(name) }
        Variant::Int(i) { return Int::as_string(i) }
        Variant::Float(f) { return Float::as_string(f) }
        Variant::Bool(b) { return Bool::as_string(b) }
        Variant::Unit { return "unit" }
        Variant::String(s) { return "\"" |> concat(s) |> concat("\"") }
        Variant::Closure(Closure(args, body)) {
            val args_s = args |> values() |> join(", ")
            val body_s = body |> values() |> map(N::as_string) |> join("; ")
            return "|_| { _ }" |> fmt(args_s, body_s)
        }

        Variant::Add(Pair(a, b)) { return "(_ + _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::Subtract(Pair(a, b)) { return "(_ - _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::Multiply(Pair(a, b)) { return "(_ * _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::Divide(Pair(a, b)) { return "(_ / _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::Remainder(Pair(a, b)) { return "(_ % _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::LessThan(Pair(a, b)) { return "(_ < _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::LessThanEqual(Pair(a, b)) { return "(_ <= _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::Equal(Pair(a, b)) { return "(_ == _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::NotEqual(Pair(a, b)) { return "(_ != _)" |> fmt(N::as_string(a), N::as_string(b)) }
        Variant::Negate(x) { return "(- _)" |> fmt(N::as_string(x)) }
        Variant::Not(x) { return "(! _)" |> fmt(N::as_string(x)) }
        Variant::Member(Pair(obj, name)) { return "(_ ._)" |> fmt(N::as_string(obj), name) }
        Variant::Call(Invocation(called, args)) {
            val args_s = args |> values() |> map(N::as_string) |> join(", ")
            return "(_(_))" |> fmt(N::as_string(called), args_s)
        }
        Variant::PipedCall(Invocation(called, args)) {
            val args_s = args |> values() |> skip(1) 
                |> map(N::as_string) |> join(", ")
            return "(_ |> _(_))" |> fmt(
                N::as_string(args |> at(0)), N::as_string(called), args_s
            )
        }
        Variant::NamedCall(invocation) {
            return "(fun@" 
                |> concat(PathInvocation::as_string(invocation))
                |> concat(")")
        }
        Variant::StructInit(invocation) {
            return "(struct@" 
                |> concat(PathInvocation::as_string(invocation))
                |> concat(")")
        }
        Variant::EnumInit(invocation) {
            return "(enum@" 
                |> concat(PathInvocation::as_string(invocation))
                |> concat(")")
        }
        Variant::IfExpr(IfExpr(c, i, e)) {
            return "(if _ then _ else _)"
                |> fmt(N::as_string(c), N::as_string(i), N::as_string(e))
        }

        Variant::LocalVariable(LocalVariable(name, mutable, type, value)) {
            return "_ __ = _" |> fmt(
                if mutable { "mut" } else { "val" }, name,
                type |> map[N, String](|t| ": " |> concat(N::as_string(t)))
                    |> unwrap_or(""),
                N::as_string(value)
            )
        }
        Variant::Assignment(Pair(a, b)) { 
            return "_ = _" |> fmt(N::as_string(a), N::as_string(b)) 
        }
        Variant::Return(v) { return "return " |> concat(N::as_string(v)) }
        Variant::Continue { return "continue" }
        Variant::Break { return "break" }
        Variant::If(If(cond, if_body, else_body)) {
            val if_body_s = if_body |> values() |> map(N::as_string) |> join("; ")
            val else_body_s = else_body |> values() |> map(N::as_string) |> join("; ")
            return "if _ { _ } else { _ }" |> fmt(
                N::as_string(cond), if_body_s, else_body_s
            )
        }
        Variant::While(While(cond, body)) {
            return "while _ { _ }" |> fmt(
                N::as_string(cond),
                body |> values() |> map(N::as_string) |> join("; ")
            )
        }
        Variant::For(For(name, seq, body)) {
            return "for _: _ { _ }" |> fmt(
                name, N::as_string(seq),
                body |> values() |> map(N::as_string) |> join("; ")
            )
        }
        Variant::Match(Match(matched, branches)) {
            val branches_s = branches |> values() 
                |> map(MatchBranch::as_string[N]) |> join(" ")
            return "match _ { _ }" |> fmt(
                N::as_string(matched), branches_s
            )
        }

        _ { return "not yet implemented" }
    }
}