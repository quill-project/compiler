
mod quill::checker

use quill::*
use quill::types::*
use quill::ast::UntypedNode

// Given a checker state, an annotation node and a concrete type, this function
// attempts to update the current type arguments in the context of the given
// checker state by comparing the given annotation and its concrete type.
// For example, if given the annotation 'List[T]' and a concrete type 'List[Int]',
// this function will update the type argument 'T' in the context of the given
// checker to be of type 'Int'.
fun infer_anno_t_args(
    decl_c: mut Checker,
    anno: UntypedNode,
    given: Type
) -> Bool {
    match given.value {
        Invalid { return false }
        _ {}
    }
    match anno.value {
        TypeRef(Pair(_, ast::PathRef(exp_path, exp_t_args))) {
            val exp_t_arg_c: Int = exp_t_args
                |> map(List::length[UntypedNode])
                |> unwrap_or(0)
            val is_t_arg: Bool = (exp_path |> length() |> is(1))
                && (decl_c.type_args |> has(exp_path |> at(0)))
            if is_t_arg {
                val arg_name: String = exp_path |> at(0)
                return decl_c.type_args 
                    |> get(arg_name)
                    |> expect("branch depends on map to have type")
                    |> Type::join(given)
                    |> map[Type, Unit](|t| {
                        decl_c.type_args |> set(arg_name, t)
                    })
                    |> is_some()
            }
            match given.value {
                Struct(Pair(_, given_t_args)) |
                Enum(Pair(_, given_t_args)) {
                    val got_t_arg_c: Int = given_t_args |> length()
                    if exp_t_arg_c != got_t_arg_c { return false }
                    return given_t_args |> indices() |> fold(true, |acc, i|
                        infer_anno_t_args(
                            decl_c, 
                            exp_t_args |> expect("length > 0") |> at(i), 
                            given_t_args |> at(i)
                        ) && acc
                    )
                }
                List(given_t_arg) {
                    if exp_t_arg_c != 1 { return false }
                    return infer_anno_t_args(
                        decl_c,
                        exp_t_args |> expect("length == 0") |> at(0),
                        given_t_arg
                    )
                }
                _ {}
            }
        }
        FunctionType(ast::FunctionType(exp_args_t, exp_ret_t)) {
            match given.value {
                Variant::Function(Pair(got_args_t, got_ret_t)) {
                    val exp_arg_c: Int = exp_args_t |> length()
                    val got_arg_c: Int = got_args_t |> length()
                    if exp_arg_c != got_arg_c { return false }
                    val args: Bool = got_args_t |> indices() |> fold(true, |acc, i|
                        infer_anno_t_args(
                            decl_c, exp_args_t |> at(i), got_args_t |> at(i)
                        ) && acc
                    )
                    match exp_ret_t {
                        Some(e_ret_t) {
                            return infer_anno_t_args(decl_c, e_ret_t, got_ret_t)
                                && args
                        }
                        None { return args }
                    }
                }
                _ {}
            }
        }
        _ {}
    }
    return true
}

// Given a call site checker state, a list of value nodes, an optional
// concrete expected return type, a declaration site checker, a list of
// argument type annotations and a result value type annotation, this function
// attempts to infer the type arguments that are used to instantiate
// the symbol, and puts them INTO THE DECLARATION SITE CHECKER.
// For example, if 'add' is defined as a 'fun add[T](a: T, b: T) -> T',
// then providing the arguments 'add(5, 10)' and expecting a result type of 'Int'
// will result in 'T' being inferred to be 'Int'.
fun infer_call_t_args(
    call_c: mut Checker,
    given_args: List[UntypedNode],
    exp_ret_type: Option[Type],
    call_site: Source,

    decl_c: mut Checker,
    exp_arg_types: List[UntypedNode],
    exp_varargs: Bool,
    given_ret_type: UntypedNode
) -> List[TypedNode] {
    val get_va_list_type: Fun(UntypedNode) -> UntypedNode = |n| { match n.value {
        TypeRef(Pair(_, ast::PathRef(List::of("std", "List"), o_e))) |
        TypeRef(Pair(_, ast::PathRef(List::of("List"), o_e))) { return o_e
            |> and_then[List[UntypedNode], UntypedNode](|l_e| l_e |> get(0))
            |> unwrap_or_else(|| UntypedNode(ast::Variant::Invalid, n.source))
        }
        _ { return UntypedNode(ast::Variant::Invalid, n.source) }
    } }
    val old_call_msgs: mut List[Message] = call_c.messages
    exp_ret_type |> map[Type, Unit](|ret_t| {
        infer_anno_t_args(decl_c, given_ret_type, ret_t)
    })
    val exp_arg_c: Int = exp_arg_types |> length()
    val checked_args: mut List[Option[TypedNode]] = given_args 
        |> indices()
        |> map[Int, Option[TypedNode]](|_| Option::None)
        |> List::collect()
    mut had_success: Bool = true
    Stream::new[List[Option[TypedNode]]](|| checked_args)
        |> take_while(|c| c |> values() |> any(|n| n |> is_none()))
        |> take_while(|_| had_success)
        |> for_each(|checked| {
            had_success = false
            call_c.messages = List::empty()
            given_args |> indices()
                |> filter(|i| checked_args |> at(i) |> is_none())
                |> for_each(|i| {
                    val arg_val: UntypedNode = given_args |> at(i)
                    val ei = Int::min(exp_arg_c - 1, i)
                    val is_varargs = exp_varargs && i >= exp_arg_c - 1
                    val raw_exp_arg_type: UntypedNode = exp_arg_types |> at(ei)
                    val exp_arg_type = if !is_varargs { raw_exp_arg_type }
                        else { get_va_list_type(raw_exp_arg_type) }
                    val exp_t: TypedNode = decl_c 
                        |> check_annotation(exp_arg_type)
                    val given_t: TypedNode = call_c 
                        |> check(arg_val, exp_t.type)
                    val success: Bool = infer_anno_t_args(
                        decl_c, exp_arg_type, given_t.type
                    )
                    if !success { return unit }
                    checked_args |> set(i, Option::Some(given_t))
                    had_success = true
                })
        })
    call_c.messages |> values() |> for_each(|m| { old_call_msgs |> push(m) })
    call_c.messages = old_call_msgs
    val unknown: mut Sequence[Pair[String, Type]] = decl_c.type_args 
        |> entries()
        |> filter(|t| {
            match t.second.value {
                Invalid { return true }
                _ { return false }
            }
        })
    unknown |> for_each(|t| {
        call_c.messages |> push(
            Message::failed_t_arg_inference(call_site, t.first)
        )
    })
    return checked_args
        |> values()
        |> map[Option[TypedNode], TypedNode](|a| a |> unwrap_or_else(
            || TypedNode(
                ast::Variant::Invalid, call_site, 
                Type(Variant::Invalid, !IS_MUTABLE, call_site)
            )            
        ))
        |> List::collect()
}

// Ensures both of the given concrete types to be of the same numeric type.
// If both of the given types are of the same numeric type, that type is returned.
// If one of the given types is invalid, the other numeric type is returned.
// In all other cases, an appropriate error is generated and an invalid type
// is returned.
fun Checker::operands_numeric(
    self: mut Checker, lhs: Type, rhs: Type, at: Source
) -> Type {
    match Pair(lhs.value, rhs.value) {
        Pair(Variant::Integer, Variant::Integer) |
        Pair(Variant::Float, Variant::Float) |
        Pair(Variant::Invalid, Variant::Integer) |
        Pair(Variant::Invalid, Variant::Float) { 
            return rhs 
        }
        Pair(Variant::Integer, Variant::Invalid) |
        Pair(Variant::Float, Variant::Invalid) { 
            return lhs 
        }
        _ { 
            self.messages |> push(Message::arithmetic_operands(lhs, rhs, at))
            return Type(Variant::Invalid, !IS_MUTABLE, at)
        }
    }
}

// Checks a given closure literal node using the given argument types
// and the context provided by the given checker state.
pub fun Checker::check_closure(
    self: mut Checker, node: UntypedNode, c: ast::Closure[UntypedNode],
    arg_types: List[Type]
) -> TypedNode {
    val exp_arg_c: Int = arg_types |> length()
    val got_arg_c: Int = c.args |> length()
    if exp_arg_c != got_arg_c {
        self.messages |> push(Message::unexpected_closure_argc(
            exp_arg_c, got_arg_c, node.source
        ))
    }
    val scope_vars: mut Map[String, mut Variable] = range(0, got_arg_c)
        |> map[Int, Pair[String, mut Variable]](|i| Pair(
            c.args |> at(i),
            Variable(
                node.source, !IS_MUTABLE, !IS_USED, 
                arg_types |> get(i) |> unwrap_or_else(
                    || Type(Variant::Invalid, !IS_MUTABLE, node.source)
                )
            )
        ))
        |> Map::collect()
    val func = Function(
        List::of(Scope(scope_vars)), 
        Option::None
    )
    self.functions |> push(func)
    self |> enter_scope()
    val body_t: Pair[List[TypedNode], ScopeExit] 
        = self |> check_statement_list(c.body, !IN_LOOP)
    self |> exit_scope()
    self.functions |> pop()
    val return_type = func.return_type 
        |> unwrap_or_else(|| Type(Variant::Unit, !IS_MUTABLE, node.source))
    val always_returns = body_t.second == ScopeExit::Function 
        || return_type.value == Variant::Unit
    if !always_returns {
        self.messages |> push(
            Message::missing_return(
                func.return_type |> expect(""), 
                node.source
            )
        )
    }
    return TypedNode(
        ast::Variant::Closure(ast::Closure(c.args, body_t.first)),
        node.source,
        Type(
            Variant::Function(Pair(arg_types, return_type)),
            !IS_MUTABLE, node.source    
        )
    )
}

// Internal helper function to turn a list of types and a list of type argument names
// into a map of <type arg name> -> <type>.
fun make_full_t_args(types: List[Type], names: List[String], at: Source) -> mut Map[String, Type]
    = range(0, names |> length())
    |> map[Int, Pair[String, Type]](|i| Pair(
        names |> at(i),
        types |> get(i) |> unwrap_or_else(
            || Type(Variant::Invalid, !IS_MUTABLE, at)
        )
    ))
    |> Map::collect()

// Checks a given member access node.
pub fun Checker::check_member(
    self: mut Checker, node: UntypedNode, 
    accessed: UntypedNode, member_name: String
) -> TypedNode {
    val accessed_t: TypedNode = self |> infer(accessed)
    mut r: Type = Type(Variant::Invalid, !IS_MUTABLE, node.source)
    match accessed_t.type.value {
        Variant::Struct(Pair(path, g_t_args)) {
            r = self.symbols.symbols |> get(path) |> and_then[Symbol, Type](|s| {
                match s.node.value {
                    Structure(ast::CustomType(_, public, t_args, members)) {
                        val hidden: Bool = !public
                            && s.context.module != self.context.module
                        if hidden {
                            self.messages |> push(Message::symbol_private(
                                path, node.source, s.node.source
                            ))
                        }
                        val member_c = Checker(
                            List::empty(),
                            make_full_t_args(g_t_args, t_args, node.source),
                            self.symbols, s.context, 
                            self.dependencies, List::empty()
                        )
                        val mem_t: Option[Type] = members
                            |> values()
                            |> find(|m| m.first == member_name)
                            |> map[Pair[String, UntypedNode], TypedNode](
                                |m| member_c |> check_annotation(m.second)
                            )
                            |> map[TypedNode, Type](|t| t.type)
                        if mem_t |> is_none() {
                            self.messages |> push(Message::missing_member(
                                path, member_name, node.source, s.node.source
                            ))
                        }
                        return mem_t
                    }
                    _ { return Option::None }
                }
            }) |> unwrap_or(r)
        }
        Variant::Invalid {}
        _ {
            self.messages |> push(
                Message::expected_struct(accessed_t.type, node.source)
            )
        }
    }
    return TypedNode(
        ast::Variant::Member(Pair(accessed_t, member_name)),
        node.source, r
    )
}

// Checks a given path reference node using the given checker state and 
// optionally using a concrete expected type and returns either:
// - a reference to a local variable
// - a reference to a global variable
// - a reference to a function
// - an enum instantiation
pub fun Checker::check_path_ref(
    self: mut Checker, node: UntypedNode, 
    raw_path: List[String], t_args: Option[List[UntypedNode]],
    exp: Option[Type]
) -> TypedNode {
    if raw_path |> length() |> is(1) {
        val local_name: String = raw_path |> at(0)
        match self |> find_variable(local_name) {
            Some(local) {
                if t_args |> is_some() {
                    self.messages |> push(Message::unexpected_t_args(
                        local_name, node.source
                    ))
                }
                local.used = true
                return TypedNode(
                    ast::Variant::VariableRef(local_name),
                    node.source,
                    local.type
                )
            }
            None {}
        }
    }
    val path: List[String] = self.symbols |> expand(self.context, raw_path)
    val t_args_t: Option[List[TypedNode]] = t_args
        |> map[List[UntypedNode], List[TypedNode]](|args| args
            |> values()
            |> map[UntypedNode, TypedNode](
                |t| self |> check_annotation(t)
            )
            |> List::collect()
        )
    val type_args: List[Type] = t_args_t
        |> map[List[TypedNode], List[Type]](|args| args
            |> values()
            |> map[TypedNode, Type](|t| t.type)
            |> List::collect()    
        )
        |> unwrap_or(List::empty())
    val check_public: Fun(Bool, Symbol) = |public, symbol| {
        if public || symbol.context.module == self.context.module {
            return unit
        }
        self.messages |> push(Message::symbol_private(
            path, node.source, symbol.node.source
        ))
    }
    val check_tac: Fun(Int) = |exp_tac| {
        val got_tac: Int = type_args |> length()
        if exp_tac != got_tac {
            self.messages |> push(Message::wrong_type_arg_c(
                path, exp_tac, got_tac, node.source
            ))
        }
    }
    match self.symbols.symbols |> get(path) {
        Some(s) { match s.node.value {
            GlobalVariable(ast::GlobalVariable(
                _, public, _, type, _
            )) {
                check_public(public, s)
                if t_args |> is_some() {
                    self.messages |> push(Message::unexpected_t_args(
                        path |> values() |> join("::"), node.source
                    ))
                }
                val var_c = Checker(
                    List::empty(), Map::empty(),
                    self.symbols, s.context, 
                    self.dependencies, List::empty()
                )
                val type_t: TypedNode = var_c |> check_annotation(type)
                val instance: SymbolInstance 
                    = SymbolInstance(path, List::empty())
                self.dependencies |> push(instance)
                return TypedNode(
                    ast::Variant::PathRef(ast::PathRef(path, Option::None)),
                    node.source, type_t.type
                )
            }
            ast::Variant::Function(ast::Function(
                _, public, f_t_args, f_args, false, f_ret_t, _
            )) | ast::Variant::ExternalFunction(ast::ExternalFunction(
                _, public, f_t_args, f_args, false, f_ret_t, _
            )) {
                check_public(public, s)
                val func_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, f_t_args, node.source),
                    self.symbols, s.context,
                    self.dependencies, List::empty() 
                )
                match Pair(exp, t_args) {
                    Pair(Option::Some(_), Option::None) {
                        val arg_nodes: List[UntypedNode] = f_args
                            |> values()
                            |> map(|a| a.second)
                            |> List::collect()
                        val got = UntypedNode(
                            ast::Variant::FunctionType(ast::FunctionType(
                                arg_nodes, f_ret_t
                            )),
                            s.node.source
                        )
                        infer_call_t_args(
                            self, List::empty(), exp, node.source,
                            func_c, List::empty(), false, got
                        )
                    }
                    _ {
                        check_tac(f_t_args |> length())
                    }
                }                
                val f_arg_types: List[Type] = f_args
                    |> values()
                    |> map[Pair[String, UntypedNode], Type](
                        |a| (func_c |> check_annotation(a.second)).type
                    )
                    |> List::collect()
                val f_ret_type: Type = f_ret_t
                    |> map[UntypedNode, Type](
                        |r| (func_c |> check_annotation(r)).type
                    )
                    |> unwrap_or_else(
                        || Type(Variant::Unit, !IS_MUTABLE, node.source)
                    )
                val r = Type(
                    Variant::Function(Pair(f_arg_types, f_ret_type)),
                    !IS_MUTABLE, node.source
                )
                val final_type_args: List[Type] = f_t_args |> values()
                    |> map[String, Type](|t| func_c.type_args 
                        |> get(t) 
                        |> expect("was inserted earlier")
                    )
                    |> List::collect()
                val instance: SymbolInstance 
                    = SymbolInstance(path, final_type_args)
                self.dependencies |> push(instance)
                return TypedNode(
                    ast::Variant::FunctionRef(ast::PathRef(path, t_args_t)),
                    node.source, r
                )
            }
            _ {}
        } }
        None {}
    }
    val enum_path: List[String] = self.symbols 
        |> expand(self.context, raw_path |> slice_to(-1))
    match self.symbols.symbols |> get(enum_path) {
        Some(s) { match s.node.value {
            Enumeration(ast::CustomType(
                _, public, t_t_args, t_members
            )) {
                check_public(public, s)
                if t_args |> is_some() { check_tac(t_t_args |> length()) }
                val member_name: String = raw_path |> at(-1)
                val o_member: Option[UntypedNode] = t_members
                    |> values()
                    |> find(|m| m.first == member_name)
                    |> map[Pair[String, UntypedNode], UntypedNode](|m| m.second)
                if o_member |> is_none() {
                    self.messages |> push(Message::missing_member(
                        enum_path, member_name, node.source, s.node.source
                    ))
                }
                val member: UntypedNode = o_member |> unwrap_or_else(
                        || UntypedNode(ast::Variant::Invalid, node.source)
                    )
                val result = UntypedNode(
                    ast::Variant::TypeRef(Pair(!IS_MUTABLE, ast::PathRef(
                        enum_path, 
                        Option::Some(t_t_args 
                            |> values()
                            |> map[String, UntypedNode](|t| UntypedNode(
                                ast::Variant::TypeRef(Pair(
                                    !IS_MUTABLE, 
                                    ast::PathRef(List::of(t), Option::None)
                                )),
                                s.node.source
                            ))
                            |> List::collect()
                        )
                    ))),
                    s.node.source
                )
                val value = UntypedNode(ast::Variant::Unit, node.source)
                val enum_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, t_t_args, node.source),
                    self.symbols, s.context,
                    self.dependencies, List::empty() 
                )
                val values_t: List[TypedNode] = infer_call_t_args(
                    self, List::of(value), exp, node.source,
                    enum_c, List::of(member), false, result
                )
                val final_type_args: List[Type] = t_t_args |> values()
                    |> map[String, Type](|t| enum_c.type_args 
                        |> get(t) 
                        |> expect("was inserted earlier")
                    )
                    |> List::collect()
                val instance: SymbolInstance 
                    = SymbolInstance(enum_path, final_type_args)
                self.dependencies |> push(instance)
                return TypedNode(
                    ast::Variant::EnumInit(ast::PathInvocation(
                        List::concat(enum_path, List::of(member_name)),
                        values_t, t_args_t
                    )),
                    node.source,
                    Type(
                        Variant::Enum(Pair(enum_path, final_type_args)), 
                        !IS_MUTABLE, node.source
                    )
                )
            }
            _ {}
        } }
        None {}
    }
    self.messages |> push(Message::unknown_path(path, node.source))
    return TypedNode(
        ast::Variant::Invalid, node.source,
        Type(Variant::Invalid, !IS_MUTABLE, node.source)
    )
}

// Checks a given call node using the given checker state and 
// optionally using a concrete expected type and returns either:
// - a call to a named function
// - a structure initialization
// - an enum initialization
// - a call to an arbitrary expression
pub fun Checker::check_invocation(
    self: mut Checker, node: UntypedNode,
    invoked: UntypedNode, args: List[UntypedNode],
    exp: Option[Type]
) -> TypedNode {
    val check_argc: Fun(String, Int) = |invoked, exp_c| {
        val got_c: Int = args |> length()
        if exp_c == got_c { return unit }
        self.messages |> push(
            Message::unexpected_argc(invoked, exp_c, got_c, node.source)
        )
    }
    match invoked.value {
        PathRef(ast::PathRef(raw_path, t_args)) {
            val t_args_t: Option[List[TypedNode]] = t_args
                |> map[List[UntypedNode], List[TypedNode]](|args| args
                    |> values()
                    |> map[UntypedNode, TypedNode](
                        |t| self |> check_annotation(t)
                    )
                    |> List::collect()
                )
            val type_args: List[Type] = t_args_t
                |> map[List[TypedNode], List[Type]](|args| args
                    |> values()
                    |> map[TypedNode, Type](|t| t.type)
                    |> List::collect()    
                )
                |> unwrap_or(List::empty())
            val check_named: Fun(List[String], Symbol, Bool, List[String], List[UntypedNode], Bool, UntypedNode) -> Pair[List[TypedNode], Type]
            = |path, symbol, public, decl_t_args, exp_arg_t, exp_varargs, got_ret_t| {
                if !public && symbol.context.module != self.context.module {
                    self.messages |> push(Message::symbol_private(
                        path, node.source, symbol.node.source
                    ))
                }
                val exp_arg_c: Int = if !exp_varargs { exp_arg_t |> length() }
                    else { exp_arg_t |> length() |> subtract(1) }
                val got_arg_c: Int = args |> length()
                if !exp_varargs && got_arg_c != exp_arg_c {
                    self.messages |> push(Message::unexpected_argc(
                        path |> values() |> join("::"),
                        exp_arg_t |> length(), args |> length(),
                        node.source
                    ))
                }
                if exp_varargs && got_arg_c < exp_arg_c {
                    self.messages |> push(Message::unexpected_argc_varargs(
                        path |> values() |> join("::"),
                        exp_arg_t |> length() |> subtract(1), args |> length(),
                        node.source
                    ))
                }
                val pad_args: List[UntypedNode] 
                    = Int::max(exp_arg_c - got_arg_c, 0)
                    |> List::of_length(
                        UntypedNode(ast::Variant::Invalid, node.source)
                    )
                val final_args: List[UntypedNode] = List::concat(args, pad_args)
                    |> slice_to(
                        if exp_varargs { Int::max(exp_arg_c, got_arg_c) } 
                        else { exp_arg_c }
                    )
                val exp_tac: Int = decl_t_args |> length()
                val got_tac: Int = type_args |> length()
                if (t_args |> is_some()) && exp_tac != got_tac {
                    self.messages |> push(Message::wrong_type_arg_c(
                        path, exp_tac, got_tac, node.source
                    ))
                }
                val symbol_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, decl_t_args, node.source),
                    self.symbols, symbol.context,
                    self.dependencies, List::empty() 
                )
                val args_t: List[TypedNode] = infer_call_t_args(
                    self, final_args, exp, node.source,
                    symbol_c, exp_arg_t, exp_varargs, got_ret_t
                )
                val final_type_args: List[Type] = decl_t_args |> values()
                    |> map[String, Type](|t| symbol_c.type_args
                        |> get(t)
                        |> expect("was inserted earlier")
                    )
                    |> List::collect()
                val instance: SymbolInstance 
                    = SymbolInstance(path, final_type_args)
                self.dependencies |> push(instance)
                val result_type = (symbol_c |> check_annotation(got_ret_t)).type
                return Pair(args_t, result_type)
            }
            val path: List[String] = self.symbols 
                |> expand(self.context, raw_path)
            match self.symbols.symbols |> get(path) {
                Some(s) { match s.node.value {
                    ast::Variant::Function(ast::Function(
                        _, public, f_t_args, f_args, f_varargs, f_ret_t, _
                    )) | ast::Variant::ExternalFunction(ast::ExternalFunction(
                        _, public, f_t_args, f_args, f_varargs, f_ret_t, _
                    )) {
                        val arg_nodes: List[UntypedNode] = f_args
                            |> values()
                            |> map[Pair[String, UntypedNode], UntypedNode](
                                |a| a.second
                            )
                            |> List::collect()
                        val ret_node: UntypedNode = f_ret_t
                            |> unwrap_or_else(
                                || UntypedNode(ast::Variant::Unit, node.source)
                            )
                        val checked = check_named(
                            path, s, public, f_t_args, arg_nodes, f_varargs, 
                            ret_node
                        )
                        return TypedNode(
                            ast::Variant::NamedCall(ast::PathInvocation(
                                path, checked.first, t_args_t
                            )),
                            node.source, checked.second
                        )
                    }
                    ast::Variant::Structure(ast::CustomType(
                        _, public, t_t_args, t_members
                    )) {
                        val member_nodes: List[UntypedNode] = t_members
                            |> values()
                            |> map[Pair[String, UntypedNode], UntypedNode](
                                |a| a.second
                            )
                            |> List::collect()
                        val t_arg_nodes: List[UntypedNode] = t_t_args
                            |> values()
                            |> map[String, UntypedNode](|t| UntypedNode(
                                ast::Variant::TypeRef(Pair(
                                    !IS_MUTABLE, 
                                    ast::PathRef(List::of(t), Option::None)
                                )),
                                node.source
                            ))
                            |> List::collect()
                        val ret_node = UntypedNode(
                            ast::Variant::TypeRef(Pair(IS_MUTABLE, ast::PathRef(
                                path, Option::Some(t_arg_nodes)
                            ))),
                            node.source
                        )
                        val checked = check_named(
                            path, s, public, t_t_args, member_nodes, false, 
                            ret_node
                        )
                        return TypedNode(
                            ast::Variant::StructInit(ast::PathInvocation(
                                path, checked.first, t_args_t
                            )),
                            node.source, checked.second
                        )
                    }
                    _ {}
                } }
                None {}
            }
            val enum_path: List[String] = self.symbols 
                |> expand(self.context, raw_path |> slice_to(-1))
            match self.symbols.symbols |> get(enum_path) {
                Some(s) { match s.node.value {
                    ast::Variant::Enumeration(ast::CustomType(
                        _, public, t_t_args, t_members
                    )) {
                        val member_name: String = raw_path |> at(-1)
                        val o_member_node: Option[UntypedNode] = t_members
                            |> values()
                            |> find(|m| m.first == member_name)
                            |> map[Pair[String, UntypedNode], UntypedNode](
                                |m| m.second
                            )
                        if o_member_node |> is_none() {
                            self.messages |> push(Message::missing_member(
                                enum_path, member_name, 
                                node.source, s.node.source
                            ))
                        }
                        val member_node: UntypedNode = o_member_node
                            |> unwrap_or_else(|| UntypedNode(
                                ast::Variant::Invalid, node.source
                            ))
                        val t_arg_nodes: List[UntypedNode] = t_t_args
                            |> values()
                            |> map[String, UntypedNode](|t| UntypedNode(
                                ast::Variant::TypeRef(Pair(
                                    !IS_MUTABLE, 
                                    ast::PathRef(List::of(t), Option::None)
                                )),
                                node.source
                            ))
                            |> List::collect()
                        val ret_node = UntypedNode(
                            ast::Variant::TypeRef(Pair(
                                !IS_MUTABLE, 
                                ast::PathRef(
                                    enum_path, Option::Some(t_arg_nodes)
                                )
                            )),
                            node.source
                        )
                        val checked = check_named(
                            enum_path, s, public, t_t_args, 
                            List::of(member_node), false, ret_node
                        )
                        return TypedNode(
                            ast::Variant::EnumInit(ast::PathInvocation(
                                List::concat(enum_path, List::of(member_name)), 
                                checked.first, t_args_t
                            )),
                            node.source, checked.second
                        )
                    }
                    _ {}
                } }
                None {}
            }
        }
        _ {}
    }
    val called_t: TypedNode = self |> infer(invoked)
    val inv = Type(Variant::Invalid, !IS_MUTABLE, node.source)
    mut exp_arg_t: List[Type] = List::empty()
    mut exp_ret_t: Type = inv
    match called_t.type.value {
        Variant::Function(Pair(arg_types, ret_type)) {
            exp_arg_t = arg_types
            exp_ret_t = ret_type
            check_argc(called_t.type |> as_string(), exp_arg_t |> length())
        }
        _ { 
            self.messages |> push(
                Message::expected_function(called_t.type, node.source)
            )
        }
    }
    val args_t: List[TypedNode] = args
        |> indices()
        |> map[Int, TypedNode](|i| {
            val t: Type = exp_arg_t |> get(i) |> unwrap_or(inv)
            return self |> check(args |> at(i), t)
        })
        |> List::collect()
    return TypedNode(
        ast::Variant::Call(ast::Invocation(called_t, args_t)),
        node.source, exp_ret_t
    )
}

// Checks a given piped call node using the given checker state and 
// optionally using a concrete expected type and returns either:
// - a call to a named function
// - a structure initialization
// - an enum initialization
// - a call to an arbitrary expression
pub fun Checker::check_piped_invocation(
    self: mut Checker, node: UntypedNode,
    invoked: UntypedNode, raw_args: List[UntypedNode],
    exp: Option[Type]
) -> TypedNode {
    val receiver: UntypedNode = raw_args |> at(0)
    match invoked.value {
        PathRef(ast::PathRef(raw_path, t_args)) {
            val t_args_t: Option[List[TypedNode]] = t_args
                |> map[List[UntypedNode], List[TypedNode]](|args| args
                    |> values()
                    |> map[UntypedNode, TypedNode](
                        |t| self |> check_annotation(t)
                    )
                    |> List::collect()
                )
            val type_args: List[Type] = t_args_t
                |> map[List[TypedNode], List[Type]](|args| args
                    |> values()
                    |> map[TypedNode, Type](|t| t.type)
                    |> List::collect()    
                )
                |> unwrap_or(List::empty())
            val receiver_t: TypedNode = self |> infer(receiver)
            val exp_path: List[String] = self.symbols 
                |> expand(self.context, raw_path)
            if self.symbols.symbols |> has(exp_path) {
                return self |> check_invocation(node, invoked, raw_args, exp)
            }
            if raw_path |> length() |> is_not(1) {
                return self |> check_invocation(node, invoked, raw_args, exp)
            }
            val is_receiver: Fun(Symbol, List[String], UntypedNode) -> Bool
            = |symbol, decl_t_args, receiver_ann| {
                val symbol_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, decl_t_args, node.source),
                    self.symbols, symbol.context,
                    self.dependencies, List::empty() 
                )
                infer_anno_t_args(
                    symbol_c, receiver_ann, receiver_t.type
                )
                val receiver_ann_t: TypedNode = symbol_c
                    |> check_annotation(receiver_ann)
                return Type::matches(receiver_ann_t.type, receiver_t.type)
            }
            val is_candidate: Fun(List[String]) -> Bool 
            = |p| { match self.symbols.symbols |> get(p) {
                Some(s) { match s.node.value {
                    ast::Variant::Function(ast::Function(
                        _, _, s_t_args, s_args, false, _, _
                    )) |
                    ExternalFunction(ast::ExternalFunction(
                        _, _, s_t_args, s_args, false, _, _
                    )) |
                    Structure(ast::CustomType(
                        _, _, s_t_args, s_args
                    )) |
                    Enumeration(ast::CustomType(
                        _, _, s_t_args, s_args
                    )) {
                        if s_args |> length() |> is(0) { return false }
                        val receiver_ann: UntypedNode = (s_args |> at(0))
                            .second
                        return is_receiver(s, s_t_args, receiver_ann)
                    }
                    _ { return false }
                } }
                None { return false }
            } }
            val candidates: Set[List[String]] = self.context.aliases
                |> values()
                |> map[List[String], List[String]](
                    |p| List::concat(p, raw_path)
                )
                |> filter(is_candidate)
                |> Set::collect()
            val candidate_c: Int = candidates |> size()
            if candidate_c == 0 {
                return self |> check_invocation(node, invoked, raw_args, exp)
            }
            if candidate_c > 1 {
                self.messages |> push(Message::ambiguous_pipe(
                    receiver_t.type, candidates, node.source
                ))
                return TypedNode(
                    ast::Variant::Invalid, node.source,
                    Type(Variant::Invalid, !IS_MUTABLE, node.source)
                )
            }
            val invoked_path: List[String] = candidates
                |> values() |> next() |> expect("confirmed count to be 1")
            val exp_invoked = UntypedNode(
                ast::Variant::PathRef(ast::PathRef(invoked_path, t_args)),
                node.source
            )
            return self |> check_invocation(node, exp_invoked, raw_args, exp)
        }
        _ {
            return self |> check_invocation(node, invoked, raw_args, exp)
        }
    }
}

// Checks a given node using the context provided by the given checker state
// and by asserting that its result must be a given concrete type.
// This function should be used whenever a specific type is expected as the result.
pub fun Checker::check(
    self: mut Checker, node: UntypedNode, exp: Type
) -> TypedNode {
    val make_literal: Fun(Variant, ast::Variant[TypedNode]) -> TypedNode = |t, v| {
        val r = Type(t, !IS_MUTABLE, node.source)
        if exp.value != t && exp.value != Variant::Invalid {
            self.messages |> push(Message::unexpected_type(exp, r))
        }
        return TypedNode(v, node.source, r)
    }
    val check_numeric: Fun() -> Type = || {
        match exp.value {
            Integer | Float { return exp }
            _ {
                self.messages |> push(
                    Message::unexpected_numeric(exp, node.source)
                )
                return Type(Variant::Invalid, !IS_MUTABLE, node.source)
            }
        }
    }
    val check_arithmetic: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val n: Type = check_numeric()
        val lhs: TypedNode = self |> check(operands.first, n)
        val rhs: TypedNode = self |> check(operands.second, n)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, n)
    }
    val check_ordering: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        if exp.value != r.value && exp.value != Variant::Invalid {
            self.messages |> push(Message::unexpected_type(exp, r))
        }
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    val check_comparison: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        if exp.value != r.value && exp.value != Variant::Invalid {
            self.messages |> push(Message::unexpected_type(exp, r))
        }
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> join_types(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    match node.value {
        PathRef(ast::PathRef(path, t_args)) {
            val checked: TypedNode = self 
                |> check_path_ref(node, path, t_args, Option::Some(exp))
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
                return TypedNode(
                    checked.value, checked.source, 
                    Type(Variant::Invalid, !IS_MUTABLE, checked.source)
                )
            }
            return checked
        }
        Int(value) {
            return make_literal(Variant::Integer, ast::Variant::Int(value))
        }
        Float(value) {
            return make_literal(Variant::Float, ast::Variant::Float(value))
        }
        Bool(value) {
            return make_literal(Variant::Boolean, ast::Variant::Bool(value))
        }
        Unit {
            return make_literal(Variant::Unit, ast::Variant::Unit)
        }
        String(value) {
            return make_literal(Variant::String, ast::Variant::String(value))
        }
        Closure(c) {
            match exp.value {
                Variant::Function(Pair(exp_arg_t, exp_ret_t)) {
                    val checked: TypedNode
                        = self |> check_closure(node, c, exp_arg_t)
                    if !Type::matches(exp, checked.type) {
                        self.messages |> push(
                            Message::unexpected_type(exp, checked.type)
                        )
                        return TypedNode(
                            checked.value, checked.source, 
                            Type(Variant::Invalid, !IS_MUTABLE, checked.source)
                        )
                    }
                    return checked
                }
                _ {
                    self.messages |> push(
                        Message::unexpected_closure(exp, node.source)
                    )
                    return TypedNode(
                        ast::Variant::Invalid, node.source,
                        Type(Variant::Invalid, !IS_MUTABLE, node.source)
                    )
                }
            }
        }
        Add(o) {
            return check_arithmetic(o, |op| ast::Variant::Add(op))
        }
        Subtract(o) {
            return check_arithmetic(o, |op| ast::Variant::Subtract(op))
        }
        Multiply(o) {
            return check_arithmetic(o, |op| ast::Variant::Multiply(op))
        }
        Divide(o) {
            return check_arithmetic(o, |op| ast::Variant::Divide(op))
        }
        Remainder(o) {
            return check_arithmetic(o, |op| ast::Variant::Remainder(op))
        }
        LessThan(o) {
            return check_ordering(o, |op| ast::Variant::LessThan(op))
        }
        LessThanEqual(o) {
            return check_ordering(o, |op| ast::Variant::LessThanEqual(op))
        }
        Equal(o) {
            return check_comparison(o, |op| ast::Variant::Equal(op))
        }
        NotEqual(o) {
            return check_comparison(o, |op| ast::Variant::NotEqual(op))
        }
        Negate(value) {
            val n: Type = check_numeric()
            val v: TypedNode = self |> check(value, n)
            return TypedNode(ast::Variant::Negate(v), node.source, n)
        }
        Not(value) {
            val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            if exp.value != r.value && exp.value != Variant::Invalid {
                self.messages |> push(Message::unexpected_type(exp, r))
            }
            val v: TypedNode = self |> check(value, r)
            return TypedNode(ast::Variant::Not(v), node.source, r)
        }
        Member(Pair(accessed, mem_name)) {
            val checked: TypedNode = self 
                |> check_member(node, accessed, mem_name)
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
            }
            return checked
        }
        Call(ast::Invocation(invoked, args)) {
            val checked: TypedNode = self
                |> check_invocation(node, invoked, args, Option::Some(exp))
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
            }
            return checked
        }
        PipedCall(ast::Invocation(invoked, args)) {
            val checked: TypedNode = self |> check_piped_invocation(
                node, invoked, args, Option::Some(exp)
            )
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
            }
            return checked
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c = Type(Variant::Boolean, !IS_MUTABLE, cond.source)
            val cond_t: TypedNode = self |> check(cond, c)
            val if_val_t: TypedNode = self |> check(if_val, exp)
            val else_val_t: TypedNode = self |> check(else_val, exp)
            return TypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond_t, if_val_t, else_val_t)),
                node.source,
                Type::join(if_val_t.type, else_val_t.type) |> unwrap_or(exp)
            )
        }

        _ {
            return TypedNode(
                ast::Variant::Invalid, 
                node.source, 
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}

// Checks a given node only using using the context provided by the given checker state.
// The missing extra context in contrast to 'check' reduces functionality when
// checking the given node, and so this function should only be used when
// necessary.
pub fun Checker::infer(
    self: mut Checker, node: UntypedNode
) -> TypedNode {
    val infer_arithmetic: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        val t: Type = self 
            |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, t)
    } 
    val infer_ordering: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    val infer_comparison: Fun(
        Pair[UntypedNode, UntypedNode],
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> join_types(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    match node.value {
        PathRef(ast::PathRef(path, t_args)) {
            return self |> check_path_ref(node, path, t_args, Option::None)
        }
        Int(value) { return TypedNode(
            ast::Variant::Int(value),
            node.source,
            Type(Variant::Integer, !IS_MUTABLE, node.source)
        ) }
        Float(value) { return TypedNode(
            ast::Variant::Float(value),
            node.source,
            Type(Variant::Float, !IS_MUTABLE, node.source)
        ) }
        Bool(value) { return TypedNode(
            ast::Variant::Bool(value),
            node.source,
            Type(Variant::Boolean, !IS_MUTABLE, node.source)
        ) }
        Unit { return TypedNode(
            ast::Variant::Unit,
            node.source,
            Type(Variant::Unit, !IS_MUTABLE, node.source)
        ) }
        String(value) { return TypedNode(
            ast::Variant::String(value),
            node.source,
            Type(Variant::String, !IS_MUTABLE, node.source)
        ) }
        Closure(c) {
            if 0 != (c.args |> length()) {
                self.messages |> push(
                    Message::insufficient_closure_context(node.source)
                )
            }
            return self |> check_closure(node, c, List::empty())
        }
        Add(o) {
            return infer_arithmetic(o, |op| ast::Variant::Add(op))
        }
        Subtract(o) {
            return infer_arithmetic(o, |op| ast::Variant::Subtract(op))
        }
        Multiply(o) {
            return infer_arithmetic(o, |op| ast::Variant::Multiply(op))
        }
        Divide(o) {
            return infer_arithmetic(o, |op| ast::Variant::Divide(op))
        }
        Remainder(o) {
            return infer_arithmetic(o, |op| ast::Variant::Remainder(op))
        }
        LessThan(o) {
            return infer_ordering(o, |op| ast::Variant::LessThan(op))
        }
        LessThanEqual(o) {
            return infer_ordering(o, |op| ast::Variant::LessThanEqual(op))
        }
        Equal(o) {
            return infer_comparison(o, |op| ast::Variant::Equal(op))
        }
        NotEqual(o) {
            return infer_comparison(o, |op| ast::Variant::NotEqual(op))
        }
        Negate(value) {
            val v: TypedNode = self |> infer(value)
            mut r: Type = v.type
            match v.type.value {
                Integer | Float {}
                _ { 
                    self.messages |> push(
                        Message::expected_numeric(v.type, node.source)
                    )
                    r = Type(Variant::Invalid, !IS_MUTABLE, node.source) 
                }
            }
            return TypedNode(ast::Variant::Negate(v), node.source, r)
        }
        Not(value) {
            val r = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val v: TypedNode = self |> check(value, r)
            return TypedNode(ast::Variant::Not(v), node.source, r)
        }
        Member(Pair(accessed, mem_name)) {
            return self |> check_member(node, accessed, mem_name)
        }
        Call(ast::Invocation(invoked, args)) {
            return self |> check_invocation(node, invoked, args, Option::None)
        }
        PipedCall(ast::Invocation(invoked, args)) {
            return self 
                |> check_piped_invocation(node, invoked, args, Option::None)
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, c)
            val if_val_t: TypedNode = self |> infer(if_val)
            val else_val_t: TypedNode = self |> infer(else_val)
            val r: Type = self 
                |> join_types(if_val_t.type, else_val_t.type, node.source)
            return TypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond_t, if_val_t, else_val_t)), 
                node.source, r
            )
        }

        _ {
            return TypedNode(
                ast::Variant::Invalid, 
                node.source, 
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}