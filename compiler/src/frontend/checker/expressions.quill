
mod quill::checker

use quill::*
use quill::types::*
use quill::ast::UntypedNode

// Given a checker state, an annotation node and a concrete type, this function
// attempts to update the current type arguments in the context of the given
// checker state by comparing the given annotation and its concrete type.
// For example, if given the annotation 'List[T]' and a concrete type 'List[Int]',
// this function will update the type argument 'T' in the context of the given
// checker to be of type 'Int'.
fun infer_anno_t_args(
    decl_c: mut Checker,
    anno: UntypedNode,
    given: Type
) -> Bool {
    match given.value {
        Invalid { return false }
        _ {}
    }
    match anno.value {
        TypeRef(Pair(_, ast::PathRef(exp_path, exp_t_args))) {
            val exp_t_arg_c: Int = exp_t_args
                |> map(List::length[UntypedNode])
                |> unwrap_or(0)
            val is_t_arg: Bool = 1 == (exp_path |> length())
                && (decl_c.type_args |> has(exp_path |> at(0)))
            if is_t_arg {
                val arg_name: String = exp_path |> at(0)
                return decl_c.type_args 
                    |> get(arg_name)
                    |> expect("branch depends on map to have type")
                    |> Type::join(given)
                    |> map[Type, Unit](|t| {
                        decl_c.type_args |> set(arg_name, t)
                    })
                    |> is_some()
            }
            match given.value {
                Struct(Pair(_, given_t_args)) |
                Enum(Pair(_, given_t_args)) {
                    val got_t_arg_c: Int = given_t_args |> length()
                    if exp_t_arg_c != got_t_arg_c { return false }
                    return given_t_args |> indices() |> fold(true, |acc, i|
                        infer_anno_t_args(
                            decl_c, 
                            exp_t_args |> expect("length > 0") |> at(i), 
                            given_t_args |> at(i)
                        ) && acc
                    )
                }
                List(given_t_arg) {
                    if exp_t_arg_c != 1 { return false }
                    return infer_anno_t_args(
                        decl_c,
                        exp_t_args |> expect("length == 0") |> at(0),
                        given_t_arg
                    )
                }
                _ {}
            }
        }
        FunctionType(ast::FunctionType(exp_args_t, exp_ret_t)) {
            match given.value {
                Variant::Function(Pair(got_args_t, got_ret_t)) {
                    val exp_arg_c: Int = exp_args_t |> length()
                    val got_arg_c: Int = got_args_t |> length()
                    if exp_arg_c != got_arg_c { return false }
                    val args: Bool = got_args_t |> indices() |> fold(true, |acc, i|
                        infer_anno_t_args(
                            decl_c, exp_args_t |> at(i), got_args_t |> at(i)
                        ) && acc
                    )
                    match exp_ret_t {
                        Some(e_ret_t) {
                            return infer_anno_t_args(decl_c, e_ret_t, got_ret_t)
                                && args
                        }
                        None { return args }
                    }
                }
                _ {}
            }
        }
        _ {}
    }
    return true
}

// Given a call site checker state, a list of value nodes, an optional
// concrete expected return type, a declaration site checker, a list of
// argument type annotations and a result value type annotation, this function
// attempts to infer the type arguments that are used to instantiate
// the symbol, and puts them INTO THE DECLARATION SITE CHECKER.
// For example, if 'add' is defined as a 'fun add[T](a: T, b: T) -> T',
// then providing the arguments 'add(5, 10)' and expecting a result type of 'Int'
// will result in 'T' being inferred to be 'Int'.
fun infer_call_t_args(
    call_c: mut Checker,
    given_args: List[UntypedNode],
    exp_ret_type: Option[Type],
    call_site: Source,

    decl_c: mut Checker,
    exp_arg_types: List[UntypedNode],
    exp_varargs: Bool,
    given_ret_type: UntypedNode
) -> List[TypedNode] {
    val get_va_list_type: Fun(UntypedNode) -> UntypedNode = |n| { match n.value {
        TypeRef(Pair(_, ast::PathRef(List::of("std", "List"), o_e))) |
        TypeRef(Pair(_, ast::PathRef(List::of("List"), o_e))) { return o_e
            |> and_then[List[UntypedNode], UntypedNode](|l_e| l_e |> get(0))
            |> unwrap_or_else(|| UntypedNode(ast::Variant::Invalid, n.source))
        }
        _ { return UntypedNode(ast::Variant::Invalid, n.source) }
    } }
    val old_call_msgs: mut List[Message] = call_c.messages
    call_c.messages = List::empty()
    exp_ret_type |> map[Type, Unit](|ret_t| {
        infer_anno_t_args(decl_c, given_ret_type, ret_t)
    })
    val exp_arg_c: Int = exp_arg_types |> length()
    val checked_args: mut List[Option[TypedNode]] = given_args 
        |> indices()
        |> map[Int, Option[TypedNode]](|_| Option::None)
        |> List::collect()
    mut had_success: Bool = true
    Stream::new[List[Option[TypedNode]]](|| checked_args)
        |> take_while(|c| c |> values() |> any(|n| n |> is_none()))
        |> take_while(|_| had_success)
        |> for_each(|checked| {
            had_success = false
            call_c.messages = List::empty()
            given_args |> indices()
                |> filter(|i| checked_args |> at(i) |> is_none())
                |> for_each(|i| {
                    val arg_val: UntypedNode = given_args |> at(i)
                    val ei = Int::min(exp_arg_c - 1, i)
                    val is_varargs = exp_varargs && i >= exp_arg_c - 1
                    val raw_exp_arg_type: UntypedNode = exp_arg_types |> at(ei)
                    val exp_arg_type = if !is_varargs { raw_exp_arg_type }
                        else { get_va_list_type(raw_exp_arg_type) }
                    val exp_t: TypedNode = decl_c 
                        |> check_annotation(exp_arg_type)
                    val given_t: TypedNode = call_c 
                        |> check(arg_val, exp_t.type)
                    val success: Bool = infer_anno_t_args(
                        decl_c, exp_arg_type, given_t.type
                    )
                    if !success { return unit }
                    checked_args |> set(i, Option::Some(given_t))
                    had_success = true
                })
        })
    val added_msgs: List[Message] = call_c.messages
    call_c.messages = old_call_msgs
    if !had_success {
        added_msgs |> values() |> for_each(|m| { call_c.messages |> push(m) })
    }
    val unknown: mut Sequence[String] = decl_c.type_args 
        |> entries()
        |> filter(|t| {
            match t.second.value {
                Invalid { return true }
                _ { return false }
            }
        })
        |> map[Pair[String, Type], String](|t| t.first)
    unknown |> for_each(|t| {
        call_c.messages |> push(
            Message::failed_t_arg_inference(call_site, t)
        )
    })
    val r_args: List[TypedNode] = checked_args
        |> values()
        |> map[Option[TypedNode], TypedNode](|a| a |> unwrap_or_else(
            || TypedNode(
                ast::Variant::Invalid, call_site, 
                Type(Variant::Invalid, !IS_MUTABLE, call_site)
            )            
        ))
        |> List::collect()
    r_args |> indices() |> for_each(|i| {
        val arg_t: TypedNode = r_args |> at(i)
        val ei = Int::min(exp_arg_c - 1, i)
        val is_varargs = exp_varargs && i >= exp_arg_c - 1
        val raw_exp_arg_type: UntypedNode = exp_arg_types |> at(ei)
        val exp_arg_type = if !is_varargs { raw_exp_arg_type }
            else { get_va_list_type(raw_exp_arg_type) }
        val exp_t: TypedNode = decl_c 
            |> check_annotation(exp_arg_type)
        if Type::matches(exp_t.type, arg_t.type) { return unit }
        call_c.messages |> push(
            Message::unexpected_type(exp_t.type, arg_t.type)
        )
    })
    return r_args
}

// Ensures both of the given concrete types to be of the same numeric type.
// If both of the given types are of the same numeric type, that type is returned.
// If one of the given types is invalid, the other numeric type is returned.
// In all other cases, an appropriate error is generated and an invalid type
// is returned.
fun Checker::operands_numeric(
    self: mut Checker, lhs: Type, rhs: Type, at: Source
) -> Type {
    match Pair(lhs.value, rhs.value) {
        Pair(Variant::Integer, Variant::Integer) |
        Pair(Variant::Float, Variant::Float) |
        Pair(Variant::Invalid, Variant::Integer) |
        Pair(Variant::Invalid, Variant::Float) { 
            return rhs 
        }
        Pair(Variant::Integer, Variant::Invalid) |
        Pair(Variant::Float, Variant::Invalid) { 
            return lhs 
        }
        _ { 
            self.messages |> push(Message::arithmetic_operands(lhs, rhs, at))
            return Type(Variant::Invalid, !IS_MUTABLE, at)
        }
    }
}

// Checks a given closure literal node using the given argument types
// and the context provided by the given checker state.
pub fun Checker::check_closure(
    self: mut Checker, node: UntypedNode, c: ast::Closure[UntypedNode],
    arg_types: List[Type], exp_ret_type: Option[Type]
) -> TypedNode {
    val exp_arg_c: Int = arg_types |> length()
    val got_arg_c: Int = c.args |> length()
    if exp_arg_c != got_arg_c {
        self.messages |> push(Message::unexpected_closure_argc(
            exp_arg_c, got_arg_c, node.source
        ))
    }
    val args_captured: mut List[Box[Bool]] = List::empty()
    val scope_vars: mut Map[String, mut Variable] = range(0, got_arg_c)
        |> map[Int, Pair[String, mut Variable]](|i| {
            val captured_m: mut Box[Bool] = Box(!IS_CAPTURED)
            val captured: Box[Bool] = captured_m
            args_captured |> push(captured)
            return Pair(
                c.args |> at(i),
                Variable(
                    node.source, !IS_MUTABLE, !IS_USED, 
                    arg_types |> get(i) |> unwrap_or_else(
                        || Type(Variant::Invalid, !IS_MUTABLE, node.source)
                    ),
                    captured_m
                )
            )
        })
        |> Map::collect()
    val captures: mut Map[String, Type] = Map::empty()
    val func = Function(List::of(Scope(scope_vars)), captures, exp_ret_type)
    self.functions |> push(func)
    self |> enter_scope()
    val body_t: Pair[List[TypedNode], ScopeExit] 
        = self |> check_statement_list(c.body, !IN_LOOP)
    self |> exit_scope()
    self.functions |> pop()
    val return_type = func.return_type 
        |> unwrap_or_else(|| Type(Variant::Unit, !IS_MUTABLE, node.source))
    val always_returns = body_t.second == ScopeExit::Function 
        || return_type.value == Variant::Unit
    if !always_returns {
        self.messages |> push(
            Message::missing_return(
                func.return_type |> expect(""), 
                node.source
            )
        )
    }
    return TypedNode(
        ast::Variant::Closure(ast::Closure(
            c.args, args_captured, captures, body_t.first
        )),
        node.source,
        Type(
            Variant::Function(Pair(arg_types, return_type)),
            !IS_MUTABLE, node.source    
        )
    )
}

// Internal helper function to turn a list of types and a list of type argument names
// into a map of <type arg name> -> <type>.
pub fun make_full_t_args(types: List[Type], names: List[String], at: Source) -> mut Map[String, Type]
    = range(0, names |> length())
    |> map[Int, Pair[String, Type]](|i| Pair(
        names |> at(i),
        types |> get(i) |> unwrap_or_else(
            || Type(Variant::Invalid, !IS_MUTABLE, at)
        )
    ))
    |> Map::collect()

// Internal helper function to turn a list of types into a list of typed AST nodes
// which have the given types as their types.
// The returned wrapping nodes will have an AST value of 'Invalid' and the same
// sources as the given types.
pub fun wrap_types_nodes(types: List[Type]) -> List[TypedNode]
    = types
    |> values()
    |> map[Type, TypedNode](|t| TypedNode(ast::Variant::Invalid, t.source, t))
    |> List::collect()

// Checks a given member access node.
pub fun Checker::check_member(
    self: mut Checker, node: UntypedNode, 
    accessed: UntypedNode, member_name: String
) -> TypedNode {
    val accessed_t: TypedNode = self |> infer(accessed)
    mut r: Type = Type(Variant::Invalid, !IS_MUTABLE, node.source)
    match accessed_t.type.value {
        Variant::Struct(Pair(path, g_t_args)) {
            r = self.symbols.symbols |> get(path) |> and_then[Symbol, Type](|s| {
                match s.node.value {
                    Structure(ast::CustomType(_, public, t_args, members)) {
                        val hidden: Bool = !public
                            && s.context.module != self.context.module
                        if hidden {
                            self.messages |> push(Message::symbol_private(
                                path, node.source, s.node.source
                            ))
                        }
                        val member_c = Checker(
                            List::empty(),
                            make_full_t_args(g_t_args, t_args, node.source),
                            self.symbols, s.context, 
                            List::empty(), List::empty()
                        )
                        val mem_t: Option[Type] = members
                            |> values()
                            |> find(|m| m.first == member_name)
                            |> map[Pair[String, UntypedNode], TypedNode](
                                |m| member_c |> check_annotation(m.second)
                            )
                            |> map[TypedNode, Type](|t| t.type)
                        if mem_t |> is_none() {
                            self.messages |> push(Message::missing_member(
                                path, member_name, node.source, s.node.source
                            ))
                        }
                        return mem_t
                    }
                    _ { return Option::None }
                }
            }) |> unwrap_or(r)
        }
        Variant::Invalid {}
        _ {
            self.messages |> push(
                Message::expected_struct(accessed_t.type, node.source)
            )
        }
    }
    return TypedNode(
        ast::Variant::Member(Pair(accessed_t, member_name)),
        node.source, r
    )
}

// Checks a given path reference node using the given checker state and 
// optionally using a concrete expected type and returns either:
// - a reference to a local variable
// - a reference to a global variable
// - a reference to a function
// - an enum instantiation
pub fun Checker::check_path_ref(
    self: mut Checker, node: UntypedNode, 
    raw_path: List[String], t_args: Option[List[UntypedNode]],
    exp: Option[Type]
) -> TypedNode {
    if 1 == (raw_path |> length()) {
        val local_name: String = raw_path |> at(0)
        match self |> find_variable(local_name) {
            Some(local) {
                if t_args |> is_some() {
                    self.messages |> push(Message::unexpected_t_args(
                        local_name, node.source
                    ))
                }
                local.used = true
                return TypedNode(
                    ast::Variant::VariableRef(local_name),
                    node.source,
                    local.type
                )
            }
            None {}
        }
    }
    val path: List[String] = self |> expand_path(raw_path)
    val t_args_t: Option[List[TypedNode]] = t_args
        |> map[List[UntypedNode], List[TypedNode]](|args| args
            |> values()
            |> map[UntypedNode, TypedNode](
                |t| self |> check_annotation(t)
            )
            |> List::collect()
        )
    val type_args: List[Type] = t_args_t
        |> map[List[TypedNode], List[Type]](|args| args
            |> values()
            |> map[TypedNode, Type](|t| t.type)
            |> List::collect()    
        )
        |> unwrap_or(List::empty())
    val check_public: Fun(Bool, Symbol) = |p, s| {
        if p || s.context.module == self.context.module { return unit }
        self.messages |> push(Message::symbol_private(
            path, node.source, s.node.source
        ))
    }
    val check_tac: Fun(Int) = |exp_tac| {
        val got_tac: Int = type_args |> length()
        if exp_tac != got_tac {
            self.messages |> push(Message::wrong_type_arg_c(
                path, exp_tac, got_tac, node.source
            ))
        }
    }
    match self.symbols.symbols |> get(path) {
        Some(s) { match s.node.value {
            GlobalVariable(ast::GlobalVariable(
                _, public, _, type, _
            )) {
                check_public(public, s)
                if t_args |> is_some() {
                    self.messages |> push(Message::unexpected_t_args(
                        path |> values() |> join("::"), node.source
                    ))
                }
                val var_c = Checker(
                    List::empty(), Map::empty(),
                    self.symbols, s.context, 
                    List::empty(), List::empty()
                )
                val type_t: TypedNode = var_c |> check_annotation(type)
                val instance: SymbolInstance 
                    = SymbolInstance(path, List::empty())
                self.dependencies |> push(instance)
                return TypedNode(
                    ast::Variant::PathRef(ast::PathRef(path, Option::None)),
                    node.source, type_t.type
                )
            }
            ast::Variant::Function(ast::Function(
                _, public, f_t_args, f_args, false, _, f_ret_t, _
            )) | ast::Variant::ExternalFunction(ast::ExternalFunction(
                _, public, f_t_args, f_args, false, f_ret_t, _
            )) {
                check_public(public, s)
                val func_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, f_t_args, node.source),
                    self.symbols, s.context,
                    List::empty(), List::empty() 
                )
                match Pair(exp, t_args) {
                    Pair(Option::Some(_), Option::None) {
                        val arg_nodes: List[UntypedNode] = f_args
                            |> values()
                            |> map(|a| a.second)
                            |> List::collect()
                        val got = UntypedNode(
                            ast::Variant::FunctionType(ast::FunctionType(
                                arg_nodes, f_ret_t
                            )),
                            s.node.source
                        )
                        infer_call_t_args(
                            self, List::empty(), exp, node.source,
                            func_c, List::empty(), false, got
                        )
                    }
                    _ {
                        check_tac(f_t_args |> length())
                    }
                }                
                val f_arg_types: List[Type] = f_args
                    |> values()
                    |> map[Pair[String, UntypedNode], Type](
                        |a| (func_c |> check_annotation(a.second)).type
                    )
                    |> List::collect()
                val f_ret_type: Type = f_ret_t
                    |> map[UntypedNode, Type](
                        |r| (func_c |> check_annotation(r)).type
                    )
                    |> unwrap_or_else(
                        || Type(Variant::Unit, !IS_MUTABLE, node.source)
                    )
                val r = Type(
                    Variant::Function(Pair(f_arg_types, f_ret_type)),
                    !IS_MUTABLE, node.source
                )
                val final_type_args: List[Type] = f_t_args |> values()
                    |> map[String, Type](|t| func_c.type_args 
                        |> get(t) 
                        |> expect("was inserted earlier")
                    )
                    |> List::collect()
                val instance: SymbolInstance 
                    = SymbolInstance(path, final_type_args)
                self.dependencies |> push(instance)
                return TypedNode(
                    ast::Variant::FunctionRef(ast::PathRef(path, t_args_t)),
                    node.source, r
                )
            }
            _ {}
        } }
        None {}
    }
    val enum_path: List[String] = self |> expand_path(raw_path |> slice_to(-1))
    match self.symbols.symbols |> get(enum_path) {
        Some(s) { match s.node.value {
            Enumeration(ast::CustomType(
                _, public, t_t_args, t_members
            )) {
                check_public(public, s)
                if t_args |> is_some() { check_tac(t_t_args |> length()) }
                val member_name: String = raw_path |> at(-1)
                val o_member: Option[UntypedNode] = t_members
                    |> values()
                    |> find(|m| m.first == member_name)
                    |> map[Pair[String, UntypedNode], UntypedNode](|m| m.second)
                if o_member |> is_none() {
                    self.messages |> push(Message::missing_member(
                        enum_path, member_name, node.source, s.node.source
                    ))
                }
                val member: UntypedNode = o_member |> unwrap_or_else(
                        || UntypedNode(ast::Variant::Invalid, node.source)
                    )
                val result = UntypedNode(
                    ast::Variant::TypeRef(Pair(!IS_MUTABLE, ast::PathRef(
                        enum_path, 
                        Option::Some(t_t_args 
                            |> values()
                            |> map[String, UntypedNode](|t| UntypedNode(
                                ast::Variant::TypeRef(Pair(
                                    !IS_MUTABLE, 
                                    ast::PathRef(List::of(t), Option::None)
                                )),
                                s.node.source
                            ))
                            |> List::collect()
                        )
                    ))),
                    s.node.source
                )
                val value = UntypedNode(ast::Variant::Unit, node.source)
                val enum_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, t_t_args, node.source),
                    self.symbols, s.context,
                    List::empty(), List::empty() 
                )
                val values_t: List[TypedNode] = infer_call_t_args(
                    self, List::of(value), exp, node.source,
                    enum_c, List::of(member), false, result
                )
                val final_type_args: List[Type] = t_t_args |> values()
                    |> map[String, Type](|t| enum_c.type_args 
                        |> get(t) 
                        |> expect("was inserted earlier")
                    )
                    |> List::collect()
                val instance: SymbolInstance 
                    = SymbolInstance(enum_path, final_type_args)
                self.dependencies |> push(instance)
                return TypedNode(
                    ast::Variant::EnumInit(ast::PathInvocation(
                        List::concat(enum_path, List::of(member_name)),
                        values_t, 
                        Option::Some(wrap_types_nodes(final_type_args))
                    )),
                    node.source,
                    Type(
                        Variant::Enum(Pair(enum_path, final_type_args)), 
                        !IS_MUTABLE, node.source
                    )
                )
            }
            _ {}
        } }
        None {}
    }
    self.messages |> push(Message::unknown_path(path, node.source))
    return TypedNode(
        ast::Variant::Invalid, node.source,
        Type(Variant::Invalid, !IS_MUTABLE, node.source)
    )
}

// Checks a given call node using the given checker state and 
// optionally using a concrete expected type and returns either:
// - a call to a named function
// - a structure initialization
// - an enum initialization
// - a call to an arbitrary expression
pub fun Checker::check_invocation(
    self: mut Checker, node: UntypedNode,
    invoked: UntypedNode, args: List[UntypedNode],
    exp: Option[Type]
) -> TypedNode {
    val check_argc: Fun(String, Int) = |invoked, exp_c| {
        val got_c: Int = args |> length()
        if exp_c == got_c { return unit }
        self.messages |> push(
            Message::unexpected_argc(invoked, exp_c, got_c, node.source)
        )
    }
    match invoked.value {
        PathRef(ast::PathRef(raw_path, t_args)) {
            val t_args_t: Option[List[TypedNode]] = t_args
                |> map[List[UntypedNode], List[TypedNode]](|args| args
                    |> values()
                    |> map[UntypedNode, TypedNode](
                        |t| self |> check_annotation(t)
                    )
                    |> List::collect()
                )
            val type_args: List[Type] = t_args_t
                |> map[List[TypedNode], List[Type]](|args| args
                    |> values()
                    |> map[TypedNode, Type](|t| t.type)
                    |> List::collect()    
                )
                |> unwrap_or(List::empty())
            val check_named: Fun(List[String], Symbol, Bool, List[String], List[UntypedNode], Bool, UntypedNode) -> Triplet[List[TypedNode], Type, List[Type]]
            = |path, symbol, public, decl_t_args, exp_arg_t, exp_varargs, got_ret_t| {
                if !public && symbol.context.module != self.context.module {
                    self.messages |> push(Message::symbol_private(
                        path, node.source, symbol.node.source
                    ))
                }
                val exp_arg_c: Int = if !exp_varargs { exp_arg_t |> length() }
                    else { (exp_arg_t |> length()) - 1 }
                val got_arg_c: Int = args |> length()
                if !exp_varargs && got_arg_c != exp_arg_c {
                    self.messages |> push(Message::unexpected_argc(
                        path |> values() |> join("::"),
                        exp_arg_t |> length(), args |> length(),
                        node.source
                    ))
                }
                if exp_varargs && got_arg_c < exp_arg_c {
                    self.messages |> push(Message::unexpected_argc_varargs(
                        path |> values() |> join("::"),
                        (exp_arg_t |> length()) - 1, args |> length(),
                        node.source
                    ))
                }
                val pad_args: List[UntypedNode] 
                    = Int::max(exp_arg_c - got_arg_c, 0)
                    |> List::of_length(
                        UntypedNode(ast::Variant::Invalid, node.source)
                    )
                val final_args: List[UntypedNode] = List::concat(args, pad_args)
                    |> slice_to(
                        if exp_varargs { Int::max(exp_arg_c, got_arg_c) } 
                        else { exp_arg_c }
                    )
                val exp_tac: Int = decl_t_args |> length()
                val got_tac: Int = type_args |> length()
                if (t_args |> is_some()) && exp_tac != got_tac {
                    self.messages |> push(Message::wrong_type_arg_c(
                        path, exp_tac, got_tac, node.source
                    ))
                }
                val symbol_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, decl_t_args, node.source),
                    self.symbols, symbol.context,
                    List::empty(), List::empty() 
                )
                val args_t: List[TypedNode] = infer_call_t_args(
                    self, final_args, exp, node.source,
                    symbol_c, exp_arg_t, exp_varargs, got_ret_t
                )
                val final_type_args: List[Type] = decl_t_args |> values()
                    |> map[String, Type](|t| symbol_c.type_args
                        |> get(t)
                        |> expect("was inserted earlier")
                    )
                    |> List::collect()
                val instance: SymbolInstance 
                    = SymbolInstance(path, final_type_args)
                self.dependencies |> push(instance)
                val result_type = (symbol_c |> check_annotation(got_ret_t)).type
                return Triplet(args_t, result_type, final_type_args)
            }
            val path: List[String] = self |> expand_path(raw_path)
            match self.symbols.symbols |> get(path) {
                Some(s) { match s.node.value {
                    ast::Variant::Function(ast::Function(
                        _, public, f_t_args, f_args, f_varargs, _, o_f_ret_t, _
                    )) | ast::Variant::ExternalFunction(ast::ExternalFunction(
                        _, public, f_t_args, f_args, f_varargs, o_f_ret_t, _
                    )) {
                        val arg_nodes: List[UntypedNode] = f_args
                            |> values()
                            |> map[Pair[String, UntypedNode], UntypedNode](
                                |a| a.second
                            )
                            |> List::collect()
                        val f_ret_t: UntypedNode = o_f_ret_t |> unwrap_or_else(
                            || UntypedNode(
                                ast::Variant::TypeRef(Pair(
                                    !IS_MUTABLE, 
                                    ast::PathRef(
                                        List::of("std", "Unit"), Option::None
                                    )
                                )),
                                s.node.source
                            )
                        )
                        val checked = check_named(
                            path, s, public, f_t_args, arg_nodes, f_varargs, 
                            f_ret_t
                        )
                        return TypedNode(
                            ast::Variant::NamedCall(ast::PathInvocation(
                                path, checked.first,
                                Option::Some(wrap_types_nodes(checked.third))
                            )),
                            node.source, checked.second
                        )
                    }
                    ast::Variant::Structure(ast::CustomType(
                        _, public, t_t_args, t_members
                    )) {
                        val member_nodes: List[UntypedNode] = t_members
                            |> values()
                            |> map[Pair[String, UntypedNode], UntypedNode](
                                |a| a.second
                            )
                            |> List::collect()
                        val t_arg_nodes: List[UntypedNode] = t_t_args
                            |> values()
                            |> map[String, UntypedNode](|t| UntypedNode(
                                ast::Variant::TypeRef(Pair(
                                    !IS_MUTABLE, 
                                    ast::PathRef(List::of(t), Option::None)
                                )),
                                node.source
                            ))
                            |> List::collect()
                        val ret_node = UntypedNode(
                            ast::Variant::TypeRef(Pair(IS_MUTABLE, ast::PathRef(
                                path, Option::Some(t_arg_nodes)
                            ))),
                            node.source
                        )
                        val checked = check_named(
                            path, s, public, t_t_args, member_nodes, false, 
                            ret_node
                        )
                        return TypedNode(
                            ast::Variant::StructInit(ast::PathInvocation(
                                path, checked.first,
                                Option::Some(wrap_types_nodes(checked.third))
                            )),
                            node.source, checked.second
                        )
                    }
                    _ {}
                } }
                None {}
            }
            val enum_path: List[String] = self 
                |> expand_path(raw_path |> slice_to(-1))
            match self.symbols.symbols |> get(enum_path) {
                Some(s) { match s.node.value {
                    ast::Variant::Enumeration(ast::CustomType(
                        _, public, t_t_args, t_members
                    )) {
                        val member_name: String = raw_path |> at(-1)
                        val o_member_node: Option[UntypedNode] = t_members
                            |> values()
                            |> find(|m| m.first == member_name)
                            |> map[Pair[String, UntypedNode], UntypedNode](
                                |m| m.second
                            )
                        if o_member_node |> is_none() {
                            self.messages |> push(Message::missing_member(
                                enum_path, member_name, 
                                node.source, s.node.source
                            ))
                        }
                        val member_node: UntypedNode = o_member_node
                            |> unwrap_or_else(|| UntypedNode(
                                ast::Variant::Invalid, node.source
                            ))
                        val t_arg_nodes: List[UntypedNode] = t_t_args
                            |> values()
                            |> map[String, UntypedNode](|t| UntypedNode(
                                ast::Variant::TypeRef(Pair(
                                    !IS_MUTABLE, 
                                    ast::PathRef(List::of(t), Option::None)
                                )),
                                node.source
                            ))
                            |> List::collect()
                        val ret_node = UntypedNode(
                            ast::Variant::TypeRef(Pair(
                                !IS_MUTABLE, 
                                ast::PathRef(
                                    enum_path, Option::Some(t_arg_nodes)
                                )
                            )),
                            node.source
                        )
                        val checked = check_named(
                            enum_path, s, public, t_t_args, 
                            List::of(member_node), false, ret_node
                        )
                        return TypedNode(
                            ast::Variant::EnumInit(ast::PathInvocation(
                                List::concat(enum_path, List::of(member_name)), 
                                checked.first,
                                Option::Some(wrap_types_nodes(checked.third))
                            )),
                            node.source, checked.second
                        )
                    }
                    _ {}
                } }
                None {}
            }
        }
        _ {}
    }
    val called_t: TypedNode = self |> infer(invoked)
    val inv = Type(Variant::Invalid, !IS_MUTABLE, node.source)
    mut exp_arg_t: List[Type] = List::empty()
    mut exp_ret_t: Type = inv
    match called_t.type.value {
        Variant::Function(Pair(arg_types, ret_type)) {
            exp_arg_t = arg_types
            exp_ret_t = ret_type
            check_argc(called_t.type |> as_string(), exp_arg_t |> length())
        }
        Invalid {
            return TypedNode(
                ast::Variant::Invalid, node.source,
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
        _ { 
            self.messages |> push(
                Message::expected_function(called_t.type, node.source)
            )
        }
    }
    val args_t: List[TypedNode] = args
        |> indices()
        |> map[Int, TypedNode](|i| {
            val t: Type = exp_arg_t |> get(i) |> unwrap_or(inv)
            return self |> check(args |> at(i), t)
        })
        |> List::collect()
    return TypedNode(
        ast::Variant::Call(ast::Invocation(called_t, args_t)),
        node.source, exp_ret_t
    )
}

// Checks a given piped call node using the given checker state and 
// optionally using a concrete expected type and returns either:
// - a call to a named function
// - a structure initialization
// - an enum initialization
// - a call to an arbitrary expression
pub fun Checker::check_piped_invocation(
    self: mut Checker, node: UntypedNode,
    invoked: UntypedNode, raw_args: List[UntypedNode],
    exp: Option[Type]
) -> TypedNode {
    val receiver: UntypedNode = raw_args |> at(0)
    match invoked.value {
        PathRef(ast::PathRef(raw_path, t_args)) {
            if 1 != (raw_path |> length()) {
                return self |> check_invocation(node, invoked, raw_args, exp)
            }
            val exp_path: List[String] = self |> expand_path(raw_path)
            if self.symbols.symbols |> has(exp_path) {
                return self |> check_invocation(node, invoked, raw_args, exp)
            }
            val t_args_t: Option[List[TypedNode]] = t_args
                |> map[List[UntypedNode], List[TypedNode]](|args| args
                    |> values()
                    |> map[UntypedNode, TypedNode](
                        |t| self |> check_annotation(t)
                    )
                    |> List::collect()
                )
            val type_args: List[Type] = t_args_t
                |> map[List[TypedNode], List[Type]](|args| args
                    |> values()
                    |> map[TypedNode, Type](|t| t.type)
                    |> List::collect()    
                )
                |> unwrap_or(List::empty())
            val receiver_t: TypedNode = self |> infer(receiver)
            val is_receiver: Fun(Symbol, List[String], UntypedNode) -> Bool
            = |symbol, decl_t_args, receiver_ann| {
                val symbol_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, decl_t_args, node.source),
                    self.symbols, symbol.context,
                    List::empty(), List::empty() 
                )
                infer_anno_t_args(
                    symbol_c, receiver_ann, receiver_t.type
                )
                val receiver_ann_t: TypedNode = symbol_c
                    |> check_annotation(receiver_ann)
                return Type::matches(receiver_ann_t.type, receiver_t.type)
            }
            val is_candidate: Fun(List[String]) -> Bool 
            = |p| { match self.symbols.symbols |> get(p) {
                Some(s) { match s.node.value {
                    ast::Variant::Function(ast::Function(
                        _, _, s_t_args, s_args, varargs, _, _, _
                    )) |
                    ExternalFunction(ast::ExternalFunction(
                        _, _, s_t_args, s_args, varargs, _, _
                    )) {
                        val s_arg_c: Int = s_args |> length()
                        val min_req_c: Int = if varargs { 2 } else { 1 } 
                        if s_arg_c < min_req_c { return false }
                        val receiver_ann: UntypedNode = (s_args |> at(0))
                            .second
                        return is_receiver(s, s_t_args, receiver_ann)
                    }
                    Structure(ast::CustomType(
                        _, _, s_t_args, s_args
                    )) |
                    Enumeration(ast::CustomType(
                        _, _, s_t_args, s_args
                    )) {
                        if (s_args |> length()) == 0 { return false }
                        val receiver_ann: UntypedNode = (s_args |> at(0))
                            .second
                        return is_receiver(s, s_t_args, receiver_ann)
                    }
                    _ { return false }
                } }
                None { return false }
            } }
            val candidates: Set[List[String]] = self.context.aliases
                |> values()
                |> map[List[String], List[String]](
                    |p| List::concat(p, raw_path)
                )
                |> filter(is_candidate)
                |> Set::collect()
            val candidate_c: Int = candidates |> size()
            if candidate_c == 0 {
                return self |> check_invocation(node, invoked, raw_args, exp)
            }
            if candidate_c > 1 {
                self.messages |> push(Message::ambiguous_pipe(
                    receiver_t.type, candidates, node.source
                ))
                return TypedNode(
                    ast::Variant::Invalid, node.source,
                    Type(Variant::Invalid, !IS_MUTABLE, node.source)
                )
            }
            val invoked_path: List[String] = candidates
                |> values() |> next() |> expect("confirmed count to be 1")
            val exp_invoked = UntypedNode(
                ast::Variant::PathRef(ast::PathRef(invoked_path, t_args)),
                node.source
            )
            return self |> check_invocation(node, exp_invoked, raw_args, exp)
        }
        _ {
            return self |> check_invocation(node, invoked, raw_args, exp)
        }
    }
}

// Checks an overloaded operator using the context provided by the given
// checker state by first inferring all given operands and looking for
// for a defined function 'T::op', where 'T' is the first type of the operand
// and 'op' is the provided name of the operator. 
// If a function is found, it is instantiated and a call to the function is returned.
// If no function is found, an invalid AST node is returned and an error is reported.
// If a function is found but the argument types don't match, an error is reported.
pub fun Checker::infer_overloaded_operator(
    self: mut Checker, node: UntypedNode, name: String,
    operands: List[UntypedNode]
) -> TypedNode {
    val ch_operands: List[TypedNode] 
        = operands |> values()
        |> map[UntypedNode, TypedNode](|n| self |> infer(n))
        |> List::collect()
    val operand_c: Int = ch_operands |> length()
    val receiver: Type = (ch_operands |> at(0)).type
    if receiver.value == Variant::Invalid {
        return TypedNode(
            ast::Variant::Invalid, node.source,
            Type(Variant::Invalid, !IS_MUTABLE, node.source)
        )
    }
    val path: List[String] = receiver |> as_path() |> concat(List::of(name))
    val missing_impl: Fun() -> TypedNode = || {
        self.messages |> push(
            Message::missing_operator_impl(name, ch_operands, node.source)
        )
        return TypedNode(
            ast::Variant::Invalid, node.source,
            Type(Variant::Invalid, !IS_MUTABLE, node.source)
        )
    }
    match self.symbols.symbols |> get(path) {
        Some(s) { match s.node.value {
            ast::Variant::Function(ast::Function(
                _, public, t_arg_names, args, false, _, ret_type, _
            )) |
            ExternalFunction(ast::ExternalFunction(
                _, public, t_arg_names, args, false, ret_type, _
            )) { 
                if operand_c != (args |> length()) { return missing_impl() } 
                if !public && s.context.module != self.context.module {
                    self.messages |> push(Message::symbol_private(
                        path, node.source, s.node.source
                    ))
                }
                val symbol_c = Checker(
                    List::empty(),
                    t_arg_names |> values()
                        |> map[String, Pair[String, Type]](|t| Pair(
                            t, Type(Variant::Invalid, !IS_MUTABLE, node.source)
                        ))
                        |> Map::collect(),
                    self.symbols, s.context,
                    List::empty(), List::empty() 
                )
                range(0, operand_c) |> for_each(|i| {
                    val got_t: Type = (ch_operands |> at(i)).type
                    infer_anno_t_args(
                        symbol_c, 
                        (args |> at(i)).second, 
                        got_t
                    )
                    val exp_t: TypedNode = symbol_c 
                        |> check_annotation((args |> at(i)).second)
                    if Type::matches(exp_t.type, got_t) { return unit }
                    self.messages |> push(
                        Message::unexpected_type(exp_t.type, got_t)
                    )
                })
                val final_type_args: List[Type] = t_arg_names |> values()
                    |> map[String, Type](|t| symbol_c.type_args
                        |> get(t)
                        |> expect("was inserted earlier")
                    )
                    |> List::collect()
                val instance: SymbolInstance 
                    = SymbolInstance(path, final_type_args)
                self.dependencies |> push(instance)
                val result_type = ret_type 
                    |> map[UntypedNode, Type](
                        |t| (symbol_c |> check_annotation(t)).type
                    )
                    |> unwrap_or_else(
                        || Type(Variant::Invalid, !IS_MUTABLE, s.node.source)
                    )
                return TypedNode(
                    ast::Variant::NamedCall(ast::PathInvocation(
                        path, ch_operands, 
                        Option::Some(wrap_types_nodes(final_type_args))
                    )),
                    node.source, result_type
                )
            }
            _ { return missing_impl() }
        } }
        None { return missing_impl() }
    }
}

// Checks a given node using the context provided by the given checker state
// and by asserting that its result must be a given concrete type.
// This function should be used whenever a specific type is expected as the result.
pub fun Checker::check(
    self: mut Checker, node: UntypedNode, exp: Type
) -> TypedNode {
    val make_literal: Fun(Variant, ast::Variant[TypedNode]) -> TypedNode = |t, v| {
        val r = Type(t, !IS_MUTABLE, node.source)
        if exp.value != t && exp.value != Variant::Invalid {
            self.messages |> push(Message::unexpected_type(exp, r))
        }
        return TypedNode(v, node.source, r)
    }
    val check_overloaded_operator: Fun(String, List[UntypedNode]) -> TypedNode 
    = |name, operands| {
        val checked: TypedNode = self 
            |> infer_overloaded_operator(node, name, operands)
        if Type::matches(exp, checked.type) { return checked }
        self.messages |> push(
            Message::unexpected_type(exp, checked.type)
        )
        return TypedNode(
            checked.value, checked.source, 
            Type(Variant::Invalid, !IS_MUTABLE, checked.source)
        )
    }
    match node.value {
        PathRef(ast::PathRef(path, t_args)) {
            val checked: TypedNode = self 
                |> check_path_ref(node, path, t_args, Option::Some(exp))
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
                return TypedNode(
                    checked.value, checked.source, 
                    Type(Variant::Invalid, !IS_MUTABLE, checked.source)
                )
            }
            return checked
        }
        Int(value) {
            return make_literal(Variant::Integer, ast::Variant::Int(value))
        }
        Float(value) {
            return make_literal(Variant::Float, ast::Variant::Float(value))
        }
        Bool(value) {
            return make_literal(Variant::Boolean, ast::Variant::Bool(value))
        }
        Unit {
            return make_literal(Variant::Unit, ast::Variant::Unit)
        }
        String(value) {
            return make_literal(Variant::String, ast::Variant::String(value))
        }
        Closure(c) {
            match exp.value {
                Variant::Function(Pair(exp_arg_t, exp_ret_t)) {
                    val checked: TypedNode = self |> check_closure(
                        node, c, exp_arg_t, Option::Some(exp_ret_t)
                    )
                    if !Type::matches(exp, checked.type) {
                        self.messages |> push(
                            Message::unexpected_type(exp, checked.type)
                        )
                        return TypedNode(
                            checked.value, checked.source, 
                            Type(Variant::Invalid, !IS_MUTABLE, checked.source)
                        )
                    }
                    return checked
                }
                _ {
                    self.messages |> push(
                        Message::unexpected_closure(exp, node.source)
                    )
                    return TypedNode(
                        ast::Variant::Invalid, node.source,
                        Type(Variant::Invalid, !IS_MUTABLE, node.source)
                    )
                }
            }
        }
        Add(Pair(lhs, rhs)) {
            return check_overloaded_operator("plus", List::of(lhs, rhs))
        }
        Subtract(Pair(lhs, rhs)) {
            return check_overloaded_operator("minus", List::of(lhs, rhs))
        }
        Multiply(Pair(lhs, rhs)) {
            return check_overloaded_operator("times", List::of(lhs, rhs))
        }
        Divide(Pair(lhs, rhs)) {
            return check_overloaded_operator("div", List::of(lhs, rhs))
        }
        Remainder(Pair(lhs, rhs)) {
            return check_overloaded_operator("rem", List::of(lhs, rhs))
        }
        LessThan(Pair(lhs, rhs)) {
            return check_overloaded_operator("lt", List::of(lhs, rhs))
        }
        GreaterThan(Pair(lhs, rhs)) {
            return check_overloaded_operator("gt", List::of(lhs, rhs))
        }
        LessThanEqual(Pair(lhs, rhs)) {
            return check_overloaded_operator("lt_eq", List::of(lhs, rhs))
        }
        GreaterThanEqual(Pair(lhs, rhs)) {
            return check_overloaded_operator("gt_eq", List::of(lhs, rhs))
        }
        Equal(Pair(lhs, rhs)) {
            return check_overloaded_operator("eq", List::of(lhs, rhs))
        }
        NotEqual(Pair(lhs, rhs)) {
            return check_overloaded_operator("not_eq", List::of(lhs, rhs))
        }
        Negate(value) {
            return check_overloaded_operator("u_minus", List::of(value))
        }
        Not(value) {
            return check_overloaded_operator("not", List::of(value))
        }
        Member(Pair(accessed, mem_name)) {
            val checked: TypedNode = self 
                |> check_member(node, accessed, mem_name)
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
            }
            return checked
        }
        Call(ast::Invocation(invoked, args)) {
            val checked: TypedNode = self
                |> check_invocation(node, invoked, args, Option::Some(exp))
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
            }
            return checked
        }
        PipedCall(ast::Invocation(invoked, args)) {
            val checked: TypedNode = self |> check_piped_invocation(
                node, invoked, args, Option::Some(exp)
            )
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
            }
            return checked
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c = Type(Variant::Boolean, !IS_MUTABLE, cond.source)
            val cond_t: TypedNode = self |> check(cond, c)
            val if_val_t: TypedNode = self |> check(if_val, exp)
            val else_val_t: TypedNode = self |> check(else_val, exp)
            return TypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond_t, if_val_t, else_val_t)),
                node.source,
                Type::join(if_val_t.type, else_val_t.type) |> unwrap_or(exp)
            )
        }

        _ {
            return TypedNode(
                ast::Variant::Invalid, 
                node.source, 
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}

// Checks a given node only using using the context provided by the given checker state.
// The missing extra context in contrast to 'check' reduces functionality when
// checking the given node, and so this function should only be used when
// necessary.
pub fun Checker::infer(
    self: mut Checker, node: UntypedNode
) -> TypedNode {
    match node.value {
        PathRef(ast::PathRef(path, t_args)) {
            return self |> check_path_ref(node, path, t_args, Option::None)
        }
        Int(value) { return TypedNode(
            ast::Variant::Int(value),
            node.source,
            Type(Variant::Integer, !IS_MUTABLE, node.source)
        ) }
        Float(value) { return TypedNode(
            ast::Variant::Float(value),
            node.source,
            Type(Variant::Float, !IS_MUTABLE, node.source)
        ) }
        Bool(value) { return TypedNode(
            ast::Variant::Bool(value),
            node.source,
            Type(Variant::Boolean, !IS_MUTABLE, node.source)
        ) }
        Unit { return TypedNode(
            ast::Variant::Unit,
            node.source,
            Type(Variant::Unit, !IS_MUTABLE, node.source)
        ) }
        String(value) { return TypedNode(
            ast::Variant::String(value),
            node.source,
            Type(Variant::String, !IS_MUTABLE, node.source)
        ) }
        Closure(c) {
            if 0 != (c.args |> length()) {
                self.messages |> push(
                    Message::insufficient_closure_context(node.source)
                )
            }
            return self |> check_closure(node, c, List::empty(), Option::None)
        }
        Add(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "plus", List::of(lhs, rhs))
        }
        Subtract(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "minus", List::of(lhs, rhs))
        }
        Multiply(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "times", List::of(lhs, rhs))
        }
        Divide(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "div", List::of(lhs, rhs))
        }
        Remainder(Pair(lhs, rhs)) {
            return self
                |> infer_overloaded_operator(node, "rem", List::of(lhs, rhs))
        }
        LessThan(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "lt", List::of(lhs, rhs))
        }
        GreaterThan(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "gt", List::of(lhs, rhs))
        }
        LessThanEqual(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "lt_eq", List::of(lhs, rhs))
        }
        GreaterThanEqual(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "gt_eq", List::of(lhs, rhs))
        }
        Equal(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "eq", List::of(lhs, rhs))
        }
        NotEqual(Pair(lhs, rhs)) {
            return self 
                |> infer_overloaded_operator(node, "not_eq", List::of(lhs, rhs))
        }
        Negate(value) {
            return self
                |> infer_overloaded_operator(node, "u_minus", List::of(value))
        }
        Not(value) {
            return self
                |> infer_overloaded_operator(node, "not", List::of(value))
        }
        Member(Pair(accessed, mem_name)) {
            return self |> check_member(node, accessed, mem_name)
        }
        Call(ast::Invocation(invoked, args)) {
            return self |> check_invocation(node, invoked, args, Option::None)
        }
        PipedCall(ast::Invocation(invoked, args)) {
            return self 
                |> check_piped_invocation(node, invoked, args, Option::None)
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, c)
            val if_val_t: TypedNode = self |> infer(if_val)
            val else_val_t: TypedNode = self |> infer(else_val)
            val r: Type = self 
                |> join_types(if_val_t.type, else_val_t.type, node.source)
            return TypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond_t, if_val_t, else_val_t)), 
                node.source, r
            )
        }

        _ {
            return TypedNode(
                ast::Variant::Invalid, 
                node.source, 
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}