
mod quill::checker

use quill::*
use quill::types::*
use quill::ast::UntypedNode

pub val IN_LOOP: Bool = true

// Checks the given list of nodes using the context provided by the given
// checker state. 'in_loop' may be used to specify if 'continue' and 'break'
// may be used in the provided nodes (and their children).
// The function returns both the equivalent typed nodes and a scope exit
// representing the highest level scope exit that the checker can guarantee
// will always be executed.
// In addition, dead code warnings are generated for any statements from the
// list which the checker is sure will never be reached.
pub fun Checker::check_statement_list(
    self: mut Checker, nodes: List[UntypedNode], in_loop: Bool
) -> Pair[List[TypedNode], ScopeExit] {
    val start: Triplet[mut List[TypedNode], ScopeExit, Option[Source]]
        = Triplet(List::empty(), ScopeExit::None, Option::None)
    val checked = nodes
        |> values()
        |> map[UntypedNode, Pair[TypedNode, ScopeExit]](
            |n| self |> check_statement(n, in_loop)
        )
        |> fold(start, |prev, curr| {
            val nodes: mut List[TypedNode] = prev.first
            val prev_exit: ScopeExit = prev.second
            val prev_dead: Option[Source] = prev.third
            val curr_node: TypedNode = curr.first
            val curr_exit: ScopeExit = curr.second
            nodes |> push(curr_node)
            val next_exit: ScopeExit = if prev_exit != ScopeExit::None 
                { prev_exit } else { curr_exit }
            val next_dead: Option[Source] = prev_dead
                |> map[Source, Source](|d| Source::range(d, curr_node.source))
                |> or_else(|| if prev_exit != ScopeExit::None 
                    { Option::Some(curr_node.source) } else { Option::None[Source] }
                )
            return Triplet(nodes, next_exit, next_dead)
        })
    checked.third |> map[Source, Unit](|dead| {
        self.messages |> push(Message::dead_statements(dead))
    })
    return Pair(checked.first, checked.second)
}

// Determines if a given node can be used as the left hand side operand
// for an assignment using the context provided by the given checker state.
pub fun Checker::is_assignable(
    self: mut Checker, node: TypedNode
) -> Bool {
    match node.value {
        PathRef(ast::PathRef(path, Option::None)) {
            match self.symbols.symbols |> get(path) {
                // not found error handled elsewhere
                None { return IS_MUTABLE } 
                Some(symbol) {
                    match symbol.node.value {
                        // public / private check handled elsewhere
                        GlobalVariable(v) { return v.mutable } 
                        _ { return !IS_MUTABLE }
                    }
                }
            }
        }
        VariableRef(name) {
            match self |> find_variable(name) {
                // not found error handled elsewhere
                None { return IS_MUTABLE }
                // public / private check handled elsewhere
                Some(variable) { return variable.mutable }
            }
        }
        Member(Pair(accessed, _)) {
            // public / private check handled elsewhere
            return accessed.type.mutable
        } 

        Invalid { return IS_MUTABLE }
        _ { return !IS_MUTABLE }
    }
}

pub enum PatternLoc(
    StructMember: String,
    EnumMember: String
)
pub enum PatternCond(
    EnumVariant: String,
    Value: TypedNode
)
pub struct Pattern(
    captures: mut List[Pair[List[PatternLoc], Option[String]]],
    conditions: mut List[Pair[List[PatternLoc], PatternCond]]
)

// Checks a singular `match` branch pattern. This behaves the same as `check`,
// but with a few special rules:
// - unknown variables DO NOT error - they are captures
// - if a path reference is a member of an expected enum type, instantiate that enum
// - if a called path is a member of an expected enum type, instantiate that enum
// These rules are applied to the given node, and to its children if the node is:
// - a structure initialization
// - an enum initialization
// The function writes resulting conditions and captures into the given `pattern`.
pub fun Checker::check_match_pattern(
    self: mut Checker, node: UntypedNode, exp: Type,
    pattern: mut Pattern, path: List[PatternLoc]
) -> TypedNode {
    val exp_enum_path: Fun() -> Option[List[String]] = || {
        match exp.value { 
            Enum(Pair(enum_path, _)) { return Option::Some(enum_path) } 
            _ { return Option::None }
        }
    }
    val enum_has_member: Fun(String) -> Bool = |name| exp_enum_path()
        |> and_then[List[String], Symbol](|p| self.symbols.symbols |> get(p))
        |> and_then[Symbol, Pair[String, UntypedNode]](|s| {
            match s.node.value {
                Enumeration(ast::CustomType(_, _, _, members)) {
                    return members |> values() |> find(|m| m.first == name)
                }
                _ { return Option::None }
            }
        })
        |> is_some()
    val default_check: Fun() -> TypedNode = || {
        val typed: TypedNode = self |> check(node, exp)
        val cond: Pair[List[PatternLoc], PatternCond] 
            = Pair(path, PatternCond::Value(typed))
        pattern.conditions |> push(cond)
        return typed
    }
    match node.value {
        PathRef(ast::PathRef(ref_path, ref_t_args)) {
            if ref_path |> length() |> is_not(1) { return default_check() }
            val name: String = ref_path |> at(0)
            if enum_has_member(name) {
                val repl = UntypedNode(
                    ast::Variant::PathRef(ast::PathRef(
                        exp_enum_path() 
                            |> expect("required by 'enum_has_member'")
                            |> concat(List::of(name)),
                        ref_t_args
                    )),
                    node.source
                )
                return self |> check_match_pattern(repl, exp, pattern, path)
            }
            val local: Option[Variable] = self |> find_variable(name)
            if local |> is_none() {
                val n: Option[String] = if name != "_" { Option::Some(name) } 
                    else { Option::None[String] }
                val capture: Pair[List[PatternLoc], Option[String]] 
                    = Pair(path, n)
                pattern.captures |> push(capture)
                return TypedNode(
                    ast::Variant::VariableRef(name), node.source, exp
                )
            }
            return default_check()
        }
        Call(ast::Invocation(
            UntypedNode(ast::Variant::PathRef(ast::PathRef(ref_path, o_ref_t_args)), _),
            args
        )) {
            val struct_path: List[String] = self |> expand_path(ref_path)
            val raw_enum_path: List[String] = self 
                |> expand_path(ref_path |> slice_to(-1))
            val check_type_args: Fun(List[String], List[Type]) -> List[TypedNode]
                = |symbol_path, exp_t_args| {
                    val ref_t_args: List[UntypedNode] = o_ref_t_args
                        |> unwrap_or(List::empty())
                    val exp_tac: Int = exp_t_args |> length()
                    val got_tac: Int = ref_t_args |> length()
                    if exp_tac != got_tac && (o_ref_t_args |> is_some()) {
                        self.messages |> push(Message::wrong_type_arg_c(
                            symbol_path, exp_tac, got_tac, node.source
                        ))
                    }
                    return range(0, Int::min(exp_tac, got_tac)) 
                        |> map[Int, TypedNode](|ta_i| {
                            val exp_ta: Type = exp_t_args |> at(ta_i)
                            val got_ta: TypedNode = self 
                                |> check_annotation(ref_t_args |> at(ta_i))
                            if !Type::matches(exp_ta, got_ta.type) {
                                self.messages |> push(
                                    Message::unexpected_type(exp, got_ta.type)
                                )
                            }
                            return got_ta
                        })
                        |> List::collect()
                }
            val symbol_as_type: Fun(Symbol) -> Option[ast::CustomType[UntypedNode]] 
            = |s| {
                match s.node.value {
                    Structure(t) | Enumeration(t) { return Option::Some(t) }
                    _ { return Option::None }
                }
            }
            val got_arg_c: Int = args |> length()
            val check_arg_c: Fun(List[String], Int) = |symbol_path, exp_arg_c| {
                if exp_arg_c == got_arg_c { return unit }
                self.messages |> push(Message::unexpected_argc(
                    symbol_path |> values() |> join("::"),
                    exp_arg_c, got_arg_c, node.source
                ))
            }
            val check_public: Fun(List[String], Bool, Symbol) 
            = |symbol_path, p, s| {
                if p || s.context.module == self.context.module { return unit }
                self.messages |> push(Message::symbol_private(
                    symbol_path, node.source, s.node.source
                ))
            }
            match exp.value {
                Struct(Pair(struct_path, s_t_args)) {
                    val ref_t_args_t: List[TypedNode] 
                        = check_type_args(struct_path, s_t_args)
                    val s: Symbol = self.symbols.symbols 
                        |> get(struct_path)
                        |> expect("path was referenced by expected type")
                    val t: ast::CustomType[UntypedNode] = symbol_as_type(s)
                        |> expect("symbol was referenced by expected type")
                    check_public(struct_path, t.public, s)
                    check_arg_c(struct_path, t.members |> length())
                    val decl_c = Checker(
                        List::empty(),
                        make_full_t_args(s_t_args, t.t_args, node.source),
                        self.symbols, s.context,
                        self.dependencies, List::empty() 
                    )
                    val args_t: List[TypedNode] 
                        = range(0, Int::min(t.members |> length(), got_arg_c))
                        |> map[Int, TypedNode](|arg_i| {
                            val member = t.members |> at(arg_i)
                            val loc: PatternLoc 
                                = PatternLoc::StructMember(member.first)
                            val exp_t: TypedNode = decl_c 
                                |> check_annotation(member.second)
                            return self |> check_match_pattern(
                                args |> at(arg_i), exp_t.type, 
                                pattern, List::concat(path, List::of(loc))
                            )
                        })
                        |> List::collect()
                    return TypedNode(
                        ast::Variant::StructInit(ast::PathInvocation(
                            struct_path, args_t, 
                            o_ref_t_args |> map(|_| ref_t_args_t)
                        )),
                        node.source, exp
                    )
                }
                Enum(Pair(enum_path, e_t_args)) {
                    val path_matches: Bool = raw_enum_path == enum_path
                        || (raw_enum_path |> length() |> is(0))
                    if !path_matches { return default_check() }
                    val ref_t_args_t: List[TypedNode]
                        = check_type_args(enum_path, e_t_args)
                    val s: Symbol = self.symbols.symbols 
                        |> get(enum_path)
                        |> expect("path was referenced by expected type")
                    val t: ast::CustomType[UntypedNode] = symbol_as_type(s)
                        |> expect("symbol was referenced by expected type")
                    check_public(enum_path, t.public, s)
                    check_arg_c(enum_path, 1)
                    val decl_c = Checker(
                        List::empty(),
                        make_full_t_args(e_t_args, t.t_args, node.source),
                        self.symbols, s.context,
                        self.dependencies, List::empty() 
                    )
                    val member_name: String = ref_path |> at(-1)
                    val member: Option[Pair[String, UntypedNode]] = t.members
                        |> values()
                        |> find(|m| member_name == m.first)
                    if member |> is_none() {
                        self.messages |> push(Message::missing_member(
                            enum_path, member_name, node.source, s.node.source
                        ))
                    }
                    val args_t: List[TypedNode] = member 
                        |> and_then[Pair[String, UntypedNode], TypedNode](|m|
                            args |> get(0) |> map[UntypedNode, TypedNode](|a| {
                                val loc: PatternLoc 
                                    = PatternLoc::EnumMember(member_name)
                                val exp_t: TypedNode = decl_c 
                                    |> check_annotation(m.second)
                                return self |> check_match_pattern(
                                    a, exp_t.type,
                                    pattern, List::concat(path, List::of(loc))
                                )
                            })
                        )
                        |> as_seq()
                        |> List::collect()
                    return TypedNode(
                        ast::Variant::EnumInit(ast::PathInvocation(
                            List::concat(enum_path, List::of(member_name)), 
                            args_t, 
                            o_ref_t_args |> map(|_| ref_t_args_t)
                        )),
                        node.source, exp
                    )
                }
                _ {
                    return default_check()
                }
            }
        }
        _ {
            return default_check()
        }
    }
}

// Checks a singular statement node using the context provided by the given
// checker state. 'in_loop' may be used to specify if 'continue' and 'break'
// may be used in the node (or any children).
// The function returns both the checked node and a scope exit representing
// the highest guaranteed scope exit executed by the provided node.
pub fun Checker::check_statement(
    self: mut Checker, node: UntypedNode, in_loop: Bool
) -> Pair[TypedNode, ScopeExit] {
    val make_node: Fun(ast::Variant[TypedNode]) -> TypedNode
        = |v| TypedNode(
            v, node.source, Type(Variant::Unit, !IS_MUTABLE, node.source)
        )
    match node.value {
        LocalVariable(v) { match v.type {
            Some(ann) {
                val ann_t: TypedNode = self |> check_annotation(ann)
                val value_t: TypedNode = self |> check(v.value, ann_t.type)
                val scope: Scope = self |> scope()
                scope.locals |> set(v.name, Variable(
                    node.source, v.mutable, !IS_USED, ann_t.type
                ))
                return Pair(
                    make_node(ast::Variant::LocalVariable(ast::LocalVariable(
                        v.name, v.mutable, Option::Some(ann_t), value_t
                    ))), 
                    ScopeExit::None
                )
            }
            None {
                val value_t: TypedNode = self |> infer(v.value)
                val scope: Scope = self |> scope()
                scope.locals |> set(v.name, Variable(
                    node.source, v.mutable, !IS_USED, value_t.type
                ))
                return Pair(
                    make_node(ast::Variant::LocalVariable(ast::LocalVariable(
                        v.name, v.mutable, Option::None, value_t
                    ))), 
                    ScopeExit::None
                )
            }
        } }
        Assignment(Pair(dest, value)) {
            val dest_t: TypedNode = self |> infer(dest)
            val assignable: Bool = self |> is_assignable(dest_t)
            if !assignable {
                self.messages |> push(Message::const_assignment(dest.source))
            }
            val value_t: TypedNode = self |> check(value, dest_t.type)
            return Pair(
                make_node(ast::Variant::Assignment(Pair(dest_t, value_t))), 
                ScopeExit::None
            )
        }
        Return(value) {
            val func: mut Function = self.functions |> at(-1)
            match func.return_type {
                Some(pre_ret_t) {
                    val value_t: TypedNode = self |> check(value, pre_ret_t)
                    func.return_type = Option::Some(self |> join_types(
                        pre_ret_t, value_t.type, node.source
                    ))
                    return Pair(
                        make_node(ast::Variant::Return(value_t)),
                        ScopeExit::Function
                    )
                }
                None {
                    val value_t: TypedNode = self |> infer(value)
                    func.return_type = Option::Some(value_t.type)
                    return Pair(
                        make_node(ast::Variant::Return(value_t)),
                        ScopeExit::Function
                    )
                }
            }
            
        }
        Continue {
            if !in_loop {
                self.messages |> push(Message::stray_loop_controls(node.source))
            }
            return Pair(make_node(ast::Variant::Continue), ScopeExit::Loop)
        }
        Break {
            if !in_loop {
                self.messages |> push(Message::stray_loop_controls(node.source))
            }
            return Pair(make_node(ast::Variant::Break), ScopeExit::Loop)
        }
        If(ast::If(cond, if_body, else_body)) {
            val bool: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, bool)
            self |> enter_scope()
            val if_body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(if_body, in_loop)
            self |> exit_scope()
            self |> enter_scope()
            val else_body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(else_body, in_loop)
            self |> exit_scope()
            val exit = ScopeExit::combine(if_body_t.second, else_body_t.second)
            return Pair(
                make_node(ast::Variant::If(ast::If(
                    cond_t, if_body_t.first, else_body_t.first
                ))), 
                exit
            )
        }
        While(ast::While(cond, body)) {
            val bool: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, bool)
            self |> enter_scope()
            val body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(body, IN_LOOP)
            self |> exit_scope()
            val body_exit_level = ScopeExit::level(body_t.second)
            val exit = if body_exit_level > ScopeExit::level(ScopeExit::Loop)
                { body_t.second } else { ScopeExit::None }
            return Pair(
                make_node(ast::Variant::While(ast::While(
                    cond_t, body_t.first
                ))),
                exit
            )
        }
        For(ast::For(name, in, body)) {
            val in_t: TypedNode = self |> infer(in)
            mut iter_type: Type = in_t.type
            match in_t.type {
                Type(
                    Variant::Struct(Pair(List::of("std", "Sequence"), seq_t_args)), 
                    IS_MUTABLE, _
                ) {
                    iter_type = seq_t_args |> get(0) |> unwrap_or_else(
                        || Type(Variant::Invalid, !IS_MUTABLE, in.source)
                    )
                }
                Type(Variant::Invalid, _, _) {}
                _ {
                    self.messages |> push(
                        Message::not_iterable(in_t.type, node.source)
                    )
                }
            }
            val function: mut Function = self.functions |> at(-1)
            val scope: Scope = Scope(Map::of(
                Pair(name, Variable(
                    node.source, !IS_MUTABLE, !IS_USED, iter_type
                ))
            ))
            function.scopes |> push(scope)
            val body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(body, IN_LOOP)
            self |> exit_scope()
            val body_exit_level = ScopeExit::level(body_t.second)
            val exit = if body_exit_level > ScopeExit::level(ScopeExit::Loop)
                { body_t.second } else { ScopeExit::None }
            return Pair(
                make_node(ast::Variant::For(ast::For(name, in_t, body_t.first))),
                exit
            )
        }
        Match(ast::Match(matched, branches)) {
            val matched_t: TypedNode = self |> infer(matched)
            val branches_t: Pair[mut List[ast::MatchBranch[TypedNode]], ScopeExit]
                = branches 
                |> values()
                |> fold(Pair(List::empty(), ScopeExit::Function), |acc, b| {
                    val patterns_t: List[TypedNode] = b.patterns 
                        |> values()
                        |> map(|p| {
                            val pattern = Pattern(List::empty(), List::empty())
                            return self |> check_match_pattern(
                                p, matched_t.type, pattern, List::empty()
                            )
                        })
                        |> List::collect()
                    val body: Pair[List[TypedNode], ScopeExit]
                        = self |> check_statement_list(b.body, in_loop)
                    val branch: ast::MatchBranch[TypedNode] 
                        = ast::MatchBranch(patterns_t, body.first)
                    acc.first |> push(branch)
                    return Pair(acc.first, acc.second |> combine(body.second))
                })
            // TODO!
            // - ensure that all branch patterns have the same captures
            //   (ignore if '_')
            // - exhaustiveness checking
            // - store the conditions and captures in the output node
            return Pair(
                make_node(ast::Variant::Match(ast::Match(
                    matched_t, branches_t.first
                ))),
                branches_t.second
            )
        }

        _ { 
            return Pair(self |> infer(node), ScopeExit::None) 
        }
    }
}