
mod quill::types

use quill::*
use quill::checker::Checker
use quill::ast::UntypedNode

pub enum Variant(
    Unit,
    Integer,
    Float,
    Boolean,
    String,
    Struct: Pair[List[String], List[Type]],
    Enum: Pair[List[String], List[Type]],
    Function: Pair[List[Type], Type],
    List: Type,

    Invalid
)

pub fun Variant::as_hash(self: Variant) -> Int {
    match self {
        Unit { return 0 }
        Integer { return 1 }
        Float { return 2 }
        Boolean { return 3 }
        String { return 4 }
        Struct(args) { return args |> as_hash() |> hash::combine_ord(5) }
        Enum(args) { return args |> as_hash() |> hash::combine_ord(6) }
        Function(args) { return args |> as_hash() |> hash::combine_ord(7) }
        List(elem_t) { return elem_t |> as_hash() |> hash::combine_ord(8) }

        Invalid { return 9 }
    }
}

pub fun Variant::as_string(self: Variant) -> String {
    match self {
        Unit { return "Unit" }
        Integer { return "Int" }
        Float { return "Float" }
        Boolean { return "Bool" }
        String { return "String" }
        Struct(Pair(path, t_arg_t)) | Enum(Pair(path, t_arg_t)) {
            val path_s: String = path |> values() |> join("::")
            val t_arg_i_s: String = t_arg_t |> values()
                |> map(Type::as_string) |> join(", ")
            val t_arg_s: String = if t_arg_t |> length() |> is(0) { "" }
                else { "[_]" |> fmt(t_arg_i_s) }
            return path_s |> concat(t_arg_s)
        }
        Function(Pair(arg_t, ret_t)) {
            val arg_s: String = arg_t |> values() 
                |> map(Type::as_string) |> join(", ")
            return "Fun(_) -> _" |> fmt(arg_s, ret_t |> as_string())
        }
        List(elem_t) { return "List[_]" |> fmt(elem_t |> as_string()) }

        Invalid { return "<unknown>" }
    }
}

pub struct Type(
    value: Variant,
    mutable: Bool,
    source: Source
)

pub val IS_MUTABLE: Bool = true

pub fun Type::as_hash(self: Type) -> Int 
    = self.value |> as_hash()
    |> hash::combine_ord(self.mutable |> as_hash())

pub fun Type::as_string(self: Type) -> String
    = (if self.mutable { "mut " } else { "" })
    |> concat(self.value |> as_string())

// Computes the least upper bound of the two given types.
// The function returns the most specific type that can safely represent
// 'a' and 'b'.
// For example, if 'a = Cat' and 'b = mut Cat', then the function shall
// return 'Cat', since the cat may not always be mutable.
// However, if 'a = Fun(Cat)' and 'b = Fun(mut Cat)', then the function
// shall return 'Fun(mut Cat)', since the function may or may not mutate
// the given cat.
pub fun Type::join(a: Type, b: Type) -> Option[Type] {
    val join_rlist: Fun(List[Type], List[Type]) -> Option[mut List[Type]] 
        = |args_a, args_b| args_a |> values()
        |> zip(args_b |> values(), Type::join)
        |> fold(Option::Some(List::empty[Type]()), |a, t| a |> and_then(
            |r| t |> map(|n| {
                r |> push(n)
                return r
            })
        ))
    val meet_rlist: Fun(List[Type], List[Type]) -> Option[mut List[Type]] 
        = |args_a, args_b| args_a |> values()
        |> zip(args_b |> values(), Type::meet)
        |> fold(Option::Some(List::empty[Type]()), |a, t| a |> and_then(
            |r| t |> map(|n| {
                r |> push(n)
                return r
            })
        ))
    val mutable: Bool = a.mutable && b.mutable
    match Pair(a.value, b.value) {
        Pair(Variant::Unit, Variant::Unit) |
        Pair(Variant::Integer, Variant::Integer) |
        Pair(Variant::Float, Variant::Float) |
        Pair(Variant::Boolean, Variant::Boolean) |
        Pair(Variant::String, Variant::String) { return Option::Some(a) }
        Pair(
            Variant::Struct(Pair(a_path, a_args)), 
            Variant::Struct(Pair(b_path, b_args))
        ) {
            val len_match: Bool = (a_args |> length()) == (b_args |> length())
            if a_path == b_path && len_match {
                return join_rlist(a_args, b_args)
                    |> map(|args| Type(
                        Variant::Struct(Pair(a_path, args)), mutable, a.source
                    ))
            }
        }
        Pair(
            Variant::Enum(Pair(a_path, a_args)),
            Variant::Enum(Pair(b_path, b_args))
        ) {
            val len_match: Bool = (a_args |> length()) == (b_args |> length())
            if a_path == b_path && len_match {
                return join_rlist(a_args, b_args)
                    |> map(|args| Type(
                        Variant::Enum(Pair(a_path, args)), 
                        !IS_MUTABLE, a.source
                    ))
            }
        }
        Pair(
            Variant::Function(Pair(a_args, a_ret)), 
            Variant::Function(Pair(b_args, b_ret))
        ) {
            if (a_args |> length()) == (b_args |> length()) {
                // covariance - needs to use 'meet' for args instead
                return meet_rlist(a_args, b_args)
                    |> and_then(|args| Type::join(a_ret, b_ret) 
                        |> map(|ret| Type(
                            Variant::Function(Pair(args, ret)), 
                            !IS_MUTABLE, a.source
                        ))
                    )
            }
        }
        Pair(Variant::List(a_elem), Variant::List(b_elem)) {
            return Type::join(a_elem, b_elem)
                |> map(|elem| Type(Variant::List(elem), mutable, a.source))
        }
        Pair(Variant::Invalid, _) { return Option::Some(a) }
        Pair(_, Variant::Invalid) { return Option::Some(b) }
        _ {}
    }
    return Option::None
}

// Computes the greatest lower bound of the two given types.
// The function returns the most specific type that is safe to be used in place
// of 'a' and 'b'.
// For example, if 'a = Cat' and 'b = mut Cat', then the function shall
// return 'mut Cat', since it can be used for both.
// However, if 'a = Fun(Cat)' and 'b = Fun(mut Cat)', then the function
// shall return 'Fun(Cat)', since the function may or may receive a mutable cat.
pub fun Type::meet(a: Type, b: Type) -> Option[Type] {
    val meet_rlist: Fun(List[Type], List[Type]) -> Option[mut List[Type]] 
        = |args_a, args_b| args_a |> values()
        |> zip(args_b |> values(), Type::meet)
        |> fold(Option::Some(List::empty[Type]()), |a, t| a |> and_then(
            |r| t |> map(|n| {
                r |> push(n)
                return r
            })
        ))
    val join_rlist: Fun(List[Type], List[Type]) -> Option[mut List[Type]] 
        = |args_a, args_b| args_a |> values()
        |> zip(args_b |> values(), Type::join)
        |> fold(Option::Some(List::empty[Type]()), |a, t| a |> and_then(
            |r| t |> map(|n| {
                r |> push(n)
                return r
            })
        ))
    val mutable: Bool = a.mutable || b.mutable
    match Pair(a.value, b.value) {
        Pair(Variant::Unit, Variant::Unit) |
        Pair(Variant::Integer, Variant::Integer) |
        Pair(Variant::Float, Variant::Float) |
        Pair(Variant::Boolean, Variant::Boolean) |
        Pair(Variant::String, Variant::String) { return Option::Some(a) }
        Pair(
            Variant::Struct(Pair(a_path, a_args)), 
            Variant::Struct(Pair(b_path, b_args))
        ) {
            val len_match: Bool = (a_args |> length()) == (b_args |> length())
            if a_path == b_path && len_match {
                return meet_rlist(a_args, b_args)
                    |> map(|args| Type(
                        Variant::Struct(Pair(a_path, args)), mutable, a.source
                    ))
            }
        }
        Pair(
            Variant::Enum(Pair(a_path, a_args)),
            Variant::Enum(Pair(b_path, b_args))
        ) {
            val len_match: Bool = (a_args |> length()) == (b_args |> length())
            if a_path == b_path && len_match {
                return meet_rlist(a_args, b_args)
                    |> map(|args| Type(
                        Variant::Enum(Pair(a_path, args)), 
                        !IS_MUTABLE, a.source
                    ))
            }
        }
        Pair(
            Variant::Function(Pair(a_args, a_ret)), 
            Variant::Function(Pair(b_args, b_ret))
        ) {
            if (a_args |> length()) == (b_args |> length()) {
                // covariance - needs to use 'join' for args instead
                return join_rlist(a_args, b_args)
                    |> and_then(|args| Type::meet(a_ret, b_ret) 
                        |> map(|ret| Type(
                            Variant::Function(Pair(args, ret)), 
                            !IS_MUTABLE, a.source
                        ))
                    )
            }
        }
        Pair(Variant::List(a_elem), Variant::List(b_elem)) {
            return Type::meet(a_elem, b_elem)
                |> map(|elem| Type(Variant::List(elem), mutable, a.source))
        }
        Pair(Variant::Invalid, _) { return Option::Some(a) }
        Pair(_, Variant::Invalid) { return Option::Some(b) }
        _ {}
    }
    return Option::None
}

// Returns a boolean representing if the type passed for 'got' can be used
// in place of the type passed for 'exp'.
// For example, if 'exp = mut Cat', and `got = Cat`, then the function will
// return false, since a cat that can be mutated was expected.
// However, if `exp = Fun(mut Cat)`, and `got = Fun(Cat)`, then the function
// returns true, since the function accepts an immutable cat, meaning a mutable
// one is fine too.
pub fun Type::matches(exp: Type, got: Type) -> Bool {
    match Pair(exp.value, got.value) {
        Pair(Variant::Unit, Variant::Unit) |
        Pair(Variant::Integer, Variant::Integer) |
        Pair(Variant::Float, Variant::Float) |
        Pair(Variant::Boolean, Variant::Boolean) |
        Pair(Variant::String, Variant::String) { return true }
        Pair(
            Variant::Struct(Pair(exp_path, exp_args)), 
            Variant::Struct(Pair(got_path, got_args))
        ) | 
        Pair(
            Variant::Enum(Pair(exp_path, exp_args)),
            Variant::Enum(Pair(got_path, got_args))
        ) {
            val len_match = (exp_args |> length()) == (got_args |> length())
            val mut_match = !exp.mutable || got.mutable
            if !len_match || exp_path != got_path || !mut_match { return false }
            return exp_args |> values()
                |> zip(got_args |> values(), Type::matches)
                |> all(|m| m)
        }
        Pair(
            Variant::Function(Pair(exp_args, exp_ret)), 
            Variant::Function(Pair(got_args, got_ret))
        ) {
            val len_match = (exp_args |> length()) == (got_args |> length())
            if !Type::matches(exp_ret, got_ret) || !len_match { return false }
            // covariance! order for function args needs to be flipped
            return got_args |> values()
                |> zip(exp_args |> values(), Type::matches)
                |> all(|m| m)
        }
        Pair(Variant::List(exp_elem), Variant::List(got_elem)) {
            val mut_match = !exp.mutable || got.mutable
            if !mut_match { return false }
            return Type::matches(exp_elem, got_elem)
        }
        Pair(Variant::Invalid, _) |
        Pair(_, Variant::Invalid) { return true }
        _ { return false }

    }
}

pub struct TypedNode(
    value: ast::Variant[TypedNode],
    source: Source,
    type: Type
)

pub fun TypedNode::as_string(self: TypedNode) -> String
    = "_ (=_)" |> fmt(
        ast::Variant::as_string(self.value),
        Type::as_string(self.type)
    )


pub struct ModuleContext(
    module: List[String],
    aliases: Map[String, List[String]]
)

pub struct Symbol(
    node: UntypedNode,
    type_args: List[String],
    context: ModuleContext,
    instances: mut Map[List[Type], Pair[TypedNode, Int]],
    next_id: Int
)

pub struct SymbolInstance(
    path: List[String],
    type_args: List[Type]
)

pub struct SymbolTable(
    symbols: mut Map[List[String], mut Symbol]
)
 
// Collects the paths of all symbols declared by the provided 'nodes'
// into a set.
fun SymbolTable::collect_names(nodes: List[UntypedNode]) -> Set[List[String]] {
    mut module: List[String] = List::empty()
    val paths: mut Set[List[String]] = Set::empty()
    nodes |> values() |> for_each(|node| {
        match node.value {
            Module(path) { module = path }

            GlobalVariable(ast::GlobalVariable(path, _, _, _, _)) |
            Function(ast::Function(path, _, _, _, _, _)) |
            ExternalFunction(ast::ExternalFunction(path, _, _, _, _, _)) |
            Structure(ast::CustomType(path, _, _, _)) |
            Enumeration(ast::CustomType(path, _, _, _)) {
                val abs: List[String] = List::concat(module, path)
                paths |> add(abs)
            }

            _ {}
        }
    })
    return paths
}

// Adds a given alias to a path alias map.
fun SymbolTable::process_alias(
    alias: Pair[String, List[String]],
    aliases: mut Map[String, List[String]],
    names: Set[List[String]]
) {
    if alias.second |> at(-1) |> is_not("*") {
        aliases |> add(alias)
        return unit
    }
    val repl: List[String] = alias.second
    names |> values()
        |> filter(|p| {
            val rpl_l: Int = repl |> length()
            if rpl_l < 2 { return false }
            if p |> length() |> is_not(rpl_l) { return false }
            return (repl |> slice_to(-1)) == (p |> slice_to(-1))
        })
        |> for_each(|p| {
            aliases |> set(p |> at(-1), p)
        })
}

// Builds a map of all symbols declared by the provided 'nodes'.
fun SymbolTable::collect_symbols(
    nodes: List[UntypedNode], 
    names: Set[List[String]],
    messages: mut List[Message]
) -> mut Map[List[String], mut Symbol] {
    mut symbols: mut Map[List[String], mut Symbol] = Map::empty()
    mut aliases: mut Map[String, List[String]] = Map::empty()
    // We are mutating this context object even after symbols are registered,
    // to which they will keep a reference.
    // This means that 'use'-statements will behave as if they were hoisted.
    mut context: ModuleContext = ModuleContext(List::empty(), aliases)
    val std_alias = Pair("*", List::of("std", "*"))
    SymbolTable::process_alias(std_alias, aliases, names)
    nodes |> values() |> for_each(|node| {
        val err_duplicate: Fun(List[String], Symbol) = |abs_path, prev| {
            messages |> push(Message::duplicate_symbol(
                abs_path, prev.node.source, node.source
            ))
        }
        match node.value {
            Module(path) {
                aliases = Map::empty()
                context = ModuleContext(path, aliases)
                SymbolTable::process_alias(
                    Pair("*", List::concat(path, List::of("*"))), 
                    aliases, names
                )
                SymbolTable::process_alias(std_alias, aliases, names)
            }
            Usages(usages) { usages 
                |> values() 
                |> for_each(|a| SymbolTable::process_alias(a, aliases, names))
            }

            GlobalVariable(ast::GlobalVariable(path, _, _, _, _)) {
                val abs_path: List[String] = List::concat(context.module, path)
                val symbol = Symbol(
                    node, List::empty(), context, Map::empty(), 0
                )
                symbols |> set(abs_path, symbol) 
                    |> map[Symbol, Unit](|p| err_duplicate(abs_path, p))
            }
            Function(ast::Function(path, _, t_args, _, _, _)) |
            ExternalFunction(ast::ExternalFunction(path, _, t_args, _, _, _)) |
            Structure(ast::CustomType(path, _, t_args, _)) |
            Enumeration(ast::CustomType(path, _, t_args, _)) {
                val abs_path: List[String] = List::concat(context.module, path)
                val symbol = Symbol(node, t_args, context, Map::empty(), 0)
                symbols |> set(abs_path, symbol) 
                    |> map[Symbol, Unit](|p| err_duplicate(abs_path, p))
            }

            _ {}
        }
    })
    return symbols
}

// Creates a new symbol table and populates it with the declarations provided
// by the given untyped nodes.
pub fun SymbolTable::from(
    nodes: List[UntypedNode], messages: mut List[Message]
) -> mut SymbolTable {
    val names: Set[List[String]] = SymbolTable::collect_names(nodes)
    return SymbolTable(SymbolTable::collect_symbols(nodes, names, messages))
}

// Given a context and a short path, attempts to expand the path to an absolute path.
// If in a module you have written `use foo::bar` and you pass 'bar',
// this function will expand it to 'foo::bar'.
// If there is no way to expand it, the original path will be returned.
pub fun ModuleContext::expand(
    self: SymbolTable, context: ModuleContext, short: List[String]
) -> List[String] {
    return context.aliases 
        |> get(short |> at(-1)) 
        |> map[List[String], List[String]](
            |repl| List::concat(repl, short |> slice_from(1))
        )
        |> unwrap_or(short)
}

// Type checks the given symbol instance and inserts the result into the
// symbol table. Only the symbol specified by the 'path' property of the given
// instance will be written to. In addition, instantiations caused by this
// instance will be pushed onto 'dependencies', and any reports caused by this
// instance will be pushed onto 'messages'.
pub fun SymbolTable::check_symbol(
    self: mut SymbolTable, 
    instance: SymbolInstance, 
    dependencies: mut List[SymbolInstance],
    messages: mut List[Message]
) {
    val symbol: mut Symbol = self.symbols 
        |> get(instance.path) 
        |> expect("Requested instances must be for existing symbols")
    if symbol.instances |> has(instance.type_args) { return unit }
    val named_t_args: mut Map[String, Type] = instance.type_args 
        |> indices()
        |> map[Int, Pair[String, Type]](|i| Pair(
            symbol.type_args |> at(i),
            instance.type_args |> at(i)
        ))
        |> Map::collect()
    val checker = Checker(
        List::empty(), // no function scope
        named_t_args, self, symbol.context, dependencies, messages
    )
    val checked: TypedNode = checker |> check_declaration(symbol.node)
    val id: Int = symbol.next_id
    val variant: Pair[TypedNode, Int] = Pair(checked, id)
    symbol.instances |> set(instance.type_args, variant)
    symbol.next_id = id + 1
}

// Returns a new list of instances representing all symbols present in the
// symbol table that do not take any type arguments and therefore can (and must)
// always be instantiated exactly once.
pub fun SymbolTable::base_instances(
    self: SymbolTable
) -> mut List[SymbolInstance]
    = self.symbols 
    |> entries()
    |> filter(|s| s.second.type_args |> length() |> is(0))
    |> map[Pair[List[String], mut Symbol], SymbolInstance](
        |s| SymbolInstance(s.first, List::empty())
    )
    |> List::collect()