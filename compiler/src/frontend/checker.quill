
mod quill::checker

use quill::*
use quill::types::*
use quill::ast::UntypedNode

pub enum ScopeExit(
    None,
    Loop,
    Function
)

pub fun ScopeExit::level(self: ScopeExit) -> Int {
    match self {
        None { return 0 }
        Loop { return 1 }
        Function { return 2 }
    }
}

pub fun ScopeExit::combine(a: ScopeExit, b: ScopeExit) -> ScopeExit {
    match Int::min(a |> level(), b |> level()) {
        2 { return ScopeExit::Function }
        1 { return ScopeExit::Loop }
        0 { return ScopeExit::None }
        _ { return panic("Unhandled level!") }
    }
}

pub struct Variable(
    source: Source,
    mutable: Bool,
    used: Bool,
    type: Type
)

pub val IS_USED: Bool = true

pub struct Scope(
    locals: mut Map[String, mut Variable]
)

pub struct Function(
    scopes: mut List[Scope],
    return_type: Option[Type]
)

pub struct Checker(
    functions: mut List[mut Function],
    type_args: mut Map[String, Type],
    symbols: SymbolTable,
    context: ModuleContext,
    dependencies: mut List[SymbolInstance],
    messages: mut List[Message]
)

pub fun Checker::enter_scope(self: mut Checker) {
    val function: mut Function = self.functions |> at(-1)
    val scope: Scope = Scope(Map::empty())
    function.scopes |> push(scope)
}

pub fun Checker::scope(self: mut Checker) -> Scope {
    val function: mut Function = self.functions |> at(-1)
    return function.scopes |> at(-1)
}

pub fun Checker::find_variable(
    self: mut Checker, name: String
) -> Option[mut Variable] {
    val scopes: mut Sequence[Scope] 
        = self.functions 
        |> reversed()
        |> map[mut Function, mut Sequence[Scope]](
            |func| func.scopes |> reversed()
        )
        |> flatten()
    return scopes
        |> map[Scope, Option[mut Variable]](
            |scope| scope.locals |> get(name)
        )
        |> find(Option::is_some)
        |> flatten()
}

pub fun Checker::exit_scope(self: mut Checker) {
    val function: mut Function = self.functions |> at(-1)
    val scope: Scope = function.scopes 
        |> pop() 
        |> expect("caller should ensure checker is in scope")
    scope.locals 
        |> entries()
        |> filter(|local| !local.second.used)
        |> for_each(|local| {
            self.messages |> push(
                Message::dead_local(local.first, local.second.source)
            )
        })
}

pub fun Checker::join_types(
    self: mut Checker, a: Type, b: Type, at: Source
) -> Type {
    match Type::join(a, b) {
        Some(t) { return t }
        None {
            self.messages |> push(Message::incompatible_types(a, b, at))
            return Type(Variant::Invalid, !IS_MUTABLE, at)
        }
    }
}

pub fun Checker::check_annotation(self: Checker, node: UntypedNode) -> TypedNode {
    match node.value {
        TypeRef(Pair(mutable, ast::PathRef(short_path, t_args))) {
            val path: List[String] = self.symbols 
                |> expand(self.context, short_path)
            val g_t_args: List[TypedNode] = t_args
                |> map[List[UntypedNode], List[TypedNode]](|a| a
                    |> values()
                    |> map(|n| self |> check_annotation(n))
                    |> List::collect()
                )
                |> unwrap_or(List::empty())
            val o_g_t_args: Option[List[TypedNode]] 
                = if t_args |> is_some() { Option::Some(g_t_args) } 
                else { Option::None[List[TypedNode]] }
            // generic type argument (e.g. 'T')
            if path |> length() |> is(1) {
                match self.type_args |> get(path |> at(0)) {
                    Some(t) {
                        if mutable {
                            self.messages |> push(Message::immutable_generic(
                                node.source, path |> at(0)
                            ))
                        }
                        if t_args |> is_some() {
                            self.messages |> push(Message::args_on_generic(
                                node.source, path |> at(0)
                            ))
                        }
                        return TypedNode(
                            ast::Variant::TypeRef(Pair(
                                !IS_MUTABLE, 
                                ast::PathRef(path, Option::None)
                            )),
                            node.source,
                            t
                        )
                    }
                    _ {}
                }
            }
            // built-in types
            val make_builtin: Fun(Variant) -> TypedNode = |t| {
                if mutable {
                    self.messages |> push(Message::immutable_builtin(
                        path |> at(-1), node.source
                    ))
                }
                if t_args |> is_some() {
                    self.messages |> push(Message::type_args_builtin(
                        path |> at(-1), node.source
                    ))
                }
                return TypedNode(
                    ast::Variant::TypeRef(Pair(
                        !IS_MUTABLE, ast::PathRef(path, Option::None)
                    )),
                    node.source, 
                    Type(t, !IS_MUTABLE, node.source)
                )
            }
            match path {
                List::of("Unit") | List::of("std", "Unit") { 
                    return make_builtin(Variant::Unit) 
                }
                List::of("Int") | List::of("std", "Int") { 
                    return make_builtin(Variant::Integer) 
                }
                List::of("Float") | List::of("std", "Float") { 
                    return make_builtin(Variant::Float) 
                }
                List::of("Bool") | List::of("std", "Bool") { 
                    return make_builtin(Variant::Boolean) 
                }
                List::of("String") | List::of("std", "String") { 
                    return make_builtin(Variant::String) 
                }
                List::of("List") | List::of("std", "List") {
                    if t_args |> is_none() {
                        self.messages |> push(Message::no_type_args_builtin(
                            path |> at(-1), node.source
                        ))
                    }
                    if g_t_args |> length() |> is_not(1) {
                        self.messages |> push(Message::wrong_type_arg_c(
                            List::of("std", "List"), 1, 
                            g_t_args |> length(), node.source
                        ))
                    }
                    return TypedNode(
                        ast::Variant::TypeRef(Pair(
                            mutable, 
                            ast::PathRef(path, Option::Some(g_t_args))
                        )),
                        node.source, 
                        Type(
                            Variant::List((g_t_args |> at(0)).type), 
                            mutable, node.source
                        )
                    )
                }
                _ {}
            }
            // references to custom structs and enums
            match self.symbols.symbols |> get(path) {
                Some(symbol) { match symbol.node.value {
                    Structure(ast::CustomType(_, _, t_args_names, _)) | 
                    Enumeration(ast::CustomType(_, _, t_args_names, _)) {
                        val exp_c: Int = t_args_names |> length()
                        val got_c: Int = g_t_args |> length()
                        if exp_c != got_c {
                            self.messages |> push(Message::wrong_type_arg_c(
                                path, exp_c, got_c, node.source
                            ))
                        }
                        val invalid = Type(
                            Variant::Invalid, !IS_MUTABLE, node.source
                        )
                        val padding: Int = Int::max(exp_c - got_c, 0)
                        val args: List[Type] = g_t_args
                            |> values()
                            |> take(exp_c)
                            |> map[TypedNode, Type](|n| n.type)
                            |> List::collect()
                            |> concat(List::of_length(padding, invalid))
                        val instance: SymbolInstance 
                            = SymbolInstance(path, args)
                        self.dependencies |> push(instance)
                        mut t: Variant = Variant::Invalid
                        match symbol.node.value {
                            Structure(_) { 
                                t = Variant::Struct(Pair(path, args)) 
                            }
                            Enumeration(_) {
                                t = Variant::Enum(Pair(path, args))
                            }
                            _ {}
                        }
                        return TypedNode(
                            ast::Variant::TypeRef(
                                Pair(mutable, ast::PathRef(path, o_g_t_args))
                            ),
                            node.source,
                            Type(t, mutable, node.source)
                        )
                    }
                    _ {}
                } }
                _ {}
            }
            self.messages |> push(Message::unknown_type(path, node.source))
            return TypedNode(
                ast::Variant::TypeRef(
                    Pair(mutable, ast::PathRef(path, o_g_t_args))
                ),
                node.source,
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
        FunctionType(ast::FunctionType(u_arg_t, u_ret_t)) {
            val t_arg_t: List[TypedNode] = u_arg_t
                |> values()
                |> map[UntypedNode, TypedNode](|n| self |> check_annotation(n))
                |> List::collect()
            val arg_t: List[Type] = t_arg_t
                |> values()
                |> map[TypedNode, Type](|n| n.type)
                |> List::collect()
            val t_ret_t: Option[TypedNode] = u_ret_t
                |> map[UntypedNode, TypedNode](|n| self |> check_annotation(n))
            val ret_t: Type = t_ret_t
                |> map[TypedNode, Type](|n| n.type)
                |> unwrap_or_else(
                    || Type(Variant::Unit, !IS_MUTABLE, node.source)
                )
            return TypedNode(
                ast::Variant::FunctionType(ast::FunctionType(t_arg_t, t_ret_t)),
                node.source,
                Type(Variant::Function(
                    Pair(arg_t, ret_t)), !IS_MUTABLE, node.source
                )
            )
        }
        _ {
            return TypedNode(
                ast::Variant::Invalid,
                node.source,
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}

pub fun Checker::check_declaration(
    self: mut Checker, node: UntypedNode
) -> TypedNode {
    val make_node: Fun(ast::Variant[TypedNode]) -> TypedNode
        = |v| TypedNode(
            v, node.source, Type(Variant::Unit, !IS_MUTABLE, node.source)
        )
    match node.value {
        Module(path) { return make_node(ast::Variant::Module(path)) }
        Usages(aliases) { return make_node(ast::Variant::Usages(aliases)) }
        GlobalVariable(ast::GlobalVariable(
            path, public, mutable, type, value
        )) {
            val t_type: TypedNode = self |> check_annotation(type)
            val t_value: TypedNode = self |> check(value, t_type.type)
            return make_node(ast::Variant::GlobalVariable(ast::GlobalVariable(
                path, public, mutable, t_type, t_value
            )))
        }
        ast::Variant::Function(ast::Function(
            path, public, t_args, args, return_type, body
        )) {
            val args_t: List[Pair[String, TypedNode]] = args
                |> values()
                |> map(|a| Pair(a.first, self |> check_annotation(a.second)))
                |> List::collect()
            val return_type_t: Option[TypedNode] = return_type
                |> map(|n| self |> check_annotation(n))
            val scope_vars: mut Map[String, mut Variable] = args_t
                |> values()
                |> map(|a| Pair(
                    a.first, 
                    Variable(node.source, !IS_MUTABLE, !IS_USED, a.second.type)
                ))
                |> Map::collect()
            val scope = Scope(scope_vars)
            val full_ret_t = return_type_t 
                |> map[TypedNode, Type](|n| n.type)
                |> unwrap_or_else(
                    || Type(Variant::Unit, !IS_MUTABLE, node.source)
                ) 
            val func = Function(List::of(scope), Option::Some(full_ret_t))
            self.functions |> push(func)
            val body_t: Pair[List[TypedNode], ScopeExit] 
                = self |> check_statement_list(body, !IN_LOOP)
            self |> exit_scope()
            self.functions |> pop()
            val always_returns = body_t.second == ScopeExit::Function
                || full_ret_t.value == Variant::Unit
            if !always_returns {
                self.messages |> push(
                    Message::missing_return(full_ret_t, node.source)
                )
            }
            return make_node(ast::Variant::Function(ast::Function(
                path, public, t_args, args_t, return_type_t, body_t.first
            )))
        }
        ExternalFunction(ast::ExternalFunction(
            path, public, t_args, args, return_type, body
        )) {
            val args_t: List[Pair[String, TypedNode]] = args
                |> values()
                |> map(|a| Pair(a.first, self |> check_annotation(a.second)))
                |> List::collect()
            val return_type_t: Option[TypedNode] = return_type
                |> map(|n| self |> check_annotation(n))
            return make_node(ast::Variant::ExternalFunction(
                ast::ExternalFunction(
                    path, public, t_args, args_t, return_type_t, body
                )
            ))
        }
        Structure(ast::CustomType(path, public, t_args, members)) {
            val members_t: List[Pair[String, TypedNode]] = members
                |> values()
                |> map(|m| Pair(m.first, self |> check_annotation(m.second)))
                |> List::collect()
            return make_node(ast::Variant::Structure(ast::CustomType(
                path, public, t_args, members_t
            )))
        }
        Enumeration(ast::CustomType(path, public, t_args, members)) {
            val members_t: List[Pair[String, TypedNode]] = members
                |> values()
                |> map(|m| Pair(m.first, self |> check_annotation(m.second)))
                |> List::collect()
            return make_node(ast::Variant::Enumeration(ast::CustomType(
                path, public, t_args, members_t
            )))
        }

        _ { return make_node(ast::Variant::Invalid) }
    }
}

pub val IN_LOOP: Bool = true

pub fun Checker::check_statement_list(
    self: mut Checker, nodes: List[UntypedNode], in_loop: Bool
) -> Pair[List[TypedNode], ScopeExit] {
    val start: Triplet[mut List[TypedNode], ScopeExit, Option[Source]]
        = Triplet(List::empty(), ScopeExit::None, Option::None)
    val checked = nodes
        |> values()
        |> map[UntypedNode, Pair[TypedNode, ScopeExit]](
            |n| self |> check_statement(n, in_loop)
        )
        |> fold(start, |prev, curr| {
            val nodes: mut List[TypedNode] = prev.first
            val prev_exit: ScopeExit = prev.second
            val prev_dead: Option[Source] = prev.third
            val curr_node: TypedNode = curr.first
            val curr_exit: ScopeExit = curr.second
            nodes |> push(curr_node)
            val next_exit: ScopeExit = if prev_exit != ScopeExit::None 
                { prev_exit } else { curr_exit }
            val next_dead: Option[Source] = prev_dead
                |> map[Source, Source](|d| Source::range(d, curr_node.source))
                |> or_else(|| if prev_exit != ScopeExit::None 
                    { Option::Some(curr_node.source) } else { Option::None[Source] }
                )
            return Triplet(nodes, next_exit, next_dead)
        })
    checked.third |> map[Source, Unit](|dead| {
        self.messages |> push(Message::dead_statements(dead))
    })
    return Pair(checked.first, checked.second)
}

pub fun Checker::is_assignable(
    self: mut Checker, node: TypedNode
) -> Bool {
    match node.value {
        PathRef(ast::PathRef(path, Option::None)) {
            match self.symbols.symbols |> get(path) {
                // not found error handled elsewhere
                None { return IS_MUTABLE } 
                Some(symbol) {
                    match symbol.node.value {
                        // public / private check handled elsewhere
                        GlobalVariable(v) { return v.mutable } 
                        _ { return !IS_MUTABLE }
                    }
                }
            }
        }
        VariableRef(name) {
            match self |> find_variable(name) {
                // not found error handled elsewhere
                None { return IS_MUTABLE }
                // public / private check handled elsewhere
                Some(variable) { return variable.mutable }
            }
        }
        Member(Pair(accessed, _)) {
            // public / private check handled elsewhere
            return accessed.type.mutable
        } 

        Invalid { return IS_MUTABLE }
        _ { return !IS_MUTABLE }
    }
}

pub fun Checker::check_statement(
    self: mut Checker, node: UntypedNode, in_loop: Bool
) -> Pair[TypedNode, ScopeExit] {
    val make_node: Fun(ast::Variant[TypedNode]) -> TypedNode
        = |v| TypedNode(
            v, node.source, Type(Variant::Unit, !IS_MUTABLE, node.source)
        )
    match node.value {
        LocalVariable(v) { match v.type {
            Some(ann) {
                val ann_t: TypedNode = self |> check_annotation(ann)
                val value_t: TypedNode = self |> check(v.value, ann_t.type)
                val scope: Scope = self |> scope()
                scope.locals |> set(v.name, Variable(
                    node.source, v.mutable, !IS_USED, ann_t.type
                ))
                return Pair(
                    make_node(ast::Variant::LocalVariable(ast::LocalVariable(
                        v.name, v.mutable, Option::Some(ann_t), value_t
                    ))), 
                    ScopeExit::None
                )
            }
            None {
                val value_t: TypedNode = self |> infer(v.value)
                val scope: Scope = self |> scope()
                scope.locals |> set(v.name, Variable(
                    node.source, v.mutable, !IS_USED, value_t.type
                ))
                return Pair(
                    make_node(ast::Variant::LocalVariable(ast::LocalVariable(
                        v.name, v.mutable, Option::None, value_t
                    ))), 
                    ScopeExit::None
                )
            }
        } }
        Assignment(Pair(dest, value)) {
            val dest_t: TypedNode = self |> infer(dest)
            val assignable: Bool = self |> is_assignable(dest_t)
            if !assignable {
                self.messages |> push(Message::const_assignment(dest.source))
            }
            val value_t: TypedNode = self |> check(value, dest_t.type)
            return Pair(
                make_node(ast::Variant::Assignment(Pair(dest_t, value_t))), 
                ScopeExit::None
            )
        }
        Return(value) {
            val func: mut Function = self.functions |> at(-1)
            match func.return_type {
                Some(pre_ret_t) {
                    val value_t: TypedNode = self |> check(value, pre_ret_t)
                    func.return_type = Option::Some(self |> join_types(
                        pre_ret_t, value_t.type, node.source
                    ))
                    return Pair(
                        make_node(ast::Variant::Return(value_t)),
                        ScopeExit::Function
                    )
                }
                None {
                    val value_t: TypedNode = self |> infer(value)
                    func.return_type = Option::Some(value_t.type)
                    return Pair(
                        make_node(ast::Variant::Return(value_t)),
                        ScopeExit::Function
                    )
                }
            }
            
        }
        Continue {
            if !in_loop {
                self.messages |> push(Message::stray_loop_controls(node.source))
            }
            return Pair(make_node(ast::Variant::Continue), ScopeExit::Loop)
        }
        Break {
            if !in_loop {
                self.messages |> push(Message::stray_loop_controls(node.source))
            }
            return Pair(make_node(ast::Variant::Break), ScopeExit::Loop)
        }
        If(ast::If(cond, if_body, else_body)) {
            val bool: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, bool)
            self |> enter_scope()
            val if_body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(if_body, in_loop)
            self |> exit_scope()
            self |> enter_scope()
            val else_body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(else_body, in_loop)
            self |> exit_scope()
            val exit = ScopeExit::combine(if_body_t.second, else_body_t.second)
            return Pair(
                make_node(ast::Variant::If(ast::If(
                    cond_t, if_body_t.first, else_body_t.first
                ))), 
                exit
            )
        }
        While(ast::While(cond, body)) {
            val bool: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, bool)
            self |> enter_scope()
            val body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(body, IN_LOOP)
            self |> exit_scope()
            val body_exit_level = ScopeExit::level(body_t.second)
            val exit = if body_exit_level > ScopeExit::level(ScopeExit::Loop)
                { body_t.second } else { ScopeExit::None }
            return Pair(
                make_node(ast::Variant::While(ast::While(
                    cond_t, body_t.first
                ))),
                exit
            )
        }
        For(ast::For(name, in, body)) {
            val in_t: TypedNode = self |> infer(in)
            mut iter_type: Type = in_t.type
            match in_t.type {
                Type(
                    Variant::Struct(Pair(List::of("std", "Sequence"), seq_t_args)), 
                    IS_MUTABLE, _
                ) {
                    iter_type = seq_t_args |> get(0) |> unwrap_or_else(
                        || Type(Variant::Invalid, !IS_MUTABLE, in.source)
                    )
                }
                Type(Variant::Invalid, _, _) {}
                _ {
                    self.messages |> push(
                        Message::not_iterable(in_t.type, node.source)
                    )
                }
            }
            val function: mut Function = self.functions |> at(-1)
            val scope: Scope = Scope(Map::of(
                Pair(name, Variable(
                    node.source, !IS_MUTABLE, !IS_USED, iter_type
                ))
            ))
            function.scopes |> push(scope)
            val body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(body, IN_LOOP)
            self |> exit_scope()
            val body_exit_level = ScopeExit::level(body_t.second)
            val exit = if body_exit_level > ScopeExit::level(ScopeExit::Loop)
                { body_t.second } else { ScopeExit::None }
            return Pair(
                make_node(ast::Variant::For(ast::For(name, in_t, body_t.first))),
                exit
            )
        }
        Match(ast::Match(matched, branches)) {
            // - check branches
            // - exhaustiveness checking
            // - build typed node
            // TODO!
            return panic("not yet implemented")
        }

        _ { return Pair(make_node(ast::Variant::Invalid), ScopeExit::None) }
    }
}

fun infer_anno_t_args(
    decl_c: mut Checker,
    anno: UntypedNode,
    given: Type
) -> Bool {
    match given.value {
        Invalid { return false }
        _ {}
    }
    match anno.value {
        TypeRef(Pair(_, ast::PathRef(exp_path, exp_t_args))) {
            val exp_t_arg_c: Int = exp_t_args
                |> map(List::length[UntypedNode])
                |> unwrap_or(0)
            val is_t_arg: Bool = (exp_path |> length() |> is(1))
                && (decl_c.type_args |> has(exp_path |> at(0)))
            if is_t_arg {
                val arg_name: String = exp_path |> at(0)
                return decl_c.type_args 
                    |> get(arg_name)
                    |> expect("branch depends on map to have type")
                    |> Type::join(given)
                    |> map[Type, Unit](|t| {
                        decl_c.type_args |> set(arg_name, t)
                    })
                    |> is_some()
            }
            match given.value {
                Struct(Pair(_, given_t_args)) |
                Enum(Pair(_, given_t_args)) {
                    val got_t_arg_c: Int = given_t_args |> length()
                    if exp_t_arg_c != got_t_arg_c { return false }
                    return given_t_args |> indices() |> fold(true, |acc, i|
                        infer_anno_t_args(
                            decl_c, 
                            exp_t_args |> expect("length > 0") |> at(i), 
                            given_t_args |> at(i)
                        ) && acc
                    )
                }
                List(given_t_arg) {
                    if exp_t_arg_c != 1 { return false }
                    return infer_anno_t_args(
                        decl_c,
                        exp_t_args |> expect("length == 0") |> at(0),
                        given_t_arg
                    )
                }
                _ {}
            }
        }
        FunctionType(ast::FunctionType(exp_args_t, exp_ret_t)) {
            match given.value {
                Variant::Function(Pair(got_args_t, got_ret_t)) {
                    val exp_arg_c: Int = exp_args_t |> length()
                    val got_arg_c: Int = got_args_t |> length()
                    if exp_arg_c != got_arg_c { return false }
                    val args: Bool = got_args_t |> indices() |> fold(true, |acc, i|
                        infer_anno_t_args(
                            decl_c, exp_args_t |> at(i), got_args_t |> at(i)
                        ) && acc
                    )
                    match exp_ret_t {
                        Some(e_ret_t) {
                            return infer_anno_t_args(decl_c, e_ret_t, got_ret_t)
                                && args
                        }
                        None { return args }
                    }
                }
                _ {}
            }
        }
        _ {}
    }
    return true
}

fun infer_call_t_args(
    call_c: mut Checker,
    given_args: List[UntypedNode],
    exp_ret_type: Option[Type],
    call_site: Source,
    
    decl_c: mut Checker,
    exp_arg_types: List[UntypedNode],
    given_ret_type: UntypedNode
) -> List[TypedNode] {
    val old_call_msgs: mut List[Message] = call_c.messages
    val checked_args: mut List[Option[TypedNode]] = given_args 
        |> indices()
        |> map[Int, Option[TypedNode]](|_| Option::None)
        |> List::collect()
    mut had_success: Bool = true
    Stream::new[List[Option[TypedNode]]](|| checked_args)
        |> take_while(|c| c |> values() |> any(|n| n |> is_none()))
        |> take_while(|_| had_success)
        |> for_each(|checked| {
            had_success = false
            call_c.messages |> clear()
            given_args |> indices()
                |> filter(|i| checked_args |> at(i) |> is_some())
                |> for_each(|i| {
                    val arg_val: UntypedNode = given_args |> at(i)
                    val exp_t: TypedNode = decl_c 
                        |> check_annotation(exp_arg_types |> at(i))
                    val given_t: TypedNode = call_c
                        |> check(arg_val, exp_t.type)
                    val success: Bool = infer_anno_t_args(
                        decl_c, exp_arg_types |> at(i), given_t.type
                    )
                    if !success { return unit }
                    checked_args |> set(i, Option::Some(given_t))
                    had_success = true
                })
        })
    call_c.messages = List::concat(old_call_msgs, call_c.messages)
    if !had_success {
        call_c.messages |> push(Message::failed_t_arg_inference(call_site))
    }
    return checked_args
        |> values()
        |> map[Option[TypedNode], TypedNode](|a| a |> unwrap_or_else(
            || TypedNode(
                ast::Variant::Invalid, call_site, 
                Type(Variant::Invalid, !IS_MUTABLE, call_site)
            )            
        ))
        |> List::collect()
}

fun Checker::operands_numeric(
    self: mut Checker, lhs: Type, rhs: Type, at: Source
) -> Type {
    match Pair(lhs.value, rhs.value) {
        Pair(Variant::Integer, Variant::Integer) |
        Pair(Variant::Float, Variant::Float) {
            return lhs
        }
        Pair(Variant::Invalid, _) { return lhs }
        Pair(_, Variant::Invalid) { return rhs }
        _ { 
            self.messages |> push(Message::arithmetic_operands(lhs, rhs, at))
            return Type(Variant::Invalid, !IS_MUTABLE, at)
        }
    }
}

pub fun Checker::check_closure(
    self: mut Checker, node: UntypedNode, c: ast::Closure[UntypedNode],
    arg_types: List[Type]
) -> TypedNode {
    val exp_arg_c: Int = arg_types |> length()
    val got_arg_c: Int = c.args |> length()
    if exp_arg_c != got_arg_c {
        self.messages |> push(Message::unexpected_closure_argc(
            exp_arg_c, got_arg_c, node.source
        ))
    }
    val scope_vars: mut Map[String, mut Variable] = range(0, got_arg_c)
        |> map[Int, Pair[String, mut Variable]](|i| Pair(
            c.args |> at(i),
            Variable(
                node.source, !IS_MUTABLE, !IS_USED, 
                arg_types |> get(i) |> unwrap_or_else(
                    || Type(Variant::Invalid, !IS_MUTABLE, node.source)
                )
            )
        ))
        |> Map::collect()
    val func = Function(
        List::of(Scope(scope_vars)), 
        Option::None
    )
    self.functions |> push(func)
    self |> enter_scope()
    val body_t: Pair[List[TypedNode], ScopeExit] 
        = self |> check_statement_list(c.body, !IN_LOOP)
    self |> exit_scope()
    self.functions |> pop()
    val return_type = func.return_type 
        |> unwrap_or_else(|| Type(Variant::Unit, !IS_MUTABLE, node.source))
    val always_returns = body_t.second == ScopeExit::Function 
        || return_type.value == Variant::Unit
    if !always_returns {
        self.messages |> push(
            Message::missing_return(
                func.return_type |> expect(""), 
                node.source
            )
        )
    }
    return TypedNode(
        ast::Variant::Closure(ast::Closure(List::empty(), body_t.first)),
        node.source,
        Type(
            Variant::Function(Pair(List::empty(), return_type)),
            !IS_MUTABLE, node.source    
        )
    )
}

fun make_full_t_args(types: List[Type], names: List[String], at: Source) -> mut Map[String, Type]
    = range(0, names |> length())
    |> map[Int, Pair[String, Type]](|i| Pair(
        names |> at(i),
        types |> get(i) |> unwrap_or_else(
            || Type(Variant::Invalid, !IS_MUTABLE, at)
        )
    ))
    |> Map::collect()

pub fun Checker::check_member(
    self: mut Checker, node: UntypedNode, 
    accessed: UntypedNode, member_name: String
) -> TypedNode {
    val accessed_t: TypedNode = self |> infer(accessed)
    mut r: Type = Type(Variant::Invalid, !IS_MUTABLE, node.source)
    match accessed_t.type.value {
        Variant::Struct(Pair(path, g_t_args)) {
            r = self.symbols.symbols |> get(path) |> and_then[Symbol, Type](|s| {
                match s.node.value {
                    Structure(ast::CustomType(_, public, t_args, members)) {
                        val hidden: Bool = !public
                            && s.context.module != self.context.module
                        if hidden {
                            self.messages |> push(Message::symbol_private(
                                path, node.source, s.node.source
                            ))
                        }
                        val member_c = Checker(
                            List::empty(),
                            make_full_t_args(g_t_args, t_args, node.source),
                            self.symbols, s.context, 
                            self.dependencies, List::empty()
                        )
                        val mem_t: Option[Type] = members
                            |> values()
                            |> find(|m| m.first == member_name)
                            |> map[Pair[String, UntypedNode], TypedNode](
                                |m| member_c |> check_annotation(m.second)
                            )
                            |> map[TypedNode, Type](|t| t.type)
                        if mem_t |> is_none() {
                            self.messages |> push(Message::missing_member(
                                path, member_name, node.source, s.node.source
                            ))
                        }
                        return mem_t
                    }
                    _ { return Option::None }
                }
            }) |> unwrap_or(r)
        }
        Variant::Invalid {}
        _ {
            self.messages |> push(
                Message::expected_struct(accessed_t.type, node.source)
            )
        }
    }
    return TypedNode(
        ast::Variant::Member(Pair(accessed_t, member_name)),
        node.source, r
    )
}

pub fun Checker::check_path_ref(
    self: mut Checker, node: UntypedNode, 
    raw_path: List[String], t_args: Option[List[UntypedNode]],
    exp: Option[Type]
) -> TypedNode {
    if raw_path |> length() |> is(1) {
        val local_name: String = raw_path |> at(0)
        match self |> find_variable(local_name) {
            Some(local) {
                if t_args |> is_some() {
                    self.messages |> push(Message::unexpected_t_args(
                        local_name, node.source
                    ))
                }
                local.used = true
                return TypedNode(
                    ast::Variant::VariableRef(local_name),
                    node.source,
                    local.type
                )
            }
            None {}
        }
    }
    val path: List[String] = self.symbols |> expand(self.context, raw_path)
    val t_args_t: Option[List[TypedNode]] = t_args
        |> map[List[UntypedNode], List[TypedNode]](|args| args
            |> values()
            |> map[UntypedNode, TypedNode](
                |t| self |> check_annotation(t)
            )
            |> List::collect()
        )
    val type_args: List[Type] = t_args_t
        |> map[List[TypedNode], List[Type]](|args| args
            |> values()
            |> map[TypedNode, Type](|t| t.type)
            |> List::collect()    
        )
        |> unwrap_or(List::empty())
    val check_public: Fun(Bool, Symbol) = |public, symbol| {
        if public || symbol.context.module == self.context.module {
            return unit
        }
        self.messages |> push(Message::symbol_private(
            path, node.source, symbol.node.source
        ))
    }
    val check_tac: Fun(Int) = |exp_tac| {
        val got_tac: Int = type_args |> length()
        if exp_tac != got_tac {
            self.messages |> push(Message::wrong_type_arg_c(
                path, exp_tac, got_tac, node.source
            ))
        }
    }
    match self.symbols.symbols |> get(path) {
        Some(s) { match s.node.value {
            GlobalVariable(ast::GlobalVariable(
                _, public, _, type, _
            )) {
                check_public(public, s)
                if t_args |> is_some() {
                    self.messages |> push(Message::unexpected_t_args(
                        path |> values() |> join("::"), node.source
                    ))
                }
                val var_c = Checker(
                    List::empty(), Map::empty(),
                    self.symbols, s.context, 
                    self.dependencies, List::empty()
                )
                val type_t: TypedNode = var_c |> check_annotation(type)
                val instance: SymbolInstance 
                    = SymbolInstance(path, List::empty())
                self.dependencies |> push(instance)
                return TypedNode(
                    ast::Variant::PathRef(ast::PathRef(path, Option::None)),
                    node.source, type_t.type
                )
            }
            ast::Variant::Function(ast::Function(
                _, public, f_t_args, f_args, f_ret_t, _
            )) | ast::Variant::ExternalFunction(ast::ExternalFunction(
                _, public, f_t_args, f_args, f_ret_t, _
            )) {
                check_public(public, s)
                check_tac(f_t_args |> length())
                val func_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, f_t_args, node.source),
                    self.symbols, s.context,
                    self.dependencies, List::empty() 
                )
                val f_arg_types: List[Type] = f_args
                    |> values()
                    |> map[Pair[String, UntypedNode], Type](
                        |a| (func_c |> check_annotation(a.second)).type
                    )
                    |> List::collect()
                val f_ret_type: Type = f_ret_t
                    |> map[UntypedNode, Type](
                        |r| (func_c |> check_annotation(r)).type
                    )
                    |> unwrap_or_else(
                        || Type(Variant::Unit, !IS_MUTABLE, node.source)
                    )
                val r = Type(
                    Variant::Function(Pair(f_arg_types, f_ret_type)),
                    !IS_MUTABLE, node.source
                )
                return TypedNode(
                    ast::Variant::FunctionRef(ast::PathRef(path, t_args_t)),
                    node.source, r
                )
            }
            _ {}
        } }
        None {}
    }
    val enum_path: List[String] = self.symbols 
        |> expand(self.context, raw_path |> slice_to(-1))
    match self.symbols.symbols |> get(enum_path) {
        Some(s) { match s.node.value {
            Enumeration(ast::CustomType(
                _, public, t_t_args, t_members
            )) {
                check_public(public, s)
                if t_args |> is_some() { check_tac(t_t_args |> length()) }
                val member_name: String = raw_path |> at(-1)
                val o_member: Option[UntypedNode] = t_members
                    |> values()
                    |> find(|m| m.first == member_name)
                    |> map[Pair[String, UntypedNode], UntypedNode](|m| m.second)
                if o_member |> is_none() {
                    self.messages |> push(Message::missing_member(
                        enum_path, member_name, node.source, s.node.source
                    ))
                }
                val member: UntypedNode = o_member |> unwrap_or_else(
                        || UntypedNode(ast::Variant::Invalid, node.source)
                    )
                val result = UntypedNode(
                    ast::Variant::TypeRef(Pair(false, ast::PathRef(
                        enum_path, 
                        Option::Some(t_t_args 
                            |> values()
                            |> map[String, UntypedNode](|t| UntypedNode(
                                ast::Variant::TypeRef(Pair(false, ast::PathRef(
                                    List::of(t), Option::None
                                ))),
                                s.node.source
                            ))
                            |> List::collect()
                        )
                    ))),
                    s.node.source
                )
                val value = UntypedNode(ast::Variant::Unit, node.source)
                val enum_c = Checker(
                    List::empty(),
                    make_full_t_args(type_args, t_t_args, node.source),
                    self.symbols, s.context,
                    self.dependencies, List::empty() 
                )
                val values_t: List[TypedNode] = infer_call_t_args(
                    self, List::of(value), exp, node.source,
                    enum_c, List::of(member), result
                )
                val final_args_t: List[Type] = t_t_args |> values()
                    |> map[String, Type](|t| enum_c.type_args 
                        |> get(t) 
                        |> expect("was inserted earlier")
                    )
                    |> List::collect()
                return TypedNode(
                    ast::Variant::EnumInit(ast::PathInvocation(
                        path, values_t, t_args_t
                    )),
                    node.source,
                    Type(
                        Variant::Enum(Pair(enum_path, final_args_t)), 
                        !IS_MUTABLE, node.source
                    )
                )
            }
            _ {}
        } }
        None {}
    }
    self.messages |> push(Message::unknown_path(path, node.source))
    return TypedNode(
        ast::Variant::Invalid, node.source,
        Type(Variant::Invalid, !IS_MUTABLE, node.source)
    )
}

pub fun Checker::check_invocation(
    self: mut Checker, node: UntypedNode,
    invoked: UntypedNode, args: List[UntypedNode]
) -> TypedNode {
    match invoked.value {
        PathRef(ast::PathRef(raw_path, t_args)) {
            val path: List[String] = self.symbols 
                |> expand(self.context, raw_path)
            match self.symbols.symbols |> get(path) {
                Some(s) { match s.node.value {
                    ast::Variant::Function(ast::Function(
                        _, public, f_t_args, f_args, f_ret_t, _
                    )) | ast::Variant::ExternalFunction(ast::ExternalFunction(
                        _, public, f_t_args, f_args, f_ret_t, _
                    )) {
                        // -> NamedCall (function)
                        // TODO!
                        return panic("not yet implemented")
                    }
                    ast::Variant::Structure(ast::CustomType(
                        _, public, t_t_args, t_members
                    )) {
                        // -> StructInit (structure)
                        // TODO!
                        return panic("not yet implemented")
                    }
                    ast::Variant::Enumeration(ast::CustomType(
                        _, public, t_t_args, t_members
                    )) {
                        // -> EnumInit (enumeration)
                        // TODO!
                        return panic("not yet implemented")
                    }
                    _ {}
                } }
                None {}
            }
        }
        _ {}
    }
    // -> Call (arbitrary)
    // TODO!
    return panic("not yet implemented")
}

pub fun Checker::check(
    self: mut Checker, node: UntypedNode, exp: Type
) -> TypedNode {
    val make_literal: Fun(Variant, ast::Variant[TypedNode]) -> TypedNode = |t, v| {
        if exp.value != t && exp.value != Variant::Invalid {
            self.messages |> push(
                Message::unexpected_type(exp, Type(t, !IS_MUTABLE, node.source))
            )
        }
        return TypedNode(v, node.source, exp)
    }
    val check_numeric: Fun() -> Type = || {
        match exp.value {
            Integer | Float { return exp }
            _ {
                self.messages |> push(
                    Message::unexpected_numeric(exp, node.source)
                )
                return Type(Variant::Invalid, !IS_MUTABLE, node.source)
            }
        }
    }
    val check_arithmetic: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val n: Type = check_numeric()
        val lhs: TypedNode = self |> check(operands.first, n)
        val rhs: TypedNode = self |> check(operands.second, n)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, n)
    }
    val check_ordering: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        if exp.value != r.value && exp.value != Variant::Invalid {
            self.messages |> push(Message::unexpected_type(exp, r))
        }
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    val check_comparison: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        if exp.value != r.value && exp.value != Variant::Invalid {
            self.messages |> push(Message::unexpected_type(exp, r))
        }
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> join_types(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    match node.value {
        PathRef(ast::PathRef(path, t_args)) {
            val checked: TypedNode = self 
                |> check_path_ref(node, path, t_args, Option::Some(exp))
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
                return TypedNode(
                    checked.value, checked.source, 
                    Type(Variant::Invalid, !IS_MUTABLE, checked.source)
                )
            }
            return checked
        }
        Int(value) {
            return make_literal(Variant::Integer, ast::Variant::Int(value))
        }
        Float(value) {
            return make_literal(Variant::Float, ast::Variant::Float(value))
        }
        Bool(value) {
            return make_literal(Variant::Boolean, ast::Variant::Bool(value))
        }
        Unit {
            return make_literal(Variant::Unit, ast::Variant::Unit)
        }
        String(value) {
            return make_literal(Variant::String, ast::Variant::String(value))
        }
        Closure(c) {
            match exp.value {
                Variant::Function(Pair(exp_arg_t, exp_ret_t)) {
                    val checked: TypedNode
                        = self |> check_closure(node, c, exp_arg_t)
                    if !Type::matches(exp, checked.type) {
                        self.messages |> push(
                            Message::unexpected_type(exp, checked.type)
                        )
                        return TypedNode(
                            checked.value, checked.source, 
                            Type(Variant::Invalid, !IS_MUTABLE, checked.source)
                        )
                    }
                    return checked
                }
                _ {
                    self.messages |> push(
                        Message::unexpected_closure(exp, node.source)
                    )
                    return TypedNode(
                        ast::Variant::Invalid, node.source,
                        Type(Variant::Invalid, !IS_MUTABLE, node.source)
                    )
                }
            }
        }
        Add(o) {
            return check_arithmetic(o, |op| ast::Variant::Add(op))
        }
        Subtract(o) {
            return check_arithmetic(o, |op| ast::Variant::Subtract(op))
        }
        Multiply(o) {
            return check_arithmetic(o, |op| ast::Variant::Multiply(op))
        }
        Divide(o) {
            return check_arithmetic(o, |op| ast::Variant::Divide(op))
        }
        Remainder(o) {
            return check_arithmetic(o, |op| ast::Variant::Remainder(op))
        }
        LessThan(o) {
            return check_ordering(o, |op| ast::Variant::LessThan(op))
        }
        LessThanEqual(o) {
            return check_ordering(o, |op| ast::Variant::LessThanEqual(op))
        }
        Equal(o) {
            return check_comparison(o, |op| ast::Variant::Equal(op))
        }
        NotEqual(o) {
            return check_comparison(o, |op| ast::Variant::NotEqual(op))
        }
        Negate(value) {
            val n: Type = check_numeric()
            val v: TypedNode = self |> check(value, n)
            return TypedNode(ast::Variant::Negate(v), node.source, n)
        }
        Not(value) {
            val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            if exp.value != r.value && exp.value != Variant::Invalid {
                self.messages |> push(Message::unexpected_type(exp, r))
            }
            val v: TypedNode = self |> check(value, r)
            return TypedNode(ast::Variant::Not(v), node.source, r)
        }
        Member(Pair(accessed, mem_name)) {
            val checked: TypedNode = self 
                |> check_member(node, accessed, mem_name)
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
            }
            return checked
        }
        Call(ast::Invocation(invoked, args)) {
            val checked: TypedNode = self
                |> check_invocation(node, invoked, args)
            if !Type::matches(exp, checked.type) {
                self.messages |> push(
                    Message::unexpected_type(exp, checked.type)
                )
            }
            return checked
        }
        PipedCall(ast::Invocation(invoked, args)) {
            // 1. do required expansions
            // 2. turn into 'Call'
            // 3. return result of checking result of 2.
            // TODO!
            return panic("not yet implemented")
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c = Type(Variant::Boolean, !IS_MUTABLE, cond.source)
            val cond_t: TypedNode = self |> check(cond, c)
            val if_val_t: TypedNode = self |> check(if_val, exp)
            val else_val_t: TypedNode = self |> check(else_val, exp)
            return TypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond_t, if_val_t, else_val_t)),
                node.source,
                exp
            )
        }

        _ {
            return TypedNode(
                ast::Variant::Invalid, 
                node.source, 
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}

pub fun Checker::infer(
    self: mut Checker, node: UntypedNode
) -> TypedNode {
    val infer_arithmetic: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        val t: Type = self 
            |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, t)
    } 
    val infer_ordering: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    val infer_comparison: Fun(
        Pair[UntypedNode, UntypedNode],
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> join_types(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    match node.value {
        PathRef(ast::PathRef(path, t_args)) {
            return self |> check_path_ref(node, path, t_args, Option::None)
        }
        Int(value) { return TypedNode(
            ast::Variant::Int(value),
            node.source,
            Type(Variant::Integer, !IS_MUTABLE, node.source)
        ) }
        Float(value) { return TypedNode(
            ast::Variant::Float(value),
            node.source,
            Type(Variant::Float, !IS_MUTABLE, node.source)
        ) }
        Bool(value) { return TypedNode(
            ast::Variant::Bool(value),
            node.source,
            Type(Variant::Boolean, !IS_MUTABLE, node.source)
        ) }
        Unit { return TypedNode(
            ast::Variant::Unit,
            node.source,
            Type(Variant::Unit, !IS_MUTABLE, node.source)
        ) }
        String(value) { return TypedNode(
            ast::Variant::String(value),
            node.source,
            Type(Variant::String, !IS_MUTABLE, node.source)
        ) }
        Closure(c) {
            if 0 != (c.args |> length()) {
                self.messages |> push(
                    Message::insufficient_closure_context(node.source)
                )
            }
            return self |> check_closure(node, c, List::empty())
        }
        Add(o) {
            return infer_arithmetic(o, |op| ast::Variant::Add(op))
        }
        Subtract(o) {
            return infer_arithmetic(o, |op| ast::Variant::Subtract(op))
        }
        Multiply(o) {
            return infer_arithmetic(o, |op| ast::Variant::Multiply(op))
        }
        Divide(o) {
            return infer_arithmetic(o, |op| ast::Variant::Divide(op))
        }
        Remainder(o) {
            return infer_arithmetic(o, |op| ast::Variant::Remainder(op))
        }
        LessThan(o) {
            return infer_ordering(o, |op| ast::Variant::LessThan(op))
        }
        LessThanEqual(o) {
            return infer_ordering(o, |op| ast::Variant::LessThanEqual(op))
        }
        Equal(o) {
            return infer_comparison(o, |op| ast::Variant::Equal(op))
        }
        NotEqual(o) {
            return infer_comparison(o, |op| ast::Variant::NotEqual(op))
        }
        Negate(value) {
            val v: TypedNode = self |> infer(value)
            mut r: Type = v.type
            match v.type.value {
                Integer | Float {}
                _ { 
                    self.messages |> push(
                        Message::expected_numeric(v.type, node.source)
                    )
                    r = Type(Variant::Invalid, !IS_MUTABLE, node.source) 
                }
            }
            return TypedNode(ast::Variant::Negate(v), node.source, r)
        }
        Not(value) {
            val r = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val v: TypedNode = self |> check(value, r)
            return TypedNode(ast::Variant::Not(v), node.source, r)
        }
        Member(Pair(accessed, mem_name)) {
            return self |> check_member(node, accessed, mem_name)
        }
        Call(ast::Invocation(invoked, args)) {
            return self |> check_invocation(node, invoked, args)
        }
        PipedCall(ast::Invocation(invoked, args)) {
            // 1. do required expansions
            // 2. turn into 'Call'
            // 3. return result of checking result of 2.
            // TODO!
            return panic("not yet implemented")
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, c)
            val if_val_t: TypedNode = self |> infer(if_val)
            val else_val_t: TypedNode = self |> infer(else_val)
            val r: Type = self 
                |> join_types(if_val_t.type, else_val_t.type, node.source)
            return TypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond_t, if_val_t, else_val_t)), 
                node.source, r
            )
        }

        _ {
            return TypedNode(
                ast::Variant::Invalid, 
                node.source, 
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}