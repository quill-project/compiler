
mod quill::checker

use quill::*
use quill::types::*
use quill::ast::UntypedNode

pub enum ScopeExit(
    None,
    Loop,
    Function
)

pub fun ScopeExit::level(self: ScopeExit) -> Int {
    match self {
        None { return 0 }
        Loop { return 1 }
        Function { return 2 }
    }
}

pub fun ScopeExit::combine(a: ScopeExit, b: ScopeExit) -> ScopeExit {
    match Int::min(a |> level(), b |> level()) {
        2 { return ScopeExit::Function }
        1 { return ScopeExit::Loop }
        0 { return ScopeExit::None }
        _ { return panic("Unhandled level!") }
    }
}

pub struct Variable(
    source: Source,
    mutable: Bool,
    used: Bool,
    type: Type
)

pub val IS_USED: Bool = true

pub struct Scope(
    locals: mut Map[String, mut Variable]
)

pub struct Function(
    scopes: mut List[Scope],
    return_type: Type
)

pub struct Checker(
    functions: mut List[mut Function],
    type_args: mut Map[String, Type],
    symbols: SymbolTable,
    context: ModuleContext,
    dependencies: mut List[SymbolInstance],
    messages: mut List[Message]
)

pub fun Checker::enter_scope(self: mut Checker) {
    val function: mut Function = self.functions |> at(-1)
    val scope: Scope = Scope(Map::empty())
    function.scopes |> push(scope)
}

pub fun Checker::scope(self: mut Checker) -> Scope {
    val function: mut Function = self.functions |> at(-1)
    return function.scopes |> at(-1)
}

pub fun Checker::find_variable(
    self: mut Checker, name: String
) -> Option[mut Variable] {
    val scopes: mut Sequence[Scope] 
        = self.functions 
        |> reversed()
        |> map[mut Function, mut Sequence[Scope]](
            |func| func.scopes |> reversed()
        )
        |> flatten()
    return scopes
        |> map[Scope, Option[mut Variable]](
            |scope| scope.locals |> get(name)
        )
        |> find(Option::is_some)
        |> flatten()
}

pub fun Checker::exit_scope(self: mut Checker) {
    val function: mut Function = self.functions |> at(-1)
    val scope: Scope = function.scopes 
        |> pop() 
        |> expect("caller should ensure checker is in scope")
    scope.locals 
        |> entries()
        |> filter(|local| !local.second.used)
        |> for_each(|local| {
            self.messages |> push(
                Message::dead_local(local.first, local.second.source)
            )
        })
}

pub fun Checker::join_types(
    self: mut Checker, a: Type, b: Type, at: Source
) -> Type {
    match Type::join(a, b) {
        Some(t) { return t }
        None {
            self.messages |> push(Message::incompatible_types(a, b, at))
            return Type(Variant::Invalid, !IS_MUTABLE, at)
        }
    }
}

pub fun Checker::check_annotation(self: Checker, node: UntypedNode) -> TypedNode {
    match node.value {
        TypeRef(Pair(mutable, ast::PathRef(short_path, t_args))) {
            val path: List[String] = self.symbols 
                |> expand(self.context, short_path)
            val g_t_args: List[TypedNode] = t_args
                |> map[List[UntypedNode], List[TypedNode]](|a| a
                    |> values()
                    |> map(|n| self |> check_annotation(n))
                    |> List::collect()
                )
                |> unwrap_or(List::empty())
            val o_g_t_args: Option[List[TypedNode]] 
                = if t_args |> is_some() { Option::Some(g_t_args) } 
                else { Option::None[List[TypedNode]] }
            // generic type argument (e.g. 'T')
            if path |> length() |> is(1) {
                match self.type_args |> get(path |> at(0)) {
                    Some(t) {
                        if mutable {
                            self.messages |> push(Message::immutable_generic(
                                node.source, path |> at(0)
                            ))
                        }
                        if t_args |> is_some() {
                            self.messages |> push(Message::args_on_generic(
                                node.source, path |> at(0)
                            ))
                        }
                        return TypedNode(
                            ast::Variant::TypeRef(Pair(
                                !IS_MUTABLE, 
                                ast::PathRef(path, Option::None)
                            )),
                            node.source,
                            t
                        )
                    }
                    _ {}
                }
            }
            // built-in types
            val make_builtin: Fun(Variant) -> TypedNode = |t| {
                if mutable {
                    self.messages |> push(Message::immutable_builtin(
                        path |> at(-1), node.source
                    ))
                }
                if t_args |> is_some() {
                    self.messages |> push(Message::type_args_builtin(
                        path |> at(-1), node.source
                    ))
                }
                return TypedNode(
                    ast::Variant::TypeRef(Pair(
                        !IS_MUTABLE, ast::PathRef(path, Option::None)
                    )),
                    node.source, 
                    Type(t, !IS_MUTABLE, node.source)
                )
            }
            match path {
                List::of("Unit") | List::of("std", "Unit") { 
                    return make_builtin(Variant::Unit) 
                }
                List::of("Int") | List::of("std", "Int") { 
                    return make_builtin(Variant::Integer) 
                }
                List::of("Float") | List::of("std", "Float") { 
                    return make_builtin(Variant::Float) 
                }
                List::of("Bool") | List::of("std", "Bool") { 
                    return make_builtin(Variant::Boolean) 
                }
                List::of("String") | List::of("std", "String") { 
                    return make_builtin(Variant::String) 
                }
                List::of("List") | List::of("std", "List") {
                    if t_args |> is_none() {
                        self.messages |> push(Message::no_type_args_builtin(
                            path |> at(-1), node.source
                        ))
                    }
                    if g_t_args |> length() |> is_not(1) {
                        self.messages |> push(Message::wrong_type_arg_c(
                            List::of("std", "List"), 1, 
                            g_t_args |> length(), node.source
                        ))
                    }
                    return TypedNode(
                        ast::Variant::TypeRef(Pair(
                            mutable, 
                            ast::PathRef(path, Option::Some(g_t_args))
                        )),
                        node.source, 
                        Type(
                            Variant::List((g_t_args |> at(0)).type), 
                            mutable, node.source
                        )
                    )
                }
                _ {}
            }
            // references to custom structs and enums
            match self.symbols.symbols |> get(path) {
                Some(symbol) { match symbol.node.value {
                    Structure(ast::CustomType(_, _, t_args_names, _)) | 
                    Enumeration(ast::CustomType(_, _, t_args_names, _)) {
                        val exp_c: Int = t_args_names |> length()
                        val got_c: Int = g_t_args |> length()
                        if exp_c != got_c {
                            self.messages |> push(Message::wrong_type_arg_c(
                                path, exp_c, got_c, node.source
                            ))
                        }
                        val invalid = Type(
                            Variant::Invalid, !IS_MUTABLE, node.source
                        )
                        val padding: Int = Int::max(exp_c - got_c, 0)
                        val args: List[Type] = g_t_args
                            |> values()
                            |> take(exp_c)
                            |> map[TypedNode, Type](|n| n.type)
                            |> List::collect()
                            |> concat(List::of_length(padding, invalid))
                        val instance: SymbolInstance 
                            = SymbolInstance(path, args)
                        self.dependencies |> push(instance)
                        mut t: Variant = Variant::Unknown
                        match symbol.node.value {
                            Structure(_) { 
                                t = Variant::Struct(Pair(path, args)) 
                            }
                            Enumeration(_) {
                                t = Variant::Enum(Pair(path, args))
                            }
                            _ {}
                        }
                        return TypedNode(
                            ast::Variant::TypeRef(
                                Pair(mutable, ast::PathRef(path, o_g_t_args))
                            ),
                            node.source,
                            Type(t, mutable, node.source)
                        )
                    }
                    _ {}
                } }
                _ {}
            }
            self.messages |> push(Message::unknown_type(path, node.source))
            return TypedNode(
                ast::Variant::TypeRef(
                    Pair(mutable, ast::PathRef(path, o_g_t_args))
                ),
                node.source,
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
        FunctionType(ast::FunctionType(u_arg_t, u_ret_t)) {
            val t_arg_t: List[TypedNode] = u_arg_t
                |> values()
                |> map[UntypedNode, TypedNode](|n| self |> check_annotation(n))
                |> List::collect()
            val arg_t: List[Type] = t_arg_t
                |> values()
                |> map[TypedNode, Type](|n| n.type)
                |> List::collect()
            val t_ret_t: Option[TypedNode] = u_ret_t
                |> map[UntypedNode, TypedNode](|n| self |> check_annotation(n))
            val ret_t: Type = t_ret_t
                |> map[TypedNode, Type](|n| n.type)
                |> unwrap_or_else(
                    || Type(Variant::Unit, !IS_MUTABLE, node.source)
                )
            return TypedNode(
                ast::Variant::FunctionType(ast::FunctionType(t_arg_t, t_ret_t)),
                node.source,
                Type(Variant::Function(
                    Pair(arg_t, ret_t)), !IS_MUTABLE, node.source
                )
            )
        }
        _ {
            return TypedNode(
                ast::Variant::Invalid,
                node.source,
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}

pub fun Checker::check_declaration(
    self: mut Checker, node: UntypedNode
) -> TypedNode {
    val make_node: Fun(ast::Variant[TypedNode]) -> TypedNode
        = |v| TypedNode(
            v, node.source, Type(Variant::Unit, !IS_MUTABLE, node.source)
        )
    match node.value {
        Module(path) { return make_node(ast::Variant::Module(path)) }
        Usages(aliases) { return make_node(ast::Variant::Usages(aliases)) }
        GlobalVariable(ast::GlobalVariable(
            path, public, mutable, type, value
        )) {
            val t_type: TypedNode = self |> check_annotation(type)
            val t_value: TypedNode = self |> check(value, t_type.type)
            return make_node(ast::Variant::GlobalVariable(ast::GlobalVariable(
                path, public, mutable, t_type, t_value
            )))
        }
        ast::Variant::Function(ast::Function(
            path, public, t_args, args, return_type, body
        )) {
            val args_t: List[Pair[String, TypedNode]] = args
                |> values()
                |> map(|a| Pair(a.first, self |> check_annotation(a.second)))
                |> List::collect()
            val return_type_t: Option[TypedNode] = return_type
                |> map(|n| self |> check_annotation(n))
            val scope_vars: mut Map[String, mut Variable] = args_t
                |> values()
                |> map(|a| Pair(
                    a.first, 
                    Variable(node.source, !IS_MUTABLE, !IS_USED, a.second.type)
                ))
                |> Map::collect()
            val scope = Scope(scope_vars)
            val full_ret_t = return_type_t 
                |> map[TypedNode, Type](|n| n.type)
                |> unwrap_or_else(
                    || Type(Variant::Unit, !IS_MUTABLE, node.source)
                ) 
            val func = Function(List::of(scope), full_ret_t)
            self.functions |> push(func)
            val body_t: Pair[List[TypedNode], ScopeExit] 
                = self |> check_statement_list(body, !IN_LOOP)
            self |> exit_scope()
            self.functions |> pop()
            val always_returns = body_t.second == ScopeExit::Function
                || full_ret_t.value == Variant::Unit
            if !always_returns {
                self.messages |> push(
                    Message::missing_return(full_ret_t, node.source)
                )
            }
            return make_node(ast::Variant::Function(ast::Function(
                path, public, t_args, args_t, return_type_t, body_t.first
            )))
        }
        ExternalFunction(ast::ExternalFunction(
            path, public, t_args, args, return_type, body
        )) {
            val args_t: List[Pair[String, TypedNode]] = args
                |> values()
                |> map(|a| Pair(a.first, self |> check_annotation(a.second)))
                |> List::collect()
            val return_type_t: Option[TypedNode] = return_type
                |> map(|n| self |> check_annotation(n))
            return make_node(ast::Variant::ExternalFunction(
                ast::ExternalFunction(
                    path, public, t_args, args_t, return_type_t, body
                )
            ))
        }
        Structure(ast::CustomType(path, public, t_args, members)) {
            val members_t: List[Pair[String, TypedNode]] = members
                |> values()
                |> map(|m| Pair(m.first, self |> check_annotation(m.second)))
                |> List::collect()
            return make_node(ast::Variant::Structure(ast::CustomType(
                path, public, t_args, members_t
            )))
        }
        Enumeration(ast::CustomType(path, public, t_args, members)) {
            val members_t: List[Pair[String, TypedNode]] = members
                |> values()
                |> map(|m| Pair(m.first, self |> check_annotation(m.second)))
                |> List::collect()
            return make_node(ast::Variant::Enumeration(ast::CustomType(
                path, public, t_args, members_t
            )))
        }

        _ { return make_node(ast::Variant::Invalid) }
    }
}

pub val IN_LOOP: Bool = true

pub fun Checker::check_statement_list(
    self: mut Checker, nodes: List[UntypedNode], in_loop: Bool
) -> Pair[List[TypedNode], ScopeExit] {
    val start: Triplet[mut List[TypedNode], ScopeExit, Option[Source]]
        = Triplet(List::empty(), ScopeExit::None, Option::None)
    val checked = nodes
        |> values()
        |> map[UntypedNode, Pair[TypedNode, ScopeExit]](
            |n| self |> check_statement(n, in_loop)
        )
        |> fold(start, |prev, curr| {
            val nodes: mut List[TypedNode] = prev.first
            val prev_exit: ScopeExit = prev.second
            val prev_dead: Option[Source] = prev.third
            val curr_node: TypedNode = curr.first
            val curr_exit: ScopeExit = curr.second
            nodes |> push(curr_node)
            val next_exit: ScopeExit = if prev_exit != ScopeExit::None 
                { prev_exit } else { curr_exit }
            val next_dead: Option[Source] = prev_dead
                |> map[Source, Source](|d| Source::range(d, curr_node.source))
                |> or_else(|| if prev_exit != ScopeExit::None 
                    { Option::Some(curr_node.source) } else { Option::None[Source] }
                )
            return Triplet(nodes, next_exit, next_dead)
        })
    checked.third |> map[Source, Unit](|dead| {
        self.messages |> push(Message::dead_statements(dead))
    })
    return Pair(checked.first, checked.second)
}

pub fun Checker::is_assignable(
    self: mut Checker, node: TypedNode
) -> Bool {
    match node.value {
        PathRef(ast::PathRef(path, Option::None)) {
            match self.symbols.symbols |> get(path) {
                // not found error handled elsewhere
                None { return IS_MUTABLE } 
                Some(symbol) {
                    match symbol.node.value {
                        // public / private check handled elsewhere
                        GlobalVariable(v) { return v.mutable } 
                        _ { return !IS_MUTABLE }
                    }
                }
            }
        }
        VariableRef(name) {
            match self |> find_variable(name) {
                // not found error handled elsewhere
                None { return IS_MUTABLE }
                // public / private check handled elsewhere
                Some(variable) { return variable.mutable }
            }
        }
        // public / private check handled elsewhere
        Member(_) { return IS_MUTABLE } 

        Invalid { return IS_MUTABLE }
        _ { return !IS_MUTABLE }
    }
}

pub fun Checker::check_statement(
    self: mut Checker, node: UntypedNode, in_loop: Bool
) -> Pair[TypedNode, ScopeExit] {
    val make_node: Fun(ast::Variant[TypedNode]) -> TypedNode
        = |v| TypedNode(
            v, node.source, Type(Variant::Unit, !IS_MUTABLE, node.source)
        )
    match node.value {
        LocalVariable(v) { match v.type {
            Some(ann) {
                val ann_t: TypedNode = self |> check_annotation(ann)
                val value_t: TypedNode = self |> check(v.value, ann_t.type)
                val scope: Scope = self |> scope()
                scope.locals |> set(v.name, Variable(
                    node.source, v.mutable, !IS_USED, ann_t.type
                ))
                return Pair(
                    make_node(ast::Variant::LocalVariable(ast::LocalVariable(
                        v.name, v.mutable, Option::Some(ann_t), value_t
                    ))), 
                    ScopeExit::None
                )
            }
            None {
                val value_t: TypedNode = self |> infer(v.value)
                val scope: Scope = self |> scope()
                scope.locals |> set(v.name, Variable(
                    node.source, v.mutable, !IS_USED, value_t.type
                ))
                return Pair(
                    make_node(ast::Variant::LocalVariable(ast::LocalVariable(
                        v.name, v.mutable, Option::None, value_t
                    ))), 
                    ScopeExit::None
                )
            }
        } }
        Assignment(Pair(dest, value)) {
            val dest_t: TypedNode = self |> infer(dest)
            val assignable: Bool = self |> is_assignable(dest_t)
            if !assignable {
                self.messages |> push(Message::const_assignment(dest.source))
            }
            val value_t: TypedNode = self |> check(value, dest_t.type)
            return Pair(
                make_node(ast::Variant::Assignment(Pair(dest_t, value_t))), 
                ScopeExit::None
            )
        }
        Return(value) {
            val func: mut Function = self.functions |> at(-1)
            val value_t: TypedNode = self |> infer(value)
            func.return_type = self 
                |> join_types(func.return_type, value_t.type, node.source)
            return Pair(
                make_node(ast::Variant::Return(value_t)),
                ScopeExit::Function
            )
        }
        Continue {
            if !in_loop {
                self.messages |> push(Message::stray_loop_controls(node.source))
            }
            return Pair(make_node(ast::Variant::Continue), ScopeExit::Loop)
        }
        Break {
            if !in_loop {
                self.messages |> push(Message::stray_loop_controls(node.source))
            }
            return Pair(make_node(ast::Variant::Break), ScopeExit::Loop)
        }
        If(ast::If(cond, if_body, else_body)) {
            val bool: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, bool)
            self |> enter_scope()
            val if_body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(if_body, in_loop)
            self |> exit_scope()
            self |> enter_scope()
            val else_body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(else_body, in_loop)
            self |> exit_scope()
            val exit = ScopeExit::combine(if_body_t.second, else_body_t.second)
            return Pair(
                make_node(ast::Variant::If(ast::If(
                    cond_t, if_body_t.first, else_body_t.first
                ))), 
                exit
            )
        }
        While(ast::While(cond, body)) {
            val bool: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, bool)
            self |> enter_scope()
            val body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(body, IN_LOOP)
            self |> exit_scope()
            val body_exit_level = ScopeExit::level(body_t.second)
            val exit = if body_exit_level > ScopeExit::level(ScopeExit::Loop)
                { body_t.second } else { ScopeExit::None }
            return Pair(
                make_node(ast::Variant::While(ast::While(
                    cond_t, body_t.first
                ))),
                exit
            )
        }
        For(ast::For(name, in, body)) {
            val in_t: TypedNode = self |> infer(in)
            mut iter_type: Type = in_t.type
            match in_t.type {
                Type(
                    Variant::Struct(Pair(List::of("std", "Sequence"), seq_t_args)), 
                    IS_MUTABLE, _
                ) {
                    iter_type = seq_t_args |> get(0) |> unwrap_or_else(
                        || Type(Variant::Invalid, !IS_MUTABLE, in.source)
                    )
                }
                Type(Variant::Invalid, _, _) {}
                _ {
                    self.messages |> push(
                        Message::not_iterable(in_t.type, node.source)
                    )
                }
            }
            val function: mut Function = self.functions |> at(-1)
            val scope: Scope = Scope(Map::of(
                Pair(name, Variable(
                    node.source, !IS_MUTABLE, !IS_USED, iter_type
                ))
            ))
            function.scopes |> push(scope)
            val body_t: Pair[List[TypedNode], ScopeExit]
                = self |> check_statement_list(body, IN_LOOP)
            self |> exit_scope()
            val body_exit_level = ScopeExit::level(body_t.second)
            val exit = if body_exit_level > ScopeExit::level(ScopeExit::Loop)
                { body_t.second } else { ScopeExit::None }
            return Pair(
                make_node(ast::Variant::For(ast::For(name, in_t, body_t.first))),
                exit
            )
        }
        Match(ast::Match(matched, branches)) {
            // - check branches
            // - exhaustiveness checking
            // - build typed node
            // TODO!
            return panic("not yet implemented")
        }

        _ { return Pair(make_node(ast::Variant::Invalid), ScopeExit::None) }
    }
}

fun Checker::operands_numeric(
    self: mut Checker, lhs: Type, rhs: Type, at: Source
) -> Type {
    match Pair(lhs.value, rhs.value) {
        Pair(Variant::Integer, Variant::Integer) |
        Pair(Variant::Float, Variant::Float) {
            return lhs
        }
        Pair(Variant::Invalid, _) { return lhs }
        Pair(_, Variant::Invalid) { return rhs }
        _ { 
            self.messages |> push(Message::arithmetic_operands(lhs, rhs, at))
            return Type(Variant::Invalid, !IS_MUTABLE, at)
        }
    }
}

pub fun Checker::check_closure(
    self: mut Checker, node: UntypedNode, c: ast::Closure[UntypedNode],
    arg_types: List[Type]
) -> TypedNode {
    val exp_arg_c: Int = arg_types |> length()
    val got_arg_c: Int = c.args |> length()
    if exp_arg_c != got_arg_c {
        self.messages |> push(Message::unexpected_closure_argc(
            exp_arg_c, got_arg_c, node.source
        ))
    }
    val scope_vars: mut Map[String, mut Variable] = range(0, got_arg_c)
        |> map[Int, Pair[String, mut Variable]](|i| Pair(
            c.args |> at(i),
            Variable(
                node.source, !IS_MUTABLE, !IS_USED, 
                arg_types |> get(i) |> unwrap_or_else(
                    || Type(Variant::Invalid, !IS_MUTABLE, node.source)
                )
            )
        ))
        |> Map::collect()
    val func = Function(
        List::of(Scope(scope_vars)), 
        Type(Variant::Unknown, !IS_MUTABLE, node.source)
    )
    self.functions |> push(func)
    self |> enter_scope()
    val body_t: Pair[List[TypedNode], ScopeExit] 
        = self |> check_statement_list(c.body, !IN_LOOP)
    self |> exit_scope()
    self.functions |> pop()
    val always_returns = body_t.second == ScopeExit::Function
        || func.return_type.value == Variant::Unit
    if !always_returns {
        self.messages |> push(
            Message::missing_return(func.return_type, node.source)
        )
    }
    return TypedNode(
        ast::Variant::Closure(ast::Closure(List::empty(), body_t.first)),
        node.source,
        Type(
            Variant::Function(Pair(List::empty(), func.return_type)),
            !IS_MUTABLE, node.source    
        )
    )
}

pub fun Checker::check(
    self: mut Checker, node: UntypedNode, exp: Type
) -> TypedNode {
    val make_literal: Fun(Variant, ast::Variant[TypedNode]) -> TypedNode = |t, v| {
        if exp.value != t && exp.value != Variant::Invalid {
            self.messages |> push(
                Message::unexpected_type(exp, Type(t, !IS_MUTABLE, node.source))
            )
        }
        return TypedNode(v, node.source, exp)
    }
    val check_numeric: Fun() -> Type = || {
        match exp.value {
            Integer | Float { return exp }
            _ {
                self.messages |> push(
                    Message::unexpected_numeric(exp, node.source)
                )
                return Type(Variant::Invalid, !IS_MUTABLE, node.source)
            }
        }
    }
    val check_arithmetic: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val n: Type = check_numeric()
        val lhs: TypedNode = self |> check(operands.first, n)
        val rhs: TypedNode = self |> check(operands.second, n)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, n)
    }
    val check_ordering: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        if exp.value != r.value && exp.value != Variant::Invalid {
            self.messages |> push(Message::unexpected_type(exp, r))
        }
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    val check_comparison: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        if exp.value != r.value && exp.value != Variant::Invalid {
            self.messages |> push(Message::unexpected_type(exp, r))
        }
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> join_types(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    match node.value {
        PathRef(ast::PathRef(path, t_args)) {
            // -> PathRef (global variable)
            // -> VariableRef (local variable) (MARK AS USED!)
            // -> FunctionRef (function)
            // TODO!
            return panic("not yet implemented")
        }
        Int(value) {
            return make_literal(Variant::Integer, ast::Variant::Int(value))
        }
        Float(value) {
            return make_literal(Variant::Float, ast::Variant::Float(value))
        }
        Bool(value) {
            return make_literal(Variant::Boolean, ast::Variant::Bool(value))
        }
        Unit {
            return make_literal(Variant::Unit, ast::Variant::Unit)
        }
        String(value) {
            return make_literal(Variant::String, ast::Variant::String(value))
        }
        Closure(c) {
            match exp.value {
                Variant::Function(Pair(exp_arg_t, exp_ret_t)) {
                    val checked: TypedNode
                        = self |> check_closure(node, c, exp_arg_t)
                    if !Type::matches(exp, checked.type) {
                        self.messages |> push(
                            Message::unexpected_type(exp, checked.type)
                        )
                    }
                    return checked
                }
                _ {
                    self.messages |> push(
                        Message::unexpected_closure(exp, node.source)
                    )
                    return TypedNode(
                        ast::Variant::Invalid, node.source,
                        Type(Variant::Invalid, !IS_MUTABLE, node.source)
                    )
                }
            }
        }
        Add(o) {
            return check_arithmetic(o, |op| ast::Variant::Add(op))
        }
        Subtract(o) {
            return check_arithmetic(o, |op| ast::Variant::Subtract(op))
        }
        Multiply(o) {
            return check_arithmetic(o, |op| ast::Variant::Multiply(op))
        }
        Divide(o) {
            return check_arithmetic(o, |op| ast::Variant::Divide(op))
        }
        Remainder(o) {
            return check_arithmetic(o, |op| ast::Variant::Remainder(op))
        }
        LessThan(o) {
            return check_ordering(o, |op| ast::Variant::LessThan(op))
        }
        LessThanEqual(o) {
            return check_ordering(o, |op| ast::Variant::LessThanEqual(op))
        }
        Equal(o) {
            return check_comparison(o, |op| ast::Variant::Equal(op))
        }
        NotEqual(o) {
            return check_comparison(o, |op| ast::Variant::NotEqual(op))
        }
        Negate(value) {
            val n: Type = check_numeric()
            val v: TypedNode = self |> check(value, n)
            return TypedNode(ast::Variant::Negate(v), node.source, n)
        }
        Not(value) {
            val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            if exp.value != r.value && exp.value != Variant::Invalid {
                self.messages |> push(Message::unexpected_type(exp, r))
            }
            val v: TypedNode = self |> check(value, r)
            return TypedNode(ast::Variant::Not(v), node.source, r)
        }
        Member(Pair(accessed, mem_name)) {
            // TODO!
            return panic("not yet implemented")
        }
        Call(ast::Invocation(invoked, args)) {
            // -> Call (arbitrary)
            // -> NamedCall (function)
            // -> StructInit (structure)
            // -> EnumInit (enumeration)
            // TODO!
            return panic("not yet implemented")
        }
        PipedCall(ast::Invocation(invoked, args)) {
            // 1. do required expansions
            // 2. turn into 'Call'
            // 3. return result of checking result of 2.
            // TODO!
            return panic("not yet implemented")
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c = Type(Variant::Boolean, !IS_MUTABLE, cond.source)
            val cond_t: TypedNode = self |> check(cond, c)
            val if_val_t: TypedNode = self |> check(if_val, exp)
            val else_val_t: TypedNode = self |> check(else_val, exp)
            return TypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond_t, if_val_t, else_val_t)),
                node.source,
                exp
            )
        }

        _ {
            return TypedNode(
                ast::Variant::Invalid, 
                node.source, 
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}

pub fun Checker::infer(
    self: mut Checker, node: UntypedNode
) -> TypedNode {
    val infer_arithmetic: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        val t: Type = self 
            |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, t)
    } 
    val infer_ordering: Fun(
        Pair[UntypedNode, UntypedNode], 
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> operands_numeric(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    val infer_comparison: Fun(
        Pair[UntypedNode, UntypedNode],
        Fun(Pair[TypedNode, TypedNode]) -> ast::Variant[TypedNode]
    ) -> TypedNode = |operands, constr| {
        val r: Type = Type(Variant::Boolean, !IS_MUTABLE, node.source)
        val lhs: TypedNode = self |> infer(operands.first)
        val rhs: TypedNode = self |> infer(operands.second)
        self |> join_types(lhs.type, rhs.type, node.source)
        return TypedNode(constr(Pair(lhs, rhs)), node.source, r)
    }
    match node.value {
        PathRef(ast::PathRef(path, t_args)) {
            // -> PathRef (global variable)
            // -> VariableRef (local variable) (MARK AS USED!)
            // -> FunctionRef (function)
            // TODO!
            return panic("not yet implemented")
        }
        Int(value) { return TypedNode(
            ast::Variant::Int(value),
            node.source,
            Type(Variant::Integer, !IS_MUTABLE, node.source)
        ) }
        Float(value) { return TypedNode(
            ast::Variant::Float(value),
            node.source,
            Type(Variant::Float, !IS_MUTABLE, node.source)
        ) }
        Bool(value) { return TypedNode(
            ast::Variant::Bool(value),
            node.source,
            Type(Variant::Boolean, !IS_MUTABLE, node.source)
        ) }
        Unit { return TypedNode(
            ast::Variant::Unit,
            node.source,
            Type(Variant::Unit, !IS_MUTABLE, node.source)
        ) }
        String(value) { return TypedNode(
            ast::Variant::String(value),
            node.source,
            Type(Variant::String, !IS_MUTABLE, node.source)
        ) }
        Closure(c) {
            if 0 != (c.args |> length()) {
                self.messages |> push(
                    Message::insufficient_closure_context(node.source)
                )
            }
            return self |> check_closure(node, c, List::empty())
        }
        Add(o) {
            return infer_arithmetic(o, |op| ast::Variant::Add(op))
        }
        Subtract(o) {
            return infer_arithmetic(o, |op| ast::Variant::Subtract(op))
        }
        Multiply(o) {
            return infer_arithmetic(o, |op| ast::Variant::Multiply(op))
        }
        Divide(o) {
            return infer_arithmetic(o, |op| ast::Variant::Divide(op))
        }
        Remainder(o) {
            return infer_arithmetic(o, |op| ast::Variant::Remainder(op))
        }
        LessThan(o) {
            return infer_ordering(o, |op| ast::Variant::LessThan(op))
        }
        LessThanEqual(o) {
            return infer_ordering(o, |op| ast::Variant::LessThanEqual(op))
        }
        Equal(o) {
            return infer_comparison(o, |op| ast::Variant::Equal(op))
        }
        NotEqual(o) {
            return infer_comparison(o, |op| ast::Variant::NotEqual(op))
        }
        Negate(value) {
            val v: TypedNode = self |> infer(value)
            mut r: Type = v.type
            match v.type.value {
                Integer | Float {}
                _ { 
                    self.messages |> push(
                        Message::expected_numeric(v.type, node.source)
                    )
                    r = Type(Variant::Invalid, !IS_MUTABLE, node.source) 
                }
            }
            return TypedNode(ast::Variant::Negate(v), node.source, r)
        }
        Not(value) {
            val r = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val v: TypedNode = self |> check(value, r)
            return TypedNode(ast::Variant::Not(v), node.source, r)
        }
        Member(Pair(accessed, mem_name)) {
            // TODO!
            return panic("not yet implemented")
        }
        Call(ast::Invocation(invoked, args)) {
            // -> Call (arbitrary)
            // -> NamedCall (function)
            // -> StructInit (structure)
            // -> EnumInit (enumeration)
            // TODO!
            return panic("not yet implemented")
        }
        PipedCall(ast::Invocation(invoked, args)) {
            // 1. do required expansions
            // 2. turn into 'Call'
            // 3. return result of checking result of 2.
            // TODO!
            return panic("not yet implemented")
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c = Type(Variant::Boolean, !IS_MUTABLE, node.source)
            val cond_t: TypedNode = self |> check(cond, c)
            val if_val_t: TypedNode = self |> infer(if_val)
            val else_val_t: TypedNode = self |> infer(else_val)
            val r: Type = self 
                |> join_types(if_val_t.type, else_val_t.type, node.source)
            return TypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond_t, if_val_t, else_val_t)), 
                node.source, r
            )
        }

        _ {
            return TypedNode(
                ast::Variant::Invalid, 
                node.source, 
                Type(Variant::Invalid, !IS_MUTABLE, node.source)
            )
        }
    }
}