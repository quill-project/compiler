
mod quill::parser

use quill::*
use quill::token::(Token, TokenType)
use quill::ast::UntypedNode

pub struct Parser(
    current: Token, 
    after: mut Stream[Token],
    broken: Bool,
    messages: mut List[Message]
)

// Creates a new parser over the given token stream, reporting messages
// into the given list.
// Expects only tokens for which 'TokenType::is_relevant' returns true
// to be included in 'tokens'.
pub fun Parser::from(
    tokens: mut Stream[Token], messages: mut List[Message]
) -> mut Parser
    = Parser(tokens |> next(), tokens, false, messages)

// Discards the 'current' token and replaces it with the next token from the
// contained token stream.
pub fun Parser::advance(self: mut Parser) {
    self.current = self.after |> next()
}

// Asserts that the type of the 'current' token in 'self' is contained in the
// given list of allowed 'types'. If that is not the case, an appropriate error
// is added to the 'messages' in 'self' and 'self' is marked as broken.
// If 'self' is already broken, no message is generated.
// If the current token is an invalid token, no message is generated.
// The current value of 'self.broken' is returned at the end of the call.
pub fun Parser::expect(
    self: mut Parser, ...types: List[TokenType]
) -> Bool {
    if self.broken { return true }
    val valid = types |> values() |> any(|t| t == self.current.type)
    if valid { return false }
    if self.current.type != TokenType::Invalid {
        self.messages |> push(Message::unexpected_token(self.current, types))
    }
    self.broken = true
    return true
}



// Maps unary operators to their respective operator precedence
pub val unary_operator_prec: Map[TokenType, Int] = Map::of(
    Pair(TokenType::Minus,            2),
    Pair(TokenType::ExclamationMark,  2)
)

// Maps binary operators to their respective operator precedence
pub val binary_operator_prec: Map[TokenType, Int] = Map::of(
    Pair(TokenType::ParenOpen,        1),
    Pair(TokenType::Dot,              1),
    Pair(TokenType::Asterisk,         3),
    Pair(TokenType::Slash,            3),
    Pair(TokenType::Percent,          3),
    Pair(TokenType::Plus,             4),
    Pair(TokenType::Minus,            4),
    Pair(TokenType::LessThan,         5),
    Pair(TokenType::GreaterThan,      5),
    Pair(TokenType::LessThanEqual,    5),
    Pair(TokenType::GreaterThanEqual, 5),
    Pair(TokenType::DoubleEqual,      6),
    Pair(TokenType::NotEqual,         6),
    Pair(TokenType::DoubleAmpersand,  7),
    Pair(TokenType::DoublePipe,       8),
    Pair(TokenType::Triangle,         9)
)



// Shorthand for constructing an invalid AST node with the source being the
// current token
pub fun make_inv(s: mut Parser) -> UntypedNode
    = UntypedNode(ast::Variant::Invalid, s.current.source)

// Parses a path, such as 'std::println'. Stops after the first identifier
// not followed by a path separator and expects the starting state to be
// the first identifier of the path. Returns both the list of path segments
// and the source span of the last identifier in the path.
pub fun parse_path(s: mut Parser) -> Pair[List[String], Source] {
    if s.broken { return Pair(List::of(s.current.content), s.current.source) }
    mut last_source: Source = s.current.source
    val segments: mut List[String] = List::of(s.current.content)
    s |> advance()
    Stream::new[Unit](|| unit)
        |> take_while(|_| s.current.type == TokenType::PathSeparator)
        |> for_each(|_| {
            s |> advance()
            if s |> expect(TokenType::Identifier) { return unit }
            segments |> push(s.current.content)
            last_source = s.current.source
            s |> advance()
        })
    return Pair(segments, last_source)
}

// Parses a list of given type names, such as '[Int, Float]'. Stops after the
// closing ']' and expects the starting state to be at the opening '['.
pub fun parse_given_type_args(s: mut Parser) -> Option[List[UntypedNode]] {
    if s.broken { return Option::None }
    if s.current.type != TokenType::BracketOpen { return Option::None }
    s |> advance()
    val t_args: List[UntypedNode] = Stream::new[Token](|| s.current)
        |> take_until(|t| t.type == TokenType::BracketClose || s.broken)
        |> map[Token, UntypedNode](|_| {
            val arg = parse_type(s)
            s |> expect(TokenType::Comma, TokenType::BracketClose)
            if s.current.type == TokenType::Comma {
                s |> advance()
            }
            return arg
        })
        |> List::collect()
    if s |> expect(TokenType::BracketClose) { return Option::None }
    s |> advance()
    return Option::Some(t_args)
}

// Parses a list of names, such as 'a, b, c'. Stops at the next token with a
// type equal to 'end' and expects the starting state to be at the first name.
pub fun parse_name_list(s: mut Parser, end: TokenType) -> Option[List[String]] 
    = Stream::new[Token](|| s.current)
    |> take_until(|t| t.type == end || s.broken)
    |> fold[Token, Option[mut List[String]]](
        Option::Some(List::empty[String]()), 
        |acc, _| acc |> and_then(|a| {
            if s |> expect(TokenType::Identifier) { return Option::None }
            a |> push(s.current.content)
            s |> advance()
            if s |> expect(TokenType::Comma, end) { return Option::None }
            if s.current.type == TokenType::Comma {
                s |> advance()
            }
            return Option::Some(a)
        })
    )


// Parses a value, meaning either a literal or a unary operator, 
// e.g. '5', '-10.0'
pub fun parse_value(s: mut Parser) -> UntypedNode {
    if s.broken { return make_inv(s) }
    val start: Token = s.current
    val value: String = start.content
    match start.type {
        // expression in parentheses, e.g. '(5 + 5)'
        ParenOpen {
            s |> advance()
            val value: UntypedNode = parse_expression(s, Int::MAX)
            if s |> expect(TokenType::ParenClose) { return make_inv(s) }
            s |> advance()
            return value
        }
        // path and type arguments, e.g. 'std::println[String]'
        Identifier {
            val path: Pair[List[String], Source] = parse_path(s)
            val t_args: Option[List[UntypedNode]] = parse_given_type_args(s)
            return UntypedNode(
                ast::Variant::PathRef(ast::PathRef(path.first, t_args)),
                Source::range(start.source, path.second)
            )
        }
        // value literals, e.g. '5', 'true', '2.53'
        IntLiteral {
            s |> advance()
            val parsed: Int = Int::parse(value) 
                |> expect("Lexer should only tokenize valid int literals")
            return UntypedNode(ast::Variant::Int(parsed), start.source)
        }
        FloatLiteral {
            s |> advance()
            val parsed: Float = Float::parse(value)
                |> expect("Lexer should only tokenize valid float literals")
            return UntypedNode(ast::Variant::Float(parsed), start.source)
        }
        BoolLiteral {
            s |> advance()
            val parsed: Bool = value == "true"
            return UntypedNode(ast::Variant::Bool(parsed), start.source)
        }
        UnitLiteral {
            s |> advance()
            return UntypedNode(ast::Variant::Unit, start.source)
        }
        StringLiteral {
            s |> advance()
            return UntypedNode(ast::Variant::String(value), start.source)
        }
        // closure literals
        Pipe | DoublePipe {
            mut arg_names: List[String] = List::empty()
            if s.current.type == TokenType::Pipe {
                s |> advance()
                match parse_name_list(s, TokenType::Pipe) {
                    Some(args) { arg_names = args }
                    None { return make_inv(s) }
                }
                if s |> expect(TokenType::Pipe) { return make_inv(s) }
            }
            s |> advance()
            mut body: List[UntypedNode] = List::empty()
            mut end: Source = s.current.source
            if s.current.type == TokenType::BraceOpen {
                s |> advance()
                body = parse_statement_list(s, TokenType::BraceClose)
                if s |> expect(TokenType::BraceClose) { return make_inv(s) }
                end = s.current.source
                s |> advance()
            } else {
                val value: UntypedNode = parse_expression(s, Int::MAX)
                end = value.source
                body = List::of(
                    UntypedNode(ast::Variant::Return(value), value.source)
                )
            }
            return UntypedNode(
                ast::Variant::Closure(ast::Closure(
                    arg_names, List::empty(), Map::empty(), body
                )),
                Source::range(start.source, end)
            )
        }
        // 'if'-expression, e.g. 'if x < 5 { 5 } else if x > 10 { 10 } else { x }'
        KeywordIf {
            s |> advance()
            val cond: UntypedNode = parse_expression(s, Int::MAX)
            if s |> expect(TokenType::BraceOpen) { return make_inv(s) }
            s |> advance()
            val if_value: UntypedNode = parse_expression(s, Int::MAX)
            if s |> expect(TokenType::BraceClose) { return make_inv(s) }
            s |> advance()
            if s |> expect(TokenType::KeywordElse) { return make_inv(s) }
            s |> advance()
            if s |> expect(TokenType::KeywordIf, TokenType::BraceOpen) { 
                return make_inv(s) 
            }
            val chained: Bool = s.current.type == TokenType::KeywordIf
            if !chained {
                s |> advance()
            }
            val else_value: UntypedNode = parse_expression(s, Int::MAX)
            mut end: Source = else_value.source
            if !chained {
                if s |> expect(TokenType::BraceClose) { return make_inv(s) }
                end = s.current.source
                s |> advance()
            }
            return UntypedNode(
                ast::Variant::IfExpr(ast::IfExpr(cond, if_value, else_value)),
                Source::range(start.source, end)
            )
        }
        _ {}
    }
    val op: Token = s.current
    mut prec: Int = 0
    match unary_operator_prec |> get(op.type) {
        Some(p) { prec = p }
        None {
            s.messages |> push(
                Message::unexpected_construct(s.current, "an expression")
            )
            s.broken = true
            return make_inv(s)
        }
    }
    s |> advance()
    val operand: UntypedNode = parse_expression(s, prec) 
    val src: Source = Source::range(start.source, operand.source)
    match op.type {
        Minus { return UntypedNode(ast::Variant::Negate(operand), src) }
        ExclamationMark { return UntypedNode(ast::Variant::Not(operand), src) }
        _ { return panic("Unhandled token type in 'parse_value'") }
    }
}


// Parses an expression, including literals, unary operators and binary operators,
// e.g. '5 + 5', 'true', '!(3 < 4)'
pub fun parse_expression(s: mut Parser, parent_prec: Int) -> UntypedNode
    = Sequence::new[Int](|| binary_operator_prec |> get(s.current.type))
    |> take_until(|curr_prec| curr_prec >= parent_prec || s.broken)
    |> fold(parse_value(s), |lhs, curr_prec| {
        if s.broken { return make_inv(s) }
        val op: Token = s.current
        s |> advance()
        match op.type {
            ParenOpen {
                val args: List[UntypedNode] = Stream::new[Token](|| s.current)
                    |> take_until(|_| s.broken)
                    |> take_until(|t| t.type == TokenType::ParenClose)
                    |> map[Token, UntypedNode](|_| {
                        val arg: UntypedNode = parse_expression(s, Int::MAX)
                        s |> expect(TokenType::Comma, TokenType::ParenClose)
                        if s.current.type == TokenType::Comma {
                            s |> advance()
                        }
                        return arg
                    })
                    |> List::collect()
                val end: Token = s.current
                s |> advance()
                return UntypedNode(
                    ast::Variant::Call(ast::Invocation(lhs, args)),
                    Source::range(lhs.source, end.source)
                )
            }
            Dot {
                if s |> expect(TokenType::Identifier) { return make_inv(s) }
                val name: Token = s.current
                s |> advance()
                return UntypedNode(
                    ast::Variant::Member(Pair(lhs, name.content)), 
                    Source::range(lhs.source, name.source)
                )
            }
            _ {}
        }
        val rhs: UntypedNode = parse_expression(s, curr_prec)
        val operands: Pair[UntypedNode, UntypedNode] = Pair(lhs, rhs)
        val src: Source = Source::range(lhs.source, rhs.source)
        match op.type {
            Asterisk         { return UntypedNode(ast::Variant::Multiply        (Pair(lhs, rhs)), src) }
            Slash            { return UntypedNode(ast::Variant::Divide          (Pair(lhs, rhs)), src) }
            Percent          { return UntypedNode(ast::Variant::Remainder       (Pair(lhs, rhs)), src) }
            Plus             { return UntypedNode(ast::Variant::Add             (Pair(lhs, rhs)), src) }
            Minus            { return UntypedNode(ast::Variant::Subtract        (Pair(lhs, rhs)), src) }
            LessThan         { return UntypedNode(ast::Variant::LessThan        (Pair(lhs, rhs)), src) }
            GreaterThan      { return UntypedNode(ast::Variant::GreaterThan     (Pair(lhs, rhs)), src) }
            LessThanEqual    { return UntypedNode(ast::Variant::LessThanEqual   (Pair(lhs, rhs)), src) }
            GreaterThanEqual { return UntypedNode(ast::Variant::GreaterThanEqual(Pair(lhs, rhs)), src) }
            DoubleEqual      { return UntypedNode(ast::Variant::Equal           (Pair(lhs, rhs)), src) }
            NotEqual         { return UntypedNode(ast::Variant::NotEqual        (Pair(lhs, rhs)), src) }
            DoubleAmpersand {
                // 'lhs && rhs' -> 'if lhs { rhs } else { false }'
                return UntypedNode(ast::Variant::IfExpr(ast::IfExpr(
                    lhs, // condition
                    rhs, // if value
                    UntypedNode(ast::Variant::Bool(false), src) // else value
                )), src)
            }
            DoublePipe {
                // 'lhs || rhs' -> 'if lhs { true } else { rhs }'
                return UntypedNode(ast::Variant::IfExpr(ast::IfExpr(
                    lhs, // condition
                    UntypedNode(ast::Variant::Bool(true), src), // if value
                    rhs // else value
                )), src)
            }
            Triangle {
                mut called: UntypedNode = lhs
                mut args: mut List[UntypedNode] = List::empty()
                match rhs.value {
                    Call(ast::Invocation(invoked, og_args)) {
                        called = invoked
                        args = og_args |> slice_from(0)
                    }
                    _ {
                        s.messages |> push(Message::non_call_pipe(src))
                        s.broken = true
                        return make_inv(s)
                    }
                }
                args |> insert(0, lhs)
                return UntypedNode(
                    ast::Variant::PipedCall(ast::Invocation(called, args)), src
                )
            }
            _ { return panic("Unhandled token type in 'parse_expression'") }
        }
    })


// Parses a type, such as a named type or a function type
pub fun parse_type(s: mut Parser) -> UntypedNode {
    if s.broken { return make_inv(s) }
    val start: Token = s.current
    if s.current.content == "Fun" {
        s |> advance()
        if s |> expect(TokenType::ParenOpen) { return make_inv(s) }
        s |> advance()
        val arg_types: List[UntypedNode] = Stream::new[Token](|| s.current)
            |> take_until(|t| t.type == TokenType::ParenClose || s.broken)
            |> map[Token, UntypedNode](|_| {
                val arg: UntypedNode = parse_type(s)
                s |> expect(TokenType::Comma, TokenType::ParenClose)
                if s.current.type == TokenType::Comma {
                    s |> advance()
                }
                return arg
            })
            |> List::collect()
        if s |> expect(TokenType::ParenClose) { return make_inv(s) }
        mut end: Source = s.current.source
        s |> advance()
        mut ret_type: Option[UntypedNode] = Option::None
        if s.current.type == TokenType::ArrowRight {
            s |> advance()
            val r = parse_type(s)
            ret_type = Option::Some(r)
            end = r.source
        }
        return UntypedNode(
            ast::Variant::FunctionType(ast::FunctionType(arg_types, ret_type)),
            Source::range(start.source, end)
        )
    }
    match s.current.type {
        KeywordMut | Identifier {
            val mutable: Bool = s.current.type == TokenType::KeywordMut
            if mutable {
                s |> advance()
                if s |> expect(TokenType::Identifier) { return make_inv(s) }
            }
            val path: Pair[List[String], Source] = parse_path(s)
            val t_args: Option[List[UntypedNode]] = parse_given_type_args(s)
            return UntypedNode(
                ast::Variant::TypeRef(
                    Pair(mutable, ast::PathRef(path.first, t_args))
                ),
                Source::range(start.source, path.second)
            )
        }
        _ {
            s.messages |> push(
                Message::unexpected_construct(s.current, "a type")
            )
            s.broken = true
            return make_inv(s)
        }
    }
}


// Parses a list of argument / member names and their types, such as
// 'a: Int, b: Float, c: String'.
// The starting value in the box 'varargs' determines if usage of varargs
// is allowed. At the end of the call, the box will contain whether vargargs
// was used.
pub fun parse_name_type_list(
    s: mut Parser, end: TokenType, types_opt: Bool, varargs: mut Box[Bool]
) -> Option[List[Pair[String, UntypedNode]]] {
    val varargs_allowed: Bool = varargs.value
    varargs.value = false
    return Stream::new[Token](|| s.current)
    |> take_until(|t| t.type == end || s.broken)
    |> fold[Token, Option[mut List[Pair[String, UntypedNode]]]](
        Option::Some(List::empty[Pair[String, UntypedNode]]()),
        |acc, _| acc |> and_then(|args| {
            if varargs_allowed {
                if s |> expect(TokenType::Identifier, TokenType::TripleDots) {
                    return Option::None
                }
                if s.current.type == TokenType::TripleDots {
                    varargs.value = true
                    s |> advance()
                }
            }
            if s |> expect(TokenType::Identifier) { return Option::None }
            val name: Token = s.current
            s |> advance()
            if types_opt && s.current.type != TokenType::Colon {
                val t = UntypedNode(
                    ast::Variant::TypeRef(Pair(
                        false, 
                        ast::PathRef(List::of("std", "Unit"), Option::None)
                    )), 
                    name.source
                )
                val arg: Pair[String, UntypedNode] = Pair(name.content, t)
                args |> push(arg)
            } else {
                if s |> expect(TokenType::Colon) { return Option::None }
                s |> advance()
                val type: UntypedNode = parse_type(s)
                val arg: Pair[String, UntypedNode] = Pair(name.content, type)
                args |> push(arg)    
            }
            if varargs.value && (s |> expect(end)) { return Option::None } 
            if s |> expect(TokenType::Comma, end) { return Option::None }
            if s.current.type == TokenType::Comma {
                s |> advance()
            }
            return Option::Some(args)
        })
    )
}


// A set containing all tokens that are ONLY used to start local statements.
// 'val' and 'mut' are NOT included in this set because they may also be used
// to define a GLOBAL variable.
pub val statement_starters: Set[TokenType] = Set::of(
    TokenType::KeywordIf, TokenType::KeywordElse, 
    TokenType::KeywordReturn, TokenType::KeywordContinue,
    TokenType::KeywordBreak, TokenType::KeywordMatch,
    TokenType::KeywordWhile, TokenType::KeywordFor
)

// Parses a local statement, including variable declarations, loops and 
// other statements and expressions.
pub fun parse_statement(s: mut Parser) -> UntypedNode {
    if s.broken {
        // if broken, attempt recovery to a known start of a local statement
        val recovered: Fun(Token) -> Bool 
            = |t| (statement_starters |> has(t.type))
                || t.type == TokenType::EndOfFile
        Stream::new[Token](|| s.current)
            |> take_until(recovered)
            |> for_each(|_| s |> advance())
        s.broken = s.current.type == TokenType::EndOfFile
        if s.broken { return make_inv(s) }
    }
    val start: Token = s.current
    match s.current.type {
        // val a = 5
        // val b: Float = 3.5
        // mut c: Int = 15
        KeywordVal | KeywordMut {
            val mutable: Bool = s.current.type == TokenType::KeywordMut
            s |> advance()
            if s |> expect(TokenType::Identifier) { return make_inv(s) }
            val name: String = s.current.content
            s |> advance()
            if s |> expect(TokenType::Colon, TokenType::Equal) { 
                return make_inv(s) 
            }
            mut type: Option[UntypedNode] = Option::None
            if s.current.type == TokenType::Colon {
                s |> advance()
                type = Option::Some(parse_type(s))
            }
            if s |> expect(TokenType::Equal) { return make_inv(s) }
            s |> advance()
            val value: UntypedNode = parse_expression(s, Int::MAX)
            return UntypedNode(
                ast::Variant::LocalVariable(ast::LocalVariable(
                    name, mutable, Box(false), type, value
                )),
                Source::range(start.source, value.source)
            )
        }
        // return 5
        // return unit
        KeywordReturn {
            s |> advance()
            val value: UntypedNode = parse_expression(s, Int::MAX)
            return UntypedNode(
                ast::Variant::Return(value),
                Source::range(start.source, value.source)
            )
        }
        // match x {
        //     5 { ... }
        //     10 { ... }
        // }
        KeywordMatch {
            s |> advance()
            val matched: UntypedNode = parse_expression(s, Int::MAX)
            if s |> expect(TokenType::BraceOpen) { return make_inv(s) }
            s |> advance()
            val branches: List[ast::MatchBranch[UntypedNode]]
                = Stream::new[Token](|| s.current)
                |> take_until(
                    |t| t.type == TokenType::BraceClose || s.broken
                )
                |> map[Token, ast::MatchBranch[UntypedNode]](|_| {
                    val patterns: List[ast::MatchPattern[UntypedNode]]
                        = Stream::new[Token](|| s.current)
                        |> take_until(
                            |t| t.type == TokenType::BraceOpen || s.broken
                        )
                        |> map[Token, ast::MatchPattern[UntypedNode]](|_| {
                            val p = parse_expression(s, Int::MAX)
                            s |> expect(
                                TokenType::Pipe, TokenType::BraceOpen
                            )
                            if s.current.type == TokenType::Pipe {
                                s |> advance()
                            }
                            return ast::MatchPattern(
                                p, List::empty(), List::empty()
                            )
                        })
                        |> List::collect()
                    if s |> expect(TokenType::BraceOpen) {
                        return ast::MatchBranch(
                            patterns, Map::empty(), List::empty()
                        )
                    }
                    s |> advance()
                    val body: List[UntypedNode] 
                        = parse_statement_list(s, TokenType::BraceClose)
                    s |> expect(TokenType::BraceClose)
                    s |> advance()
                    return ast::MatchBranch(patterns, Map::empty(), body)
                })
                |> List::collect()
            if s |> expect(TokenType::BraceClose) { return make_inv(s) }
            val end: Source = s.current.source
            s |> advance()
            return UntypedNode(
                ast::Variant::Match(ast::Match(matched, branches)),
                Source::range(start.source, end)
            )
        }
        // if c { ... }
        // if c { ... } else { ... }
        // if c { ... } else if c { ... } else { ... }
        KeywordIf {
            s |> advance()
            val cond: UntypedNode = parse_expression(s, Int::MAX)
            if s |> expect(TokenType::BraceOpen) { return make_inv(s) }
            s |> advance()
            val if_body: List[UntypedNode] 
                = parse_statement_list(s, TokenType::BraceClose)
            if s |> expect(TokenType::BraceClose) { return make_inv(s) }
            mut end: Source = s.current.source
            s |> advance()
            mut else_body: List[UntypedNode] = List::empty()
            if s.current.type == TokenType::KeywordElse {
                s |> advance()
                if s |> expect(TokenType::KeywordIf, TokenType::BraceOpen) {
                    return make_inv(s)
                }
                if s.current.type == TokenType::KeywordIf {
                    val else_branch: UntypedNode = parse_statement(s)
                    end = else_branch.source
                    else_body = List::of(else_branch)
                } else {
                    s |> advance()
                    else_body 
                        = parse_statement_list(s, TokenType::BraceClose)
                    if s |> expect(TokenType::BraceClose) { 
                        return make_inv(s) 
                    }
                    end = s.current.source
                    s |> advance()
                }
            }
            return UntypedNode(
                ast::Variant::If(ast::If(cond, if_body, else_body)),
                Source::range(start.source, end)
            )
        }
        // while c { ... }
        KeywordWhile {
            s |> advance()
            val cond: UntypedNode = parse_expression(s, Int::MAX)
            if s |> expect(TokenType::BraceOpen) { return make_inv(s) }
            s |> advance()
            val body: List[UntypedNode] 
                = parse_statement_list(s, TokenType::BraceClose)
            if s |> expect(TokenType::BraceClose) { return make_inv(s) }
            val end: Source = s.current.source
            s |> advance()
            return UntypedNode(
                ast::Variant::While(ast::While(cond, body)),
                Source::range(start.source, end)
            )
        }
        // for n: s { ... }
        KeywordFor {
            s |> advance()
            if s |> expect(TokenType::Identifier) { return make_inv(s) }
            val name: String = s.current.content
            s |> advance()
            if s |> expect(TokenType::Colon) { return make_inv(s) }
            s |> advance()
            val seq: UntypedNode = parse_expression(s, Int::MAX)
            if s |> expect(TokenType::BraceOpen) { return make_inv(s) }
            s |> advance()
            val body: List[UntypedNode]
                = parse_statement_list(s, TokenType::BraceClose)
            if s |> expect(TokenType::BraceClose) { return make_inv(s) }
            val end: Source = s.current.source
            s |> advance()
            return UntypedNode(
                ast::Variant::For(ast::For(name, Box(false), seq, body)),
                Source::range(start.source, end)
            )
        }
        // continue
        KeywordContinue {
            s |> advance()
            return UntypedNode(ast::Variant::Continue, start.source)
        }
        // break
        KeywordBreak {
            s |> advance()
            return UntypedNode(ast::Variant::Break, start.source)
        }
        _ {}
    }
    val lhs: UntypedNode = parse_expression(s, Int::MAX)
    if s.current.type == TokenType::Equal {
        s |> advance()
        val rhs: UntypedNode = parse_expression(s, Int::MAX)
        return UntypedNode(
            ast::Variant::Assignment(Pair(lhs, rhs)),
            Source::range(lhs.source, rhs.source)
        )
    }
    return lhs
}


// Repeatedly parses statements until the current token type is equal to the one
// specified by 'end'.
pub fun parse_statement_list(s: mut Parser, end: TokenType) -> List[UntypedNode]
    = Stream::new[Token](|| s.current)
    |> take_until(|t| t.type == end || s.broken)
    |> map[Token, UntypedNode](|_| parse_statement(s))
    |> List::collect()


// A set containing all tokens that are ONLY used to start global definitions.
// 'val' and 'mut' are NOT included in this set because they may also be used
// to define local variables.
pub val declaration_starters: Set[TokenType] = Set::of(
    TokenType::KeywordPub, TokenType::KeywordExt, 
    TokenType::KeywordFun, TokenType::KeywordMod,
    TokenType::KeywordUse, TokenType::KeywordStruct,
    TokenType::KeywordEnum
)

// Parses a path used in a 'use' declaration, which may be a path
// such as 'std::test' optionally followed by either an asterisk (wildcard)
// ('std::test::*')
// or a parenthesized list of even more paths
// ('quill::token::(Token, TokenType, TokenType::is_relevant)')
pub fun parse_usages(s: mut Parser, before: List[String]) -> Pair[List[Pair[String, List[String]]], Source] {
    val path: mut List[String] = before |> slice_from(0)
    mut end: Source = s.current.source
    val single_result: Fun() -> Pair[List[Pair[String, List[String]]], Source]
        = || Pair(List::of(Pair(path |> at(-1), path)), end)
    if s |> expect(TokenType::Identifier) { return single_result() }
    val ended: Bool = Stream::new[Token](|| s.current)
        |> take_until(|t| t.type != TokenType::Identifier || s.broken)
        |> map[Token, Bool](|_| {
            path |> push(s.current.content)
            end = s.current.source
            s |> advance()
            if s.current.type != TokenType::PathSeparator { return true }
            s |> advance()
            s |> expect(
                TokenType::Identifier, TokenType::Asterisk, TokenType::ParenOpen
            )
            return false
        })
        |> any(|e| e)
    if !ended {
        match s.current.type {
            Asterisk {
                path |> push(s.current.content)
                end = s.current.source
                s |> advance()
                return single_result()
            }
            ParenOpen {
                s |> advance()
                val usages: List[Pair[String, List[String]]]
                    = Stream::new[Token](|| s.current)
                    |> take_until(
                        |t| t.type == TokenType::ParenClose || s.broken
                    )
                    |> map[Token, List[Pair[String, List[String]]]](|_| {
                        val usage = parse_usages(s, path).first
                        s |> expect(TokenType::Comma, TokenType::ParenClose)
                        if s.current.type == TokenType::Comma { s |> advance() }
                        return usage
                    })
                    |> reduce(List::concat)
                    |> unwrap_or(List::empty())
                val end: Source = s.current.source
                s |> advance()
                return Pair(usages, end)
            }
            _ { panic[Unit]("Unhandled token type in 'parse_usages'") }
        }
    }
    if s.current.type == TokenType::KeywordAs {
        s |> advance()
        if s |> expect(TokenType::Identifier) { return single_result() }
        val pattern: String = s.current.content
        end = s.current.source
        s |> advance()
        return Pair(List::of(Pair(pattern, path)), end)
    }
    return single_result()
}

// Parses only top level statements and declarations, such as functions, types,
// module declarations, path usages, ...
pub fun parse_declaration(s: mut Parser) -> UntypedNode {
    if s.broken {
        // if broken, attempt recovery to a known start of a global declaration
        val recovered: Fun(Token) -> Bool 
            = |t| (declaration_starters |> has(t.type))
                || t.type == TokenType::EndOfFile
        Stream::new[Token](|| s.current)
            |> take_until(recovered)
            |> for_each(|_| s |> advance())
        s.broken = false
    }
    val start: Token = s.current
    mut public: Bool = s.current.type == TokenType::KeywordPub
    if public {
        s |> advance()
        if s |> expect(
            TokenType::KeywordExt, TokenType::KeywordFun, 
            TokenType::KeywordMut, TokenType::KeywordVal,
            TokenType::KeywordEnum, TokenType::KeywordStruct
        ) { return make_inv(s) }
    }
    match s.current.type {
        // mod example::test
        KeywordMod {
            s |> advance()
            if s |> expect(TokenType::Identifier) { return make_inv(s) }
            val path: Pair[List[String], Source] = parse_path(s)
            return UntypedNode(
                ast::Variant::Module(path.first),
                Source::range(start.source, path.second)
            )
        }
        // use example::test::add
        // use example::test::PI as HALF_TAU
        // use example::(test::subtract, execute::*)
        KeywordUse {
            s |> advance()
            val usages: Pair[List[Pair[String, List[String]]], Source]
                = parse_usages(s, List::empty())
            return UntypedNode(
                ast::Variant::Usages(usages.first),
                Source::range(start.source, usages.second)
            )
        }
        // val a = 5
        // val b: Float = 3.5
        // mut c: Int = 15
        // mut example::d: Float = 20.1
        KeywordVal | KeywordMut {
            val mutable: Bool = s.current.type == TokenType::KeywordMut
            s |> advance()
            if s |> expect(TokenType::Identifier) { return make_inv(s) }
            val path: List[String] = parse_path(s).first
            if s |> expect(TokenType::Colon) { return make_inv(s) }
            s |> advance()
            val type: UntypedNode = parse_type(s)
            if s |> expect(TokenType::Equal) { return make_inv(s) }
            s |> advance()
            val value: UntypedNode = parse_expression(s, Int::MAX)
            return UntypedNode(
                ast::Variant::GlobalVariable(ast::GlobalVariable(
                    path, public, mutable, type, value
                )),
                Source::range(start.source, value.source)
            )
        }
        KeywordFun | KeywordExt {
            val external: Bool = s.current.type == TokenType::KeywordExt
            if external {
                s |> advance()
            }
            if s |> expect(TokenType::KeywordFun) { return make_inv(s) }
            s |> advance()
            if s |> expect(TokenType::Identifier) { return make_inv(s) }
            val path: List[String] = parse_path(s).first
            if s |> expect(TokenType::BracketOpen, TokenType::ParenOpen) {
                return make_inv(s)
            }
            mut t_args: List[String] = List::empty()
            if s.current.type == TokenType::BracketOpen {
                s |> advance()
                match parse_name_list(s, TokenType::BracketClose) {
                    Some(args) { t_args = args }
                    None { return make_inv(s) }
                }
                if s |> expect(TokenType::BracketClose) { return make_inv(s) }
                s |> advance()
            }
            if s |> expect(TokenType::ParenOpen) { return make_inv(s) }
            s |> advance()
            mut args: List[Pair[String, UntypedNode]] = List::empty()
            val varargs = Box(true)
            match parse_name_type_list(
                s, TokenType::ParenClose, false, varargs
            ) {
                Some(a) { args = a }
                None { return make_inv(s) }
            }
            if s |> expect(TokenType::ParenClose) { return make_inv(s) }
            s |> advance()
            mut ret_t: Option[UntypedNode] = Option::None
            if s.current.type == TokenType::ArrowRight {
                s |> advance()
                ret_t = Option::Some(parse_type(s))
            }
            if !external {
                if s |> expect(TokenType::Equal, TokenType::BraceOpen) { 
                    return make_inv(s) 
                }
            }
            if !external && s.current.type == TokenType::BraceOpen {
                s |> advance()
                val body: List[UntypedNode] 
                    = parse_statement_list(s, TokenType::BraceClose)
                if s |> expect(TokenType::BraceClose) { return make_inv(s) }
                val end: Source = s.current.source
                s |> advance()
                return UntypedNode(
                    ast::Variant::Function(ast::Function(
                        path, public, t_args, args, varargs.value, 
                        List::empty(), ret_t, body
                    )),
                    Source::range(start.source, end)
                )
            } else if !external && s.current.type == TokenType::Equal {
                s |> advance()
                val value: UntypedNode = parse_expression(s, Int::MAX)
                val body: List[UntypedNode] = List::of(UntypedNode(
                    ast::Variant::Return(value), value.source
                ))
                return UntypedNode(
                    ast::Variant::Function(ast::Function(
                        path, public, t_args, args, varargs.value, 
                        List::empty(), ret_t, body
                    )),
                    Source::range(start.source, value.source)
                )
            } else {
                if s |> expect(TokenType::Equal) { return make_inv(s) }
                s |> advance()
                if s |> expect(TokenType::StringLiteral) { return make_inv(s) }
                val body: Token = s.current
                s |> advance()
                return UntypedNode(
                    ast::Variant::ExternalFunction(ast::ExternalFunction(
                        path, public, t_args, args, varargs.value,
                        ret_t, body.content
                    )),
                    Source::range(start.source, body.source)
                )
            }
        }
        KeywordStruct | KeywordEnum {
            val is_struct: Bool = s.current.type == TokenType::KeywordStruct
            s |> advance()
            if s |> expect(TokenType::Identifier) { return make_inv(s) }
            val path: List[String] = parse_path(s).first
            if s |> expect(TokenType::BracketOpen, TokenType::ParenOpen) {
                return make_inv(s)
            }
            mut t_args: List[String] = List::empty()
            if s.current.type == TokenType::BracketOpen {
                s |> advance()
                match parse_name_list(s, TokenType::BracketClose) {
                    Some(args) { t_args = args }
                    None { return make_inv(s) }
                }
                if s |> expect(TokenType::BracketClose) { return make_inv(s) }
                s |> advance()
            }
            if s |> expect(TokenType::ParenOpen) { return make_inv(s) }
            s |> advance()
            mut args: List[Pair[String, UntypedNode]] = List::empty()
            match parse_name_type_list(
                s, TokenType::ParenClose, !is_struct, Box(false)
            ) {
                Some(a) { args = a }
                None { return make_inv(s) }
            }
            if s |> expect(TokenType::ParenClose) { return make_inv(s) }
            val end: Source = s.current.source
            s |> advance()
            val type_def = ast::CustomType(path, public, t_args, args)
            val src = Source::range(start.source, end)
            return if is_struct {
                UntypedNode(ast::Variant::Structure(type_def), src)
            } else {
                UntypedNode(ast::Variant::Enumeration(type_def), src)
            }
        }
        _ {
            s.messages |> push(
                Message::unexpected_construct(s.current, "a top-level statement")
            )
            s.broken = true
            return make_inv(s)
        }
    }
}

// Repeatedly parses declarations until the end of the file is reached.
pub fun parse_file(s: mut Parser) -> List[UntypedNode]
    = Stream::new[Token](|| s.current)
    |> take_until(|t| t.type == TokenType::EndOfFile)
    |> map[Token, UntypedNode](|_| parse_declaration(s))
    |> List::collect()