
mod quill::codegen::c

use quill::*
use quill::types::*

pub val HEADER: String = "
// C code generated from Quill source code by the Quill compiler
// https://github.com/schwalbe-t/quill

#include <quill.h>

"

// Returns a list of all instances of all symbols in the given symbol table.
fun all_instances_of(table: SymbolTable) -> mut Sequence[Triplet[TypedNode, Int, List[Type]]]
    = table.symbols 
    |> values() 
    |> map[Symbol, mut Sequence[Triplet[TypedNode, Int, List[Type]]]](
        |s| s.instances |> values()
    )
    |> flatten()

// Turns a Quill path and instance id into a valid C symbol name.
// This function makes sure that the same combination of path and id will always
// result in the same, unique name.
pub fun mangle_path(path: List[String], id: Int) -> String
    = path |> values()
    |> map[String, String](|s| s |> replace("_", "__"))
    |> join("_")
    |> concat("_")
    |> concat(id |> as_string())

// Looks up the id and typed node of the symbol instance with the given type arguments
// from the symbol with the given path from the given symbol table.
pub fun find_instance_with(
    path: List[String], t_args: List[Type], table: SymbolTable
) -> Triplet[TypedNode, Int, List[Type]] {
    val s: Symbol = table.symbols |> get(path) 
        |> expect("unknown path should've been rejected during checking")
    val i: SymbolInstance = SymbolInstance(path, t_args)
    return s.instances |> get(i |> key())
        |> expect("instance should've been instantiated during checking")
}

// Turns a Quill type into a valid C type name.
pub fun emit_type(t: Type) -> String {
    match t.value {
        Unit { return "quill_unit_t" }
        Integer { return "quill_int_t" }
        Float { return "quill_float_t" }
        Boolean { return "quill_bool_t" }
        String { return "quill_string_t" }
        Struct(_) { return "quill_struct_t" }
        Enum(_) { return "quill_enum_t" }
        Function(_) { return "quill_closure_t" }
        List(_) { return "quill_list_t" }
        
        Invalid { return panic("invalid type generated by type checker") }
    }
}

// Given a list of member names and types, returns the C code for the body
// of the equivalent type definition.
fun emit_type_members(members: List[Pair[String, TypedNode]]) -> String {
    if 0 == (members |> length()) { return "    quill_unit_t empty;" }
    return members 
        |> values()
        |> map[Pair[String, TypedNode], String](|m|
            "    _ m__;" |> fmt(emit_type(m.second.type), "_", m.first)
        )
        |> join("\n")
}

// Given a path, an id, a list of argument names and types and a return type,
// returns the C code for the equivalent function signature declaration.
fun emit_func_signature(
    path: List[String], id: Int, 
    args: List[Pair[String, TypedNode]], ret: Option[TypedNode],
    source: Source
) -> String {
    val ret_t: Type = ret
        |> map[TypedNode, Type](|r| r.type)
        |> unwrap_or_else(|| Type(Variant::Unit, !IS_MUTABLE, source))
    val args_s: String 
        = args |> indices() 
        |> map[Int, String](|i| "_ param_" |> fmt(
            emit_type((args |> at(i)).second.type), 
            i |> as_string()
        ))
        |> join(", ")
    return "static _ _(_)" |> fmt(
        emit_type(ret_t), 
        mangle_path(path, id),
        args_s
    )
}

// Emits all declarations required for function bodies and global variable values
// from the given symbol table, including type definitions, function pre-declarations
// and global variable declarations.
pub fun emit_declarations(table: SymbolTable) -> String 
    = all_instances_of(table)
    |> map[Triplet[TypedNode, Int, List[Type]], String](|i| { match i.first.value {
        Structure(ast::CustomType(path, _, _, members)) {
            return "typedef struct {\n_\n} _;\n\n" |> fmt(
                emit_type_members(members),
                mangle_path(path, i.second)
            )
        }
        Enumeration(ast::CustomType(path, _, _, members)) {
            return "typedef struct {\n_ tag;\nunion {\n_\n} value;\n} _;\n\n" |> fmt(
                "uint32_t",
                emit_type_members(members),
                mangle_path(path, i.second)
            )
        }
        ast::Variant::Function(ast::Function(path, _, _, args, _, _, ret, _)) |
        ExternalFunction(ast::ExternalFunction(path, _, _, args, _, ret, _)) {
            return emit_func_signature(
                    path, i.second, args, ret, i.first.source
                ) 
                |> concat(";\n\n")
        }
        GlobalVariable(ast::GlobalVariable(path, _, _, type, _)) {
            return "static _ _;\n\n" |> fmt(
                emit_type(type.type),
                mangle_path(path, i.second)
            )
        }
        _ { return "" }
    } })
    |> join("")

// Emits an instruction responsible for increasing the reference count of the given
// value. If the given value does not have a reference count to be increased,
// an empty string is returned.
pub fun emit_rc_add(value: String, type: Type) -> String {
    match type.value {
        Unit | Integer | Float | Boolean { 
            return "" 
        }
        String | Function(_) {
            return "_((_).alloc);\n" |> fmt("quill_rc_add", value)
        }
        Struct(_) | Enum(_) | List(_) {
            return "_(_);\n" |> fmt("quill_rc_add", value)
        }
        Invalid {
            return panic("invalid type generated by type checker")
        }
    }
}

// Emits an instruction responsible for decreasing the reference count of the given
// value. If the given value does not have a reference count to be decreased,
// an empty string is returned.
pub fun emit_rc_dec(value: String, type: Type) -> String {
    match type.value {
        Unit | Integer | Float | Boolean { 
            return "" 
        }
        String | Function(_) {
            return "_((_).alloc);\n" |> fmt("quill_rc_dec", value)
        }
        Struct(_) | Enum(_) | List(_) {
            return "_(_);\n" |> fmt("quill_rc_dec", value)
        }
        Invalid {
            return panic("invalid type generated by type checker")
        }
    }
}

// Emits the default value for each respective type. This is important mostly
// for reference types, since RC calls may be done on uninitialized variables.
pub fun emit_default_value(type: Type) -> String {
    match type.value {
        Unit { return "QUILL_UNIT" }
        Integer { return "0" }
        Float { return "0.0" }
        Boolean { return "QUILL_FALSE" }
        String { return "QUILL_EMPTY_STRING" }
        Struct(_) { return "QUILL_NULL_STRUCT" }
        Enum(_) { return "QUILL_NULL_ENUM" }
        Function(_) { return "QUILL_NULL_CLOSURE" }
        List(_) { return "QUILL_NULL_LIST" }

        Invalid { return panic("invalid type generated by type checker") }
    }
}

// Emits the expression for creation of a capture of a given type.
pub fun emit_capture_value(type: Type) -> String {
    match type.value {
        Unit { return "QUILL_UNIT_CAPTURE" }
        Integer { return "QUILL_INT_CAPTURE" }
        Float { return "QUILL_FLOAT_CAPTURE" }
        Boolean { return "QUILL_BOOL_CAPTURE" }
        String { return "QUILL_STRING_CAPTURE" }
        Struct(_) { return "QUILL_STRUCT_CAPTURE" }
        Enum(_) { return "QUILL_ENUM_CAPTURE" }
        Function(_) { return "QUILL_CLOSURE_CAPTURE" }
        List(_) { return "QUILL_LIST_CAPTURE" }

        Invalid { return panic("invalid type generated by type checker") }
    }
}

// Emits free handlers required for struct and enum types.
// When the reference count of a structure, enum or closure reaches zero,
// before the buffer is deallocated, a function is invoked that decreases 
// all reference counts of contained references. The functions generated by
// this function are responsible for this.
pub fun emit_type_deconstructors(table: SymbolTable) -> String {
    val emit_decl: Fun(String, String) -> String
        = |path, body| "static __(_ *alloc) {\n_}\n\n"
            |> fmt(path, "_deconstruct", "quill_alloc_t", body)
    return all_instances_of(table)
        |> map[Triplet[TypedNode, Int, List[Type]], String](|i| { match i.first.value {
            Structure(ast::CustomType(path, _, _, members)) {
                val p: String = mangle_path(path, i.second)
                val body_start: String = "_ *m = (_ *) alloc->data;\n"
                    |> fmt(p, p)
                val body_mems: String = members 
                    |> values()
                    |> map[Pair[String, TypedNode], String](|m| emit_rc_dec(
                        "m->m_" |> concat(m.first), m.second.type
                    ))
                    |> join("")
                return emit_decl(p, body_start |> concat(body_mems))
            }
            Enumeration(ast::CustomType(path, _, _, members)) {
                val p: String = mangle_path(path, i.second)
                val body_start: String = "_ *m = (_ *) alloc->data;\n"
                    |> fmt(p, p)
                val branches: String = members
                    |> indices()
                    |> map[Int, String](|m_i| {
                        val m: Pair[String, TypedNode] = members |> at(m_i)
                        val d: String = emit_rc_dec(
                            "m->value.m_" |> concat(m.first), m.second.type
                        )
                        if 0 == (d |> length()) { return "" }
                        return "case _:\n_break;\n" 
                            |> fmt(m_i |> as_string(), d)
                    })
                    |> join("")
                val body: String = body_start 
                    |> concat("switch(m->tag) {\n")
                    |> concat(branches)
                    |> concat("}\n")
                return emit_decl(p, body)
            }
            _ { return "" }
        } })
        |> join("")
}

// Attempts to expand macros such as `#var(...)`, `#type(...)` and `#fun(...)`
// in the given external function body, returning the expanded result.
pub fun expand_external_body(
    og_body: String, 
    args: List[Pair[String, TypedNode]],
    t_args: mut Map[String, Type],
    context: ModuleContext,
    table: SymbolTable
) -> String {
    val expand_macro: Fun(String, String, Fun(String) -> String) -> String
    = |before_body, macro, f| {
        mut rem: String = before_body
        val repl: String 
            = Sequence::new[Int](|| rem |> find(macro) |> next())
            |> fold("", |repl, i| {
                val at: String = rem |> slice_from(i + (macro |> length()))
                val closing: Int = at |> find(")") |> next() 
                    |> expect("Unclosed macro in external function body")
                val before: String = rem |> slice_to(i)
                val inner: String = at |> slice_to(closing)
                rem = at |> slice_from(closing + 1)
                return repl |> concat(before) |> concat(f(inner))
            })
        return repl |> concat(rem)
    }
    return og_body
        |> expand_macro("#var(", |n| {
            val i: Int = args |> indices() 
                |> find(|i| (args |> at(i)).first == n)
                |> unwrap_or_else(
                    || "External function body used '#var' to reference '"
                    |> concat(n)
                    |> concat("', which is not a known argument")
                    |> panic()
                )
            return "param" |> concat(i |> as_string())
        })
        |> expand_macro("#type(", |t| {
            val sources: Map[String, String] 
                = Map::of(Pair("ext_macro.quill", t))
            val messages: mut List[Message] = List::empty()
            val tokens: mut Stream[token::Token] 
                = lexer::tokenize("ext_macro.quill", t, messages)
            val node: ast::UntypedNode = parser::Parser::from(tokens, messages) 
                |> parser::parse_type()
            val checker = checker::Checker(
                List::empty(), t_args, table, context, List::empty(),
                messages
            )
            val checked: TypedNode = checker
                |> checker::Checker::check_annotation(node)
            messages |> values() 
                |> map[Message, String](|m| m |> display(sources) |> concat("\n")) 
                |> for_each(println)
            if messages |> values() |> any(Message::is_error) {
                return panic("Error in macro in external function body")
            }
            return emit_type(checked.type)
        })
        |> expand_macro("#fun(", |f| {
            // TODO!
            return panic("not yet implemented")
        })
}

// Emits the full implementations of the functions in the given table.
pub fun emit_func_implementations(table: SymbolTable) -> String 
    = table.symbols |> values() |> map[Symbol, String](
        |s| s.instances |> values() |> map[Triplet[TypedNode, Int, List[Type]], String](
            |i| { match i.first.value {
                ast::Variant::Function(ast::Function(
                    path, _, _, args, _, args_captured, ret, body
                )) {
                    val signature: String = emit_func_signature(
                        path, i.second, args, ret, i.first.source
                    )
                    val ret_type: Type = ret
                        |> map[TypedNode, Type](|t| t.type)
                        |> unwrap_or_else(
                            || Type(Variant::Unit, !IS_MUTABLE, i.first.source)
                        )
                    val gen = Generator::new(table)
                    gen |> setup_return(ret_type)
                    args |> indices() |> for_each(|arg_i| {
                        val arg: Pair[String, TypedNode] = args |> at(arg_i)
                        val arg_t: Type = arg.second.type
                        val captured: Bool = (args_captured |> at(arg_i)).value
                        val n: String = gen 
                            |> alloc_named(arg.first, arg_t, captured)
                        val v: String = "param" |> concat(arg_i |> as_string())
                        gen |> assign_to(n, arg_t, v)
                    })
                    gen |> emit_statement_list(body)
                    return signature |> concat(" {\n")
                        |> concat(gen |> output())
                        |> concat("}\n\n")
                }
                ExternalFunction(ast::ExternalFunction(
                    path, _, t_arg_names, args, _, ret, body
                )) {
                    val signature: String = emit_func_signature(
                        path, i.second, args, ret, i.first.source
                    )
                    val t_args: mut Map[String, Type] = t_arg_names |> values()
                        |> zip(i.third |> values(), |n, t| Pair(n, t))
                        |> Map::collect()
                    val body_s: String = expand_external_body(
                        body, args, t_args, s.context, table
                    )
                    return signature |> concat(" {")
                        |> concat(body_s)
                        |> concat("}\n\n")
                }
                _ { return "" }
            } }
        ) |> join("")
    ) |> join("")

// Stores the state and context required for the emission of a single function.
pub struct Generator(
    start: String,
    body: String,
    end: String,
    locals: mut Map[String, String],
    next_local_id: mut Box[Int],
    table: SymbolTable
)

// Creates a new generator state from scratch.
pub fun Generator::new(table: SymbolTable) -> mut Generator
    = Generator(
        "", "", "",
        Map::empty(), Box(0), table
    )

// Creates a new generator in a new function inside the function of the 
// given exisiting generator. Local variables are copied, but, symbols and 
// local variable indices are shared with the parent scope.
pub fun Generator::under(existing: Generator) -> mut Generator
    = Generator(
        "", "", "", 
        existing.locals |> clone(), 
        existing.next_local_id, 
        existing.table
    )

// Inserts the given text in the beginning section of the generator scope.
// The beginning section is used to create and set up local variables.
pub fun Generator::at_start(self: mut Generator, s: String) {
    self.start = self.start |> concat(s)
}

// Inserts the given text in the body section of the generator scope.
// The body section is used to execute code.
pub fun Generator::in_body(self: mut Generator, s: String) {
    self.body = self.body |> concat(s)
}

// Inserts the given text at the end of the generator scope.
// The end section is ALWAYS invoked before returning from the function,
// making it cruical for the proper handling of reference counts of references.
pub fun Generator::at_end(self: mut Generator, s: String) {
    self.end = self.end |> concat(s)
}

// Set up a local variable in the scope that allows for returning of 
// a given type 't' in the same function later.
// This function should be used on every newly created generator.
pub fun Generator::setup_return(self: mut Generator, t: Type) {
    val v: String = "_ _ = _;\n" 
        |> fmt(emit_type(t), "ret_val", emit_default_value(t))
    self |> at_start(v)
}

// Allocates a new local variable with the given type in the generator scope,
// adding a definition at the start of the scope and RC handling at the end of it.
pub fun Generator::alloc(self: mut Generator, t: Type) -> String {
    val id: Int = self.next_local_id.value
    val name: String = "local" |> concat(id |> as_string())
    val v: String = emit_default_value(t)
    self |> at_start("_ _ = _;\n" |> fmt(emit_type(t), name, v))
    self |> at_end(emit_rc_dec(name, t))
    self.next_local_id.value = id + 1
    return name
}

// Allocates a named local variable with the given type and ability to be
// captured by closures.
// This adds the respective definition at the start of the scope
// and adds RC handling at the end of it.
// It also registers the respective alias in the generator.
// The function returns the operation needed to access the variable.
pub fun Generator::alloc_named(
    self: mut Generator, og_name: String, t: Type, captured: Bool
) -> String {
    val id: Int = self.next_local_id.value
    val name: String = "local" |> concat(id |> as_string())
    self.next_local_id.value = id + 1
    val v: String = emit_default_value(t)
    if captured {
        val cv: String = emit_capture_value(t)
        self |> at_start("_ _ = _;\n" |> fmt("quill_capture_t", name, cv))
        val r: String = "*((_ *) _->data)" |> fmt(emit_type(t), name)
        self |> at_start("_ = _;\n" |> fmt(r, v))
        self |> at_end("_(_);\n" |> fmt("quill_rc_dec", name))
        self.locals |> set(og_name, r)
        return r
    } else {
        self |> at_start("_ _ = _;\n" |> fmt(emit_type(t), name, v))
        self |> at_end(emit_rc_dec(name, t))
        self.locals |> set(og_name, name)
        return name
    }
}

// Emits code that writes the value prodived by 'value' to the location specified
// by 'dest', provided that the type of 'dest' matches the given type 't'.
// This function is mainly used for the automatic insertion of RC handling
// before and after the assignment, depending on the type of the variable.
// The code is emitted at the end of the body section of the generator.
// In the case that the given type requires RC handling, the string given for
// 'value' may be emitted more than once.
pub fun Generator::assign_to(
    self: mut Generator, dest: String, t: Type, value: String
) {
    self |> in_body(emit_rc_add(value, t))
    self |> in_body(emit_rc_dec(dest, t))
    self |> in_body("_ = _;\n" |> fmt(dest, value))
}

// Returns the output of the generator for the given function.
// This includes all generated code as well as a label for the code to go to
// when it wants to return (to invoke all code in the 'end' section) and to
// actually return.
pub fun Generator::output(self: Generator) -> String
    = self.start
    |> concat(self.body)
    |> concat("ret:;\n")
    |> concat(self.end)
    |> concat("return ret_val;\n")

// Emits a local statement as the equivalent C code.
pub fun emit_statement(gen: mut Generator, node: TypedNode) {
    match node.value {
        LocalVariable(ast::LocalVariable(name, _, captured, _, value)) {
            val r: String = gen |> alloc_named(name, value.type, captured.value)
            gen |> emit_expression(value, r)
        }
        Assignment(Pair(dest, value)) {
            val d: String = gen |> emit_assignable(dest)
            gen |> emit_expression(value, d)
        }
        Return(value) {
            // Assigning any value to 'ret_val' will cause it to be returned
            // after executing 'goto ret'. The RC of a reference in 'ret_val'
            // WILL NOT be decreased in the end section, which is what we want
            // (since we want to keep the reference allocation alive after returning).
            // The implementation of 'emit_expression' is responsible for
            // increasing the reference counting when assigning it to 'ret_val'
            // (ususally done via 'Generator::assign_to')
            gen |> emit_expression(value, "ret_val")
            gen |> in_body("goto ret;\n")
        }
        Continue {
            gen |> in_body("continue;\n")
        }
        Break {
            gen |> in_body("break;\n")
        }
        If(ast::If(cond, if_body, else_body)) {
            val cond_v: String = gen |> alloc(cond.type)
            gen |> emit_expression(cond, cond_v)
            gen |> in_body("if(")
            gen |> in_body(cond_v)
            gen |> in_body(") {\n")
            gen |> emit_statement_list(if_body)
            gen |> in_body("} else {\n")
            gen |> emit_statement_list(else_body)
            gen |> in_body("}\n")
        }
        While(ast::While(cond, body)) {
            val cond_v: String = gen |> alloc(cond.type)
            gen |> in_body("for(;;) {\n")
            gen |> emit_expression(cond, cond_v)
            gen |> in_body("if(!(")
            gen |> in_body(cond_v)
            gen |> in_body(")) { break; }\n")
            gen |> emit_statement_list(body)
            gen |> in_body("}\n")
        }
        For(_) {
            // TODO!   
        }
        Match(_) {
            // just abuse the ðŸ¦† out of 'goto'

            // TODO!
        }
        _ { 
            val into: String = gen |> alloc(node.type)
            gen |> emit_expression(node, into)
        }
    }
}

// Emits the entire given statement list as the equivalent C code, NOT including
// opening and closing braces.
pub fun emit_statement_list(gen: mut Generator, nodes: List[TypedNode])
    = nodes |> values() |> for_each(|n| gen |> emit_statement(n))

// Emits the equivalent lowered C code for the given expression.
pub fun emit_expression(gen: mut Generator, node: TypedNode, into: String) {
    match node.value {
        PathRef(_) |
        VariableRef(_) |
        Member(_) {
            val v: String = gen |> emit_assignable(node)
            gen |> assign_to(into, node.type, v)
        }
        FunctionRef(_) {

        }
        Int(i) {
            val v: String = i |> as_string()
            gen |> assign_to(into, node.type, v)
        }
        Float(f) {
            val v: String = f |> as_string()
            gen |> assign_to(into, node.type, v)
        }
        Bool(b) {
            val v: String = if b { "QUILL_TRUE" } else { "QUILL_FALSE" }
            gen |> assign_to(into, node.type, v)
        }
        Unit {
            // Default value of variables containing 'quill_unit_t' is already
            // 'QUILL_UNIT', so there is nothing more to do
        }
        String(_) {
            // TODO!
        }
        Closure(_) {
            // TODO!
        }
        Call(_) {
            //    DO NOT increase RCs of all arguments!
            // 1. decrease RC of into
            //     - cannot cause RC to drop to 0 because same reference,
            //       since the reference must have been passed to the function
            //       and the function increases the RC before returning
            // 2. call and manually (without 'assign_to') put result into 'into'
            //    since returning already increased the RC of the reference by 1

            // TODO!
        }
        NamedCall(ast::PathInvocation(path, args, t_n_args)) {
            val t_args: List[Type] = t_n_args
                |> unwrap_or(List::empty())
                |> values()
                |> map[TypedNode, Type](|t| t.type)
                |> List::collect()
            val instance: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(path, t_args, gen.table)
            val get_non_va_c: Fun() -> Int = || { match instance.first.value {
                Function(ast::Function(_, _, _, a, va, _, _, _)) |
                ExternalFunction(ast::ExternalFunction(_, _, _, a, va, _, _)) {
                    val arg_c: Int = a |> length()
                    return if va { arg_c - 1 } else { arg_c }
                }
                _ { return panic("called non-function with 'NamedCall'") }
            } }
            val non_va_c: Int = get_non_va_c()
            val i: String = mangle_path(path, instance.second)
            val emit_arg: Fun(TypedNode) -> String = |arg| {
                val a: String = gen |> alloc(arg.type)
                gen |> emit_expression(arg, a)
                return a
            }
            val non_va_args_s: String = args
                |> values()
                |> take(non_va_c)
                |> map(emit_arg)
                |> join(", ")
            val va_args: List[String] = args
                |> values()
                |> skip(non_va_c)
                |> map(emit_arg)
                |> List::collect()
            mut va_args_arr: String = ""
            if 0 != (va_args |> length()) {
                // TODO!
            }
            gen |> in_body(emit_rc_dec(into, node.type))
            gen |> in_body("_ = _(__);\n" 
                |> fmt(into, i, non_va_args_s, va_args_arr)
            )
        }
        StructInit(ast::PathInvocation(path, args, t_n_args)) {
            val t_args: List[Type] = t_n_args
                |> unwrap_or(List::empty())
                |> values()
                |> map[TypedNode, Type](|t| t.type)
                |> List::collect()
            val instance: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(path, t_args, gen.table)
            val get_members: Fun() -> List[String] = || { match instance.first.value {
                Structure(ast::CustomType(_, _, _, mems)) {
                    return mems |> values() 
                        |> map[Pair[String, TypedNode], String](|m| m.first)
                        |> List::collect()
                }
                _ { return panic("initialized non-struct with 'StructInit'") }
            } }
            val layout: String = mangle_path(path, instance.second)
            val r: String = gen |> alloc(node.type)
            gen |> in_body("_ = _(sizeof(_), &__);\n"
                |> fmt(r, "quill_malloc", layout, layout, "_deconstruct")
            )
            val member_names: List[String] = get_members()
            args |> indices() |> for_each(|arg_i| {
                val arg: TypedNode = args |> at(arg_i)
                val arg_into: String = "((_ *) _->data)->m__" 
                    |> fmt(layout, r, "_", member_names |> at(arg_i))
                gen |> emit_expression(arg, arg_into)
            })
            // We don't want to use 'assign_to' here since it increases
            // the reference count of whatever we assign. 
            // On creation, 'quill_malloc' returns an allocation with RC=1,
            // so we only want to decrease the RC of whatever is replaced.
            gen |> in_body(emit_rc_dec(into, node.type))
            gen |> in_body("_ = _;\n" |> fmt(into, r))
        }
        EnumInit(_) {
            // 1. increase RCs of values
            // 2. decrease RC of into
            // 3. allocate new object, put values and put into 'into' (without 'assign_to')

            // TODO!
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c: String = gen |> alloc(cond.type)
            gen |> emit_expression(cond, c)
            gen |> in_body("if(")
            gen |> in_body(c)
            gen |> in_body(") {\n")
            gen |> emit_expression(if_val, into)
            gen |> in_body("} else {\n")
            gen |> emit_expression(else_val, into)
            gen |> in_body("}\n")
        }
        _ {
            return "encountered unexpected AST node: "
                |> concat(node |> as_string())
                |> panic() 
        }
    }
}

// Emits an assignable expression as a direct reference which can be used
// as the value for 'into' in 'emit_expression'.
pub fun emit_assignable(gen: mut Generator, node: TypedNode) -> String {
    match node.value {
        PathRef(ast::PathRef(path, o_t_args)) {
            val t_args: List[Type] = o_t_args
                |> unwrap_or(List::empty())
                |> values()
                |> map[TypedNode, Type](|t| t.type)
                |> List::collect()
            val i: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(path, t_args, gen.table)
            return mangle_path(path, i.second)
        }
        VariableRef(name) {
            return gen.locals |> get(name) 
                |> expect("checker produced reference to unknown variable")
        }
        Member(Pair(accessed, name)) {
            match accessed.type.value {
                Struct(Pair(s_path, s_t_args)) {
                    val a: String = gen |> alloc(accessed.type)
                    gen |> emit_expression(accessed, a)
                    val i: Triplet[TypedNode, Int, List[Type]] 
                        = find_instance_with(s_path, s_t_args, gen.table)
                    val layout: String = mangle_path(s_path, i.second)
                    return "((_ *) _->data)->m_"
                        |> fmt(layout, a)
                        |> concat(name)
                }
                _ { return panic("attempt to access non-struct") }
            }

        }
        _ { return panic("assignment to non-assignable expression") }
    }
}

// Emits all symbols defined by the given symbol table as a complete C file
// dependent on the Quill C runtime.
pub fun emit(table: SymbolTable, main: List[String]) -> String {
    // 1. struct / enum layouts,
    //    (external?) function pre-declarations,
    //    global variable declarations,
    //    closure capture data layouts
    // 2. struct / enum free handler implementations,
    //    closure capture free handlers
    // 3. (external?) function implementations
    // 4. global variable initialization function
    // 5. main function (calls globals init and quill main)
    return HEADER
        |> concat(emit_declarations(table))
        |> concat(emit_type_deconstructors(table))
        |> concat(emit_func_implementations(table))
}