
mod quill::codegen::c

use quill::*
use quill::types::*
use quill::codegen::*

pub val HEADER: String = "
// C code generated from Quill source code by the Quill compiler
// https://github.com/schwalbe-t/quill

#include <quill.h>

"

// Returns a list of all instances of all symbols in the given symbol table.
fun all_instances_of(table: SymbolTable) -> mut Sequence[Triplet[TypedNode, Int, List[Type]]]
    = table.symbols 
    |> values() 
    |> map[Symbol, mut Sequence[Triplet[TypedNode, Int, List[Type]]]](
        |s| s.instances |> values()
    )
    |> flatten()

// Turns a Quill path and instance id into a valid C symbol name.
// This function makes sure that the same combination of path and id will always
// result in the same, unique name.
pub fun mangle_path(path: List[String], id: Int) -> String
    = path |> values()
    |> map[String, String](|s| s |> replace("_", "__"))
    |> join("_")
    |> concat("_")
    |> concat(id |> as_string())

// Looks up the id and typed node of the symbol instance with the given type arguments
// from the symbol with the given path from the given symbol table.
pub fun find_instance_with(
    path: List[String], t_args: List[Type], table: SymbolTable
) -> Triplet[TypedNode, Int, List[Type]] {
    val s: Symbol = table.symbols |> get(path) 
        |> expect("unknown path should've been rejected during checking")
    val i: SymbolInstance = SymbolInstance(path, t_args)
    return s.instances |> get(i |> key())
        |> unwrap_or_else(|| "instance _[_] should've been instantiated during checking"
            |> fmt(
                path |> values() |> join("::"),
                t_args |> values() |> map(Type::as_string) |> join(", ")
            )
            |> panic()
        )
}

// Turns a Quill type into a valid C type name.
pub fun emit_type(t: Type) -> String {
    match t.value {
        Unit { return "quill_unit_t" }
        Integer { return "quill_int_t" }
        Float { return "quill_float_t" }
        Boolean { return "quill_bool_t" }
        String { return "quill_string_t" }
        Struct(_) { return "quill_struct_t" }
        Enum(_) { return "quill_enum_t" }
        Function(_) { return "quill_closure_t" }
        List(_) { return "quill_list_t" }
        
        Invalid { return panic("invalid type generated by type checker (in 'emit_type')") }
    }
}

// Given a list of member names and types, returns the C code for the body
// of the equivalent type definition.
fun emit_type_members(members: List[Pair[String, TypedNode]]) -> String {
    if 0 == (members |> length()) { return "    quill_unit_t empty;" }
    return members 
        |> values()
        |> map[Pair[String, TypedNode], String](|m|
            "    _ m__;" |> fmt(emit_type(m.second.type), "_", m.first)
        )
        |> join("\n")
}

// Given a path, an id, a list of argument names and types and a return type,
// returns the C code for the equivalent function signature declaration.
fun emit_func_signature(
    path: List[String], id: Int, 
    args: List[Pair[String, TypedNode]], ret: Option[TypedNode],
    source: Source
) -> String {
    val ret_t: Type = ret
        |> map[TypedNode, Type](|r| r.type)
        |> unwrap_or_else(|| Type(Variant::Unit, !IS_MUTABLE, source))
    val args_s: String 
        = args |> indices() 
        |> map[Int, String](|i| "_ param_" |> fmt(
            emit_type((args |> at(i)).second.type), 
            i |> as_string()
        ))
        |> join(", ")
    return "static _ _(_)" |> fmt(
        emit_type(ret_t), 
        mangle_path(path, id),
        args_s
    )
}

// Emits all declarations required for function bodies and global variable values
// from the given symbol table, including type definitions, function pre-declarations
// and global variable declarations.
pub fun emit_declarations(table: SymbolTable) -> String 
    = all_instances_of(table)
    |> map[Triplet[TypedNode, Int, List[Type]], String](|i| { match i.first.value {
        Structure(ast::CustomType(path, _, _, members)) {
            return "typedef struct {\n_\n} _;\n\n" |> fmt(
                emit_type_members(members),
                mangle_path(path, i.second)
            )
        }
        Enumeration(ast::CustomType(path, _, _, members)) {
            return "typedef struct {\n_ tag;\nunion {\n_\n} value;\n} _;\n\n" |> fmt(
                "uint32_t",
                emit_type_members(members),
                mangle_path(path, i.second)
            )
        }
        ast::Variant::Function(ast::Function(path, _, _, args, _, _, ret, _)) |
        ExternalFunction(ast::ExternalFunction(path, _, _, args, _, ret, _)) {
            return emit_func_signature(
                    path, i.second, args, ret, i.first.source
                ) 
                |> concat(";\n\n")
        }
        GlobalVariable(ast::GlobalVariable(path, _, _, type, _)) {
            return "static _ _;\n\n" |> fmt(
                emit_type(type.type),
                mangle_path(path, i.second)
            )
        }
        _ { return "" }
    } })
    |> join("")

// Emits an instruction responsible for increasing the reference count of the given
// value. If the given value does not have a reference count to be increased,
// an empty string is returned.
pub fun emit_rc_add(value: String, type: Type) -> String {
    match type.value {
        Unit | Integer | Float | Boolean { 
            return "" 
        }
        String | Function(_) {
            return "_((_).alloc);\n" |> fmt("quill_rc_add", value)
        }
        Struct(_) | Enum(_) | List(_) {
            return "_(_);\n" |> fmt("quill_rc_add", value)
        }
        Invalid {
            return panic("invalid type generated by type checker (in 'emit_rc_add')")
        }
    }
}

// Emits an instruction responsible for decreasing the reference count of the given
// value. If the given value does not have a reference count to be decreased,
// an empty string is returned.
pub fun emit_rc_dec(value: String, type: Type) -> String {
    match type.value {
        Unit | Integer | Float | Boolean { 
            return "" 
        }
        String | Function(_) {
            return "_((_).alloc);\n" |> fmt("quill_rc_dec", value)
        }
        Struct(_) | Enum(_) | List(_) {
            return "_(_);\n" |> fmt("quill_rc_dec", value)
        }
        Invalid {
            return panic("invalid type generated by type checker (in 'emit_rc_dec')")
        }
    }
}

// Emits the default value for each respective type. This is important mostly
// for reference types, since RC calls may be done on uninitialized variables.
pub fun emit_default_value(type: Type) -> String {
    match type.value {
        Unit { return "QUILL_UNIT" }
        Integer { return "0" }
        Float { return "0.0" }
        Boolean { return "QUILL_FALSE" }
        String { return "QUILL_EMPTY_STRING" }
        Struct(_) { return "QUILL_NULL_STRUCT" }
        Enum(_) { return "QUILL_NULL_ENUM" }
        Function(_) { return "QUILL_NULL_CLOSURE" }
        List(_) { return "QUILL_NULL_LIST" }

        Invalid { return panic("invalid type generated by type checker (in 'emit_default_value')") }
    }
}

// Emits the expression for creation of a capture of a given type.
pub fun emit_capture_value(type: Type) -> String {
    match type.value {
        Unit { return "QUILL_UNIT_CAPTURE" }
        Integer { return "QUILL_INT_CAPTURE" }
        Float { return "QUILL_FLOAT_CAPTURE" }
        Boolean { return "QUILL_BOOL_CAPTURE" }
        String { return "QUILL_STRING_CAPTURE" }
        Struct(_) { return "QUILL_STRUCT_CAPTURE" }
        Enum(_) { return "QUILL_ENUM_CAPTURE" }
        Function(_) { return "QUILL_CLOSURE_CAPTURE" }
        List(_) { return "QUILL_LIST_CAPTURE" }

        Invalid { return panic("invalid type generated by type checker (in 'emit_capture_value')") }
    }
}

// Emits free handlers required for struct and enum types.
// When the reference count of a structure, enum or closure reaches zero,
// before the buffer is deallocated, a function is invoked that decreases 
// all reference counts of contained references. The functions generated by
// this function are responsible for this.
pub fun emit_type_destructors(table: SymbolTable) -> String {
    val emit_decl: Fun(String, String) -> String
        = |path, body| "static __(_ *alloc) {\n_}\n\n"
            |> fmt(path, "_destruct", "quill_alloc_t", body)
    return all_instances_of(table)
        |> map[Triplet[TypedNode, Int, List[Type]], String](|i| { match i.first.value {
            Structure(ast::CustomType(path, _, _, members)) {
                val p: String = mangle_path(path, i.second)
                val body_start: String = "_ *m = (_ *) alloc->data;\n"
                    |> fmt(p, p)
                val body_mems: String = members 
                    |> values()
                    |> map[Pair[String, TypedNode], String](|m| emit_rc_dec(
                        "m->m_" |> concat(m.first), m.second.type
                    ))
                    |> join("")
                return emit_decl(p, body_start |> concat(body_mems))
            }
            Enumeration(ast::CustomType(path, _, _, members)) {
                val p: String = mangle_path(path, i.second)
                val body_start: String = "_ *m = (_ *) alloc->data;\n"
                    |> fmt(p, p)
                val branches: String = members
                    |> indices()
                    |> map[Int, String](|m_i| {
                        val m: Pair[String, TypedNode] = members |> at(m_i)
                        val d: String = emit_rc_dec(
                            "m->value.m_" |> concat(m.first), m.second.type
                        )
                        if 0 == (d |> length()) { return "" }
                        return "case _:\n_break;\n" 
                            |> fmt(m_i |> as_string(), d)
                    })
                    |> join("")
                val body: String = body_start 
                    |> concat("switch(m->tag) {\n")
                    |> concat(branches)
                    |> concat("}\n")
                return emit_decl(p, body)
            }
            _ { return "" }
        } })
        |> join("")
}

// Attempts to expand macros such as `#var(...)`, `#type(...)` and `#fun(...)`
// in the given external function body, returning the expanded result.
pub fun expand_external_body(
    og_body: String, 
    args: List[Pair[String, TypedNode]],
    t_args: mut Map[String, Type],
    context: ModuleContext,
    table: SymbolTable
) -> String {
    return og_body
        |> pragma::expand_all("var", |n| {
            val i: Int = args |> indices() 
                |> find(|i| (args |> at(i)).first == n)
                |> unwrap_or_else(
                    || "External function body used '#var' to reference '"
                    |> concat(n)
                    |> concat("', which is not a known argument")
                    |> panic()
                )
            return "param" |> concat(i |> as_string())
        })
        |> pragma::expand_all("type", |t| {
            val pt: Option[Type] = pragma::parse_operand_type(
                t, t_args, context, table, List::empty(), Option::None
            )
            return pt
                |> map(emit_type)
                |> unwrap_or("INVALID")
        })
        |> pragma::expand_all("rc_add", |t| {
            val pt: Option[Type] = pragma::parse_operand_type(
                t, t_args, context, table, List::empty(), Option::None
            )
            match pt {
                None { return "INVALID" }
                Some(type) { match type.value {
                    Unit { return "quill_unit_rc_add" }
                    Integer { return "quill_int_rc_add" }
                    Float { return "quill_float_rc_add" }
                    Boolean { return "quill_bool_rc_add" }
                    String { return "quill_string_rc_add" }
                    Struct(_) | Enum(_) | List(_) { return "quill_rc_add" }
                    Function(_) { return "quill_closure_rc_add" }

                    Invalid {
                        return panic("invalid type generated by type checker (in 'rc_add' macro)")
                    }
                } }
            }
        })
        |> pragma::expand_all("rc_dec", |t| {
            val pt: Option[Type] = pragma::parse_operand_type(
                t, t_args, context, table, List::empty(), Option::None
            )
            match pt {
                None { return "INVALID" }
                Some(type) { match type.value {
                    Unit { return "quill_unit_rc_dec" }
                    Integer { return "quill_int_rc_dec" }
                    Float { return "quill_float_rc_dec" }
                    Boolean { return "quill_bool_rc_dec" }
                    String { return "quill_string_rc_dec" }
                    Struct(_) | Enum(_) | List(_) { return "quill_rc_dec" }
                    Function(_) { return "quill_closure_rc_dec" }

                    Invalid {
                        return panic("invalid type generated by type checker (in 'rc_dec' macro)")
                    }
                } }
            }
        })
        |> pragma::expand_all("fun", |f| {
            val i: Option[SymbolInstance] = pragma::parse_operand_symbol_ref(
                f, t_args, context, table, List::empty(), Option::None
            )
            match i {
                None { return "INVALID" }
                Some(inst) {
                    val inst_info: Triplet[TypedNode, Int, List[Type]] 
                        = find_instance_with(inst.path, inst.type_args, table)
                    return mangle_path(inst.path, inst_info.second)
                }
            }
        })
}

// Emits the full implementations of the functions in the given table.
pub fun emit_func_implementations(g: mut Generator) -> String 
    = g.table.symbols |> values() |> map[Symbol, String](
        |s| s.instances |> values() |> map[Triplet[TypedNode, Int, List[Type]], String](
            |i| { match i.first.value {
                ast::Variant::Function(ast::Function(
                    path, _, _, args, _, args_captured, ret, body
                )) {
                    val signature: String = emit_func_signature(
                        path, i.second, args, ret, i.first.source
                    )
                    val ret_type: Type = ret
                        |> map[TypedNode, Type](|t| t.type)
                        |> unwrap_or_else(
                            || Type(Variant::Unit, !IS_MUTABLE, i.first.source)
                        )
                    val gen = Generator::under(g)
                    gen |> setup_return(ret_type)
                    args |> indices() |> for_each(|arg_i| {
                        val arg: Pair[String, TypedNode] = args |> at(arg_i)
                        val arg_t: Type = arg.second.type
                        val captured: Bool = (args_captured |> at(arg_i)).value
                        val n: String = gen 
                            |> alloc_named(arg.first, arg_t, captured)
                        val v: String = "param" |> concat(arg_i |> as_string())
                        gen |> assign_to(n, arg_t, v)
                    })
                    gen |> emit_statement_list(body)
                    return signature |> concat(" {\n")
                        |> concat(gen |> output())
                        |> concat("}\n\n")
                }
                ExternalFunction(ast::ExternalFunction(
                    path, _, t_arg_names, args, _, ret, body
                )) {
                    val signature: String = emit_func_signature(
                        path, i.second, args, ret, i.first.source
                    )
                    val t_args: mut Map[String, Type] = t_arg_names |> values()
                        |> zip(i.third |> values(), |n, t| Pair(n, t))
                        |> Map::collect()
                    val body_s: String = expand_external_body(
                        body, args, t_args, s.context, g.table
                    )
                    return signature |> concat(" {")
                        |> concat(body_s)
                        |> concat("}\n\n")
                }
                _ { return "" }
            } }
        ) |> join("")
    ) |> join("")

// Emits a singular global variable and all of its dependencies.
fun emit_global(
    path: List[String], 
    emitted: mut Set[List[String]], 
    g: mut Generator,
    out: mut Box[String]
) {
    if emitted |> has(path) { return unit }
    val instance: Triplet[TypedNode, Int, List[Type]] 
        = find_instance_with(path, List::empty(), g.table)
    match instance.first.value {
        GlobalVariable(ast::GlobalVariable(
            _, _, _, _, value, var_deps
        )) {
            var_deps |> values() |> for_each(|dep| {
                emit_global(dep, emitted, g, out)
            })
            if emitted |> has(path) {
                // TODO! better error
                return panic("cyclic reference in global variables detected")
            }
            val gen = Generator::under(g)
            val dest: String = mangle_path(path, instance.second)
            gen |> emit_expression(value, dest)
            out.value = out.value
                |> concat(gen.start)
                |> concat(gen.body)
                |> concat(gen.end)
        }
        _ {
            return panic("called 'emit_global' on non-global path")
        }
    }

}

// Emits a function with the given name that initializes all global variables 
// in the given table.
pub fun emit_global_inits(g: mut Generator, f_name: String) -> String {
    val content = Box("")
    val emitted: mut Set[List[String]] = Set::empty()
    g.table.symbols |> values() |> for_each(
        |s| s.instances |> values() |> for_each(
            |i| { match i.first.value {
                GlobalVariable(ast::GlobalVariable(path, _, _, _, _, _)) {
                    emit_global(path, emitted, g, content)
                }
                _ {}
            } }
        )
    )
    return "static void _(void) {\n" |> fmt(f_name)
        |> concat(content.value)
        |> concat("}\n\n")
}

// Stores the state and context required for the emission of a single function.
pub struct Generator(
    start: String,
    body: String,
    end: String,
    locals: mut Map[String, String],
    locals_capt: mut Map[String, String],
    table: SymbolTable,
    next_local_id: mut Box[Int],
    closure_bodies: mut Box[String],
    next_closure_id: mut Box[Int],
    closure_destr: mut Map[Int, String]
)

// Creates a new generator state from scratch.
pub fun Generator::new(table: SymbolTable) -> mut Generator
    = Generator(
        "", "", "",
        Map::empty(), Map::empty(), 
        table,
        Box(0), Box(""), Box(0), Map::empty()
    )

// Creates a new generator in a new function inside the function of the 
// given exisiting generator. Symbols and 
// local variable indices are shared with the parent scope.
pub fun Generator::under(existing: Generator) -> mut Generator
    = Generator(
        "", "", "", 
        Map::empty(), Map::empty(),
        existing.table,
        existing.next_local_id, existing.closure_bodies, 
        existing.next_closure_id, existing.closure_destr
    )

// Inserts the given text in the beginning section of the generator scope.
// The beginning section is used to create and set up local variables.
pub fun Generator::at_start(self: mut Generator, s: String) {
    self.start = self.start |> concat(s)
}

// Inserts the given text in the body section of the generator scope.
// The body section is used to execute code.
pub fun Generator::in_body(self: mut Generator, s: String) {
    self.body = self.body |> concat(s)
}

// Inserts the given text at the end of the generator scope.
// The end section is ALWAYS invoked before returning from the function,
// making it cruical for the proper handling of reference counts of references.
pub fun Generator::at_end(self: mut Generator, s: String) {
    self.end = self.end |> concat(s)
}

// Set up a local variable in the scope that allows for returning of 
// a given type 't' in the same function later.
// This function should be used on every newly created generator.
pub fun Generator::setup_return(self: mut Generator, t: Type) {
    val v: String = "_ _ = _;\n" 
        |> fmt(emit_type(t), "ret_val", emit_default_value(t))
    self |> at_start(v)
}

// Allocates a new local variable with the given type in the generator scope,
// adding a definition at the start of the scope and RC handling at the end of it.
pub fun Generator::alloc(self: mut Generator, t: Type) -> String {
    val id: Int = self.next_local_id.value
    val name: String = "local" |> concat(id |> as_string())
    val v: String = emit_default_value(t)
    self |> at_start("_ _ = _;\n" |> fmt(emit_type(t), name, v))
    self |> at_end(emit_rc_dec(name, t))
    self.next_local_id.value = id + 1
    return name
}

// Allocates a named local variable with the given type and ability to be
// captured by closures.
// This adds the respective definition at the start of the scope
// and adds RC handling at the end of it.
// It also registers the respective alias in the generator.
// The function returns the operation needed to access the variable.
pub fun Generator::alloc_named(
    self: mut Generator, og_name: String, t: Type, captured: Bool
) -> String {
    val id: Int = self.next_local_id.value
    val name: String = "local" |> concat(id |> as_string())
    self.next_local_id.value = id + 1
    val v: String = emit_default_value(t)
    if captured {
        val cv: String = emit_capture_value(t)
        self |> at_start("_ _ = _;\n" |> fmt("quill_capture_t", name, cv))
        val r: String = "(*((_ *) _->data))" |> fmt(emit_type(t), name)
        self |> at_start("_ = _;\n" |> fmt(r, v))
        self |> at_end("_(_);\n" |> fmt("quill_rc_dec", name))
        self.locals |> set(og_name, r)
        self.locals_capt |> set(og_name, name)
        return r
    } else {
        self |> at_start("_ _ = _;\n" |> fmt(emit_type(t), name, v))
        self |> at_end(emit_rc_dec(name, t))
        self.locals |> set(og_name, name)
        return name
    }
}

// Emits code that writes the value prodived by 'value' to the location specified
// by 'dest', provided that the type of 'dest' matches the given type 't'.
// This function is mainly used for the automatic insertion of RC handling
// before and after the assignment, depending on the type of the variable.
// The code is emitted at the end of the body section of the generator.
// In the case that the given type requires RC handling, the string given for
// 'value' may be emitted more than once.
pub fun Generator::assign_to(
    self: mut Generator, dest: String, t: Type, value: String
) {
    self |> in_body(emit_rc_add(value, t))
    self |> in_body(emit_rc_dec(dest, t))
    self |> in_body("_ = _;\n" |> fmt(dest, value))
}

// Returns the output of the generator for the given function.
// This includes all generated code as well as a label for the code to go to
// when it wants to return (to invoke all code in the 'end' section) and to
// actually return.
pub fun Generator::output(self: Generator) -> String
    = self.start
    |> concat(self.body)
    |> concat("ret:;\n")
    |> concat(self.end)
    |> concat("return ret_val;\n")

// Emits a local statement as the equivalent C code.
pub fun emit_statement(gen: mut Generator, node: TypedNode) {
    match node.value {
        LocalVariable(ast::LocalVariable(name, _, captured, _, value)) {
            val r: String = gen |> alloc_named(name, value.type, captured.value)
            gen |> emit_expression(value, r)
        }
        Assignment(Pair(dest, value)) {
            val d: String = gen |> emit_assignable(dest)
            gen |> emit_expression(value, d)
        }
        Return(value) {
            // Assigning any value to 'ret_val' will cause it to be returned
            // after executing 'goto ret'. The RC of a reference in 'ret_val'
            // WILL NOT be decreased in the end section, which is what we want
            // (since we want to keep the reference allocation alive after returning).
            // The implementation of 'emit_expression' is responsible for
            // increasing the reference counting when assigning it to 'ret_val'
            // (ususally done via 'Generator::assign_to')
            gen |> emit_expression(value, "ret_val")
            gen |> in_body("goto ret;\n")
        }
        Continue {
            gen |> in_body("continue;\n")
        }
        Break {
            gen |> in_body("break;\n")
        }
        If(ast::If(cond, if_body, else_body)) {
            val cond_v: String = gen |> alloc(cond.type)
            gen |> emit_expression(cond, cond_v)
            gen |> in_body("if(")
            gen |> in_body(cond_v)
            gen |> in_body(") {\n")
            gen |> emit_statement_list(if_body)
            gen |> in_body("} else {\n")
            gen |> emit_statement_list(else_body)
            gen |> in_body("}\n")
        }
        While(ast::While(cond, body)) {
            val cond_v: String = gen |> alloc(cond.type)
            gen |> in_body("for(;;) {\n")
            gen |> emit_expression(cond, cond_v)
            gen |> in_body("if(!(")
            gen |> in_body(cond_v)
            gen |> in_body(")) { break; }\n")
            gen |> emit_statement_list(body)
            gen |> in_body("}\n")
        }
        For(ast::For(name, captured, in, body)) {
            val seq_path: List[String] = List::of("std", "Sequence")
            val opt_val_path: List[String] = List::of("std", "Option")
            val get_sequence_args: Fun() -> Option[List[Type]] = || { 
                match in.type.value {
                    Struct(Pair(seq_path, seq_t_args)) { 
                        return Option::Some(seq_t_args) 
                    }
                    _ { return Option::None }
                } 
            }
            val seq_t_args: List[Type] = get_sequence_args()
                |> expect("Attempt to use 'For' with a non-sequence")
            val seq_instance: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(seq_path, seq_t_args, gen.table)
            val seq_layout: String = mangle_path(seq_path, seq_instance.second)
            val opt_val_instance: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(opt_val_path, seq_t_args, gen.table)
            val opt_val_layout: String 
                = mangle_path(opt_val_path, opt_val_instance.second)
            val get_opt_member_idx: Fun(String) -> Int = |member| { 
                match opt_val_instance.first.value {
                    Enumeration(ast::CustomType(_, _, _, members)) {
                        return members 
                            |> indices() 
                            |> find(|i| (members |> at(i)).first == member)
                            |> expect("'std::Option' is missing a required member")
                    }
                    _ { return panic("'std::Option' must be an enum") }
                } 
            }
            val seq: String = gen |> alloc(in.type)
            gen |> emit_expression(in, seq)
            val seq_func: String = "((_ *) (_)->data)->m_"
                |> fmt(seq_layout, seq, "_next")
            gen |> in_body("for(;;) {\n")
            gen |> in_body("_ _ = _(_, _(_, _));\n" |> fmt(
                "quill_enum_t", "current_opt", "QUILL_CALL_CLOSURE_NA",
                seq_func, "QUILL_CLOSURE_FPTR_NA", seq_func, "quill_enum_t"
            ))
            gen |> in_body("if(((_ *) _->data)->tag != _) { break; }\n" |> fmt(
                opt_val_layout, "current_opt", 
                get_opt_member_idx("Some") |> as_string()
            ))
            val opt_val: String = "((_ *) _->data)->value.m_"
                |> fmt(opt_val_layout, "current_opt", "_Some")
            val current: String = gen 
                |> alloc_named(name, seq_t_args |> at(0), captured.value)
            gen |> assign_to(current, seq_t_args |> at(0), opt_val)
            gen |> in_body("quill_rc_dec(current_opt);\n")
            gen |> emit_statement_list(body)
            gen |> in_body("}\n")
        }
        Match(_) {
            // just abuse the 🦆 out of 'goto'

            // TODO!
        }
        Invalid { 
            println("encountered invalid AST node!")
            gen |> in_body("INVALID;\n")
        }
        _ {
            val into: String = gen |> alloc(node.type)
            gen |> emit_expression(node, into)
        }
    }
}

// Emits the entire given statement list as the equivalent C code, NOT including
// opening and closing braces.
pub fun emit_statement_list(gen: mut Generator, nodes: List[TypedNode])
    = nodes |> values() |> for_each(|n| gen |> emit_statement(n))

// Emits the equivalent lowered C code for the given expression.
pub fun emit_expression(gen: mut Generator, node: TypedNode, into: String) {
    val get_fun_signature: Fun(Type) -> Option[Pair[List[Type], Type]] = |t| { 
        match t.value {
            Function(f) { return Option::Some(f) }
            _ { return Option::None }
        } 
    }
    match node.value {
        PathRef(_) |
        VariableRef(_) |
        Member(_) {
            val v: String = gen |> emit_assignable(node)
            gen |> assign_to(into, node.type, v)
        }
        Int(i) {
            val v: String = i |> as_string()
            gen |> assign_to(into, node.type, v)
        }
        Float(f) {
            val v: String = f |> as_string()
            gen |> assign_to(into, node.type, v)
        }
        Bool(b) {
            val v: String = if b { "QUILL_TRUE" } else { "QUILL_FALSE" }
            gen |> assign_to(into, node.type, v)
        }
        Unit {
            // Default value of variables containing 'quill_unit_t' is already
            // 'QUILL_UNIT', so there is nothing more to do
        }
        String(content) {
            gen |> in_body(emit_rc_dec(into, node.type))
            gen |> in_body("_ = _((_ []) {_}, _);\n" |> fmt(
                into, 
                "quill_string_from_points", "uint32_t",
                content |> codes() |> map(Int::as_string) |> join(","),
                content |> codes() |> length() |> as_string()
            ))
        }
        Closure(ast::Closure(args, args_capt, capture_types, body)) {
            val captures: List[String] = capture_types
                |> keys()
                |> List::collect()
            val capture_c: Int = captures |> length()
            // define a destructor for the needed capture count if it doesn't exist
            if !(gen.closure_destr |> has(capture_c)) {
                val destr_impl_s: String = "static quill_unit_t quill_closure_"
                    |> concat(capture_c |> as_string())
                    |> concat("_destruct(quill_alloc_t *alloc) {\n")
                    |> concat("    quill_capture_t *captures")
                    |> concat(" = (quill_capture_t *) alloc->data;\n")
                val destr_impl_b: String = range(0, capture_c)
                    |> map[Int, String](|i| "    _(captures[_]);\n"
                        |> fmt("quill_rc_dec", i |> as_string())
                    )
                    |> join("")
                val destr_impl_e: String = "    return QUILL_UNIT;\n"
                    |> concat("}\n\n")
                val destr_impl = destr_impl_s 
                    |> concat(destr_impl_b) 
                    |> concat(destr_impl_e)
                gen.closure_destr |> set(capture_c, destr_impl)
            }
            // generate the body for the closure
            val signature: Pair[List[Type], Type] = get_fun_signature(node.type)
                |> expect("result type of 'Closure' must be a function type!")
            val body_args_s: String = args 
                |> indices()
                |> map[Int, String](|i| ", _ param_" |> fmt(
                    signature.first |> at(i) |> emit_type(),
                    i |> as_string()
                ))
                |> join("")
            val closure_id: Int = gen.next_closure_id.value
            gen.next_closure_id.value = closure_id + 1
            val body_signature_s: String = "static _ __(__)" |> fmt(
                signature.second |> emit_type(), 
                "quill_closure_", 
                closure_id |> as_string(),
                "quill_alloc_t *alloc",
                body_args_s
            )
            val body_gen = Generator::under(gen)
            body_gen |> setup_return(signature.second)
            captures |> indices() |> for_each(|capt_i| {
                val capt_n: String = captures |> at(capt_i)
                val capt_t: Type = capture_types |> get(capt_n)
                    |> expect("capture name came from the capture types map")
                body_gen.locals |> set(
                    capt_n, 
                    "*((_ *) captures[_]->data)"
                        |> fmt(emit_type(capt_t), capt_i |> as_string())
                )
                body_gen.locals_capt |> set(
                    capt_n, 
                    "captures[_]" 
                        |> fmt(capt_i |> as_string())
                )
            })
            args |> indices() |> for_each(|arg_i| {
                val arg_name: String = args |> at(arg_i)
                val arg_type: Type = signature.first |> at(arg_i)
                val arg_capt: Bool = (args_capt |> at(arg_i)).value
                val n: String = body_gen 
                    |> alloc_named(arg_name, arg_type, arg_capt)
                val v: String = "param" |> concat(arg_i |> as_string())
                body_gen |> assign_to(n, arg_type, v)
            })
            body_gen |> emit_statement_list(body)
            val body_s: String = body_signature_s |> concat(" {\n")
                |> concat("quill_capture_t *captures = (quill_capture_t *) alloc->data;\n")
                |> concat(body_gen |> output())
                |> concat("}\n\n")
            gen.closure_bodies.value = gen.closure_bodies.value
                |> concat(body_s)
            // create a value that references both generated functions
            // and represents the closure
            gen |> in_body(emit_rc_dec(into, node.type))
            gen |> in_body("_.body = (_) &__;\n" |> fmt(
                into, "quill_fptr_t", "quill_closure_", 
                closure_id |> as_string()
            ))
            gen |> in_body("_.alloc = _(sizeof(_) * _, &___);\n" |> fmt(
                into, "quill_malloc", "quill_capture_t", 
                capture_c |> as_string(),
                "quill_closure_", capture_c |> as_string(), "_destruct"
            ))
            captures |> indices() |> for_each(|capt_i| {
                val dest: String = "((_ *) _.alloc->data)[_]"
                    |> fmt("quill_capture_t", into, capt_i |> as_string())
                val capt_name: String = captures |> at(capt_i)
                val capt_type: Type = capture_types |> get(capt_name)
                    |> expect("capture name came from the capture types map")
                val value: String = gen.locals_capt |> get(capt_name) 
                    |> expect("checker produced capture of unknown variable")
                gen |> in_body("_(_);\n" |> fmt("quill_rc_add", value))
                gen |> in_body("_ = _;\n" |> fmt(dest, value))
            })
        }
        Call(ast::Invocation(invoked, args)) {
            val signature: Pair[List[Type], Type] 
                = get_fun_signature(invoked.type)
                |> expect("'invoked' of 'Call' must result in a function type")
            val called: String = gen |> alloc(invoked.type)
            gen |> emit_expression(invoked, called)
            val arg_t_s: String = signature.first
                |> values()
                |> map[Type, String](|t| ", " |> concat(emit_type(t)))
                |> join("")
            val args_s: String = args
                |> values()
                |> map[TypedNode, String](|arg| {
                    val v: String = gen |> alloc(arg.type)
                    gen |> emit_expression(arg, v)
                    return ", " |> concat(v)
                })
                |> join("")
            gen |> in_body(emit_rc_dec(into, node.type))
            gen |> in_body("_ = _(_, _(_, __)_);\n" |> fmt(
                into, 
                if 0 == (args |> length()) { "QUILL_CALL_CLOSURE_NA" }
                    else { "QUILL_CALL_CLOSURE" },
                called, 
                if 0 == (args |> length()) { "QUILL_CLOSURE_FPTR_NA" }
                    else { "QUILL_CLOSURE_FPTR" },
                called,
                emit_type(signature.second),
                arg_t_s,
                args_s
            ))
        }
        NamedCall(ast::PathInvocation(path, args, t_n_args)) {
            val t_args: List[Type] = t_n_args
                |> unwrap_or(List::empty())
                |> values()
                |> map[TypedNode, Type](|t| t.type)
                |> List::collect()
            val instance: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(path, t_args, gen.table)
            val called: String 
                = mangle_path(path, instance.second)
            val get_uses_va: Fun() -> Bool = || { match instance.first.value {
                Function(ast::Function(_, _, _, _, va, _, _, _)) |
                ExternalFunction(ast::ExternalFunction(_, _, _, _, va, _, _)) {
                    return va
                }
                _ { return false }
            } }
            val uses_va: Bool = get_uses_va()
            val get_non_va_c: Fun() -> Int = || { match instance.first.value {
                Function(ast::Function(_, _, _, a, va, _, _, _)) |
                ExternalFunction(ast::ExternalFunction(_, _, _, a, va, _, _)) {
                    val arg_c: Int = a |> length()
                    return if va { arg_c - 1 } else { arg_c }
                }
                _ { return panic("called non-function with 'NamedCall'") }
            } }
            val non_va_c: Int = get_non_va_c()
            val non_va_args_s: String = args
                |> values()
                |> take(non_va_c)
                |> map[TypedNode, String](|arg| {
                    val a: String = gen |> alloc(arg.type)
                    gen |> emit_expression(arg, a)
                    return a
                })
                |> join(", ")
            val va_c: Int = Int::max((args |> length()) - non_va_c, 0)
            mut va_args_arr: String = ""
            if uses_va {
                val get_va_elem_t: Fun() -> Type = || { match instance.first.value {
                    Function(ast::Function(_, _, _, a, _, _, _, _)) |
                    ExternalFunction(ast::ExternalFunction(_, _, _, a, _, _, _)) {
                        match (a |> at(-1)).second.type.value {
                            List(e) { return e }
                            _ { return panic("used non-list for varargs target") }
                        }
                    }
                    _ { return panic("called non-function with 'NamedCall'") }
                } }
                val va_elem_t: Type = get_va_elem_t()
                val va_list_t: Type = Type(
                    Variant::List(va_elem_t), IS_MUTABLE, node.source
                )
                val destruct_path: List[String] 
                    = List::of("std", "List", "destruct")
                val destruct_inst: Triplet[TypedNode, Int, List[Type]]
                    = find_instance_with(
                        destruct_path, List::of(va_elem_t), gen.table
                    )
                val destruct: String 
                    = mangle_path(destruct_path, destruct_inst.second)
                va_args_arr = gen |> alloc(va_list_t)
                gen |> in_body("_ = _(sizeof(_), &_);\n" |> fmt(
                    va_args_arr, "quill_malloc", "quill_list_layout_t", destruct
                ))
                val info: String = "((_ *) _->data)"
                    |> fmt("quill_list_layout_t", va_args_arr)
                gen |> in_body("_->buffer = malloc(sizeof(_) * _);\n" |> fmt(
                    info, emit_type(va_elem_t), va_c |> as_string()
                ))
                gen |> in_body("_->capacity = _;\n" |> fmt(
                    info, va_c |> as_string()
                ))
                gen |> in_body("_->length = _;\n" |> fmt(
                    info, va_c |> as_string()
                ))
                val values: String = "((_ *) _->buffer)"
                    |> fmt(emit_type(va_elem_t), info)
                range(0, va_c) |> for_each(|i| {
                    val arg: TypedNode = args |> at(non_va_c + i)
                    val dest: String = "_[_]" 
                        |> fmt(values, i |> as_string())
                    gen |> emit_expression(arg, dest)
                })
            }
            gen |> in_body(emit_rc_dec(into, node.type))
            gen |> in_body("_ = _(___);\n" |> fmt(
                into, called, 
                non_va_args_s, 
                if uses_va && non_va_c > 0 { ", " } else { "" },
                va_args_arr
            ))
        }
        StructInit(ast::PathInvocation(path, args, t_n_args)) {
            val t_args: List[Type] = t_n_args
                |> unwrap_or(List::empty())
                |> values()
                |> map[TypedNode, Type](|t| t.type)
                |> List::collect()
            val instance: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(path, t_args, gen.table)
            val get_members: Fun() -> List[String] = || { match instance.first.value {
                Structure(ast::CustomType(_, _, _, mems)) {
                    return mems |> values() 
                        |> map[Pair[String, TypedNode], String](|m| m.first)
                        |> List::collect()
                }
                _ { return panic("initialized non-struct with 'StructInit'") }
            } }
            val layout: String = mangle_path(path, instance.second)
            val r: String = gen |> alloc(node.type)
            gen |> in_body("_ = _(sizeof(_), &__);\n"
                |> fmt(r, "quill_malloc", layout, layout, "_destruct")
            )
            val member_names: List[String] = get_members()
            args |> indices() |> for_each(|arg_i| {
                val arg: TypedNode = args |> at(arg_i)
                val arg_into: String = "((_ *) _->data)->m__" 
                    |> fmt(layout, r, "_", member_names |> at(arg_i))
                gen |> emit_expression(arg, arg_into)
            })
            // We don't want to use 'assign_to' here since it increases
            // the reference count of whatever we assign. 
            // On creation, 'quill_malloc' returns an allocation with RC=1,
            // so we only want to decrease the RC of whatever is replaced.
            gen |> in_body(emit_rc_dec(into, node.type))
            gen |> in_body("_ = _;\n" |> fmt(into, r))
        }
        EnumInit(ast::PathInvocation(inv_path, args, t_n_args)) {
            val path = inv_path |> slice_to(-1)
            val name = inv_path |> at(-1)
            val t_args: List[Type] = t_n_args
                |> unwrap_or(List::empty())
                |> values()
                |> map[TypedNode, Type](|t| t.type)
                |> List::collect()
            val instance: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(path, t_args, gen.table)
            val get_members: Fun() -> List[String] = || { match instance.first.value {
                Enumeration(ast::CustomType(_, _, _, mems)) {
                    return mems |> values() 
                        |> map[Pair[String, TypedNode], String](|m| m.first)
                        |> List::collect()
                }
                _ { return panic("initialized non-enum with 'EnumInit'") }
            } }
            val layout: String = mangle_path(path, instance.second)
            val r: String = gen |> alloc(node.type)
            gen |> in_body("_ = _(sizeof(_), &__);\n"
                |> fmt(r, "quill_malloc", layout, layout, "_destruct")
            )
            val member_names: List[String] = get_members()
            val member_i: Int = member_names 
                |> indices()
                |> find(|i| (member_names |> at(i)) == name)
                |> expect("creation of unknown enum member")
            gen |> in_body("((_ *) _->data)->tag = _;\n"
                |> fmt(layout, r, member_i |> as_string())
            )
            val value: TypedNode = args |> at(0)
            val value_into: String = "((_ *) _->data)->value.m__"
                |> fmt(layout, r, "_", name)
            gen |> emit_expression(value, value_into)
            // We don't want to use 'assign_to' here since it increases
            // the reference count of whatever we assign. 
            // On creation, 'quill_malloc' returns an allocation with RC=1,
            // so we only want to decrease the RC of whatever is replaced.
            gen |> in_body(emit_rc_dec(into, node.type))
            gen |> in_body("_ = _;\n" |> fmt(into, r))
        }
        IfExpr(ast::IfExpr(cond, if_val, else_val)) {
            val c: String = gen |> alloc(cond.type)
            gen |> emit_expression(cond, c)
            gen |> in_body("if(")
            gen |> in_body(c)
            gen |> in_body(") {\n")
            gen |> emit_expression(if_val, into)
            gen |> in_body("} else {\n")
            gen |> emit_expression(else_val, into)
            gen |> in_body("}\n")
        }
        _ {
            "encountered invalid AST node! ("
                |> concat(node |> as_string())
                |> concat(")")
                |> println() 
            gen |> in_body("INVALID;\n")
        }
    }
}

// Emits an assignable expression as a direct reference which can be used
// as the value for 'into' in 'emit_expression'.
pub fun emit_assignable(gen: mut Generator, node: TypedNode) -> String {
    match node.value {
        PathRef(ast::PathRef(path, o_t_args)) {
            val t_args: List[Type] = o_t_args
                |> unwrap_or(List::empty())
                |> values()
                |> map[TypedNode, Type](|t| t.type)
                |> List::collect()
            val i: Triplet[TypedNode, Int, List[Type]] 
                = find_instance_with(path, t_args, gen.table)
            return mangle_path(path, i.second)
        }
        VariableRef(name) {
            return gen.locals |> get(name) 
                |> expect("checker produced reference to unknown variable")
        }
        Member(Pair(accessed, name)) {
            match accessed.type.value {
                Struct(Pair(s_path, s_t_args)) {
                    val a: String = gen |> alloc(accessed.type)
                    gen |> emit_expression(accessed, a)
                    val i: Triplet[TypedNode, Int, List[Type]] 
                        = find_instance_with(s_path, s_t_args, gen.table)
                    val layout: String = mangle_path(s_path, i.second)
                    return "((_ *) _->data)->m_"
                        |> fmt(layout, a)
                        |> concat(name)
                }
                _ { return panic("attempt to access non-struct") }
            }

        }
        _ { return panic("assignment to non-assignable expression") }
    }
}

// Emits all symbols defined by the given symbol table as a complete C file
// dependent on the Quill C runtime.
pub fun emit(table: SymbolTable, main: List[String]) -> String {
    // 1. struct / enum layouts,
    //    (external?) function pre-declarations,
    //    global variable declarations,
    //    closure capture data layouts
    // 2. struct / enum free handler implementations,
    //    closure capture free handlers
    // 3. (external?) function implementations
    // 4. global variable initialization function
    // 5. main function (calls globals init and quill main)

    val g = Generator::new(table)
    val func_decls: String = emit_func_implementations(g)
    val global_inits: String = emit_global_inits(g, "quill_init_globals")
    return HEADER
        |> concat(emit_declarations(table))
        |> concat(emit_type_destructors(table))
        |> concat(g.closure_destr |> values() |> join(""))
        |> concat(g.closure_bodies.value)
        |> concat(func_decls)
        |> concat(global_inits)
}