
mod quill::codegen::c

use quill::*
use quill::types::*

pub val HEADER: String = "
// C code generated from Quill source code by the Quill compiler
// https://github.com/schwalbe-t/quill

#include <quill.h>

"

// Returns a list of all instances of all symbols in the given symbol table.
fun all_instances_of(table: SymbolTable) -> mut Sequence[Pair[TypedNode, Int]]
    = table.symbols 
    |> values() 
    |> map[Symbol, mut Sequence[Pair[TypedNode, Int]]](
        |s| s.instances |> values()
    )
    |> flatten()

// Turns a Quill path and instance id into a valid C symbol name.
// This function makes sure that the same combination of path and id will always
// result in the same, unique name.
pub fun mangle_path(path: List[String], id: Int) -> String
    = path |> values()
    |> map[String, String](|s| s |> replace("_", "__"))
    |> join("_")
    |> concat("_")
    |> concat(id |> as_string())

// Looks up the id and typed node of the symbol instance with the given type arguments
// from the symbol with the given path from the given symbol table.
pub fun find_instance_with(
    path: List[String], t_args: List[Type], table: SymbolTable
) -> Pair[TypedNode, Int] {
    val s: Symbol = table.symbols |> get(path) 
        |> expect("unknown path should've been rejected during checking")
    val i: SymbolInstance = SymbolInstance(path, t_args)
    return s.instances |> get(i |> key())
        |> expect("instance should've been instantiated during checking")
}

// Turns a Quill type into a valid C type name.
pub fun emit_type(t: Type) -> String {
    match t.value {
        Unit { return "quill_unit_t" }
        Integer { return "quill_int_t" }
        Float { return "quill_float_t" }
        Boolean { return "quill_bool_t" }
        String { return "quill_string_t" }
        Struct(_) { return "quill_struct_t" }
        Enum(_) { return "quill_enum_t" }
        Function(_) { return "quill_closure_t" }
        List(_) { return "quill_list_t" }
        
        Invalid { return panic("invalid type generated by type checker") }
    }
}

// Given a list of member names and types, returns the C code for the body
// of the equivalent type definition.
fun emit_type_members(members: List[Pair[String, TypedNode]]) -> String {
    if members |> length() |> is(0) { return "    quill_unit_t empty;" }
    return members 
        |> values()
        |> map[Pair[String, TypedNode], String](|m|
            "    _ _;" |> fmt(emit_type(m.second.type), m.first)
        )
        |> join("\n")
}

// Given a path, an id, a list of argument names and types and a return type,
// returns the C code for the equivalent function signature declaration.
fun emit_func_declaration(
    path: List[String], id: Int, 
    args: List[Pair[String, TypedNode]], ret: Option[TypedNode],
    source: Source
) -> String {
    val ret_t: Type = ret
        |> map[TypedNode, Type](|r| r.type)
        |> unwrap_or_else(|| Type(Variant::Unit, !IS_MUTABLE, source))
    val args_s: String 
        = args |> indices() 
        |> map[Int, String](|i| "_ param_" |> fmt(
            emit_type((args |> at(i)).second.type), 
            i |> as_string()
        ))
        |> join(", ")
    return "static _ _(_)" |> fmt(
        emit_type(ret_t), 
        mangle_path(path, id),
        args_s
    )
}

// Emits all declarations required for function bodies and global variable values
// from the given symbol table, including type definitions, function pre-declarations
// and global variable declarations.
pub fun emit_declarations(table: SymbolTable) -> String 
    = all_instances_of(table)
    |> map[Pair[TypedNode, Int], String](|i| { match i.first.value {
        Structure(ast::CustomType(path, _, _, members)) {
            return "typedef struct {\n_\n} _;\n\n" |> fmt(
                emit_type_members(members),
                mangle_path(path, i.second)
            )
        }
        Enumeration(ast::CustomType(path, _, _, members)) {
            return "typedef union {\n_\n} _;\n\n" |> fmt(
                emit_type_members(members),
                mangle_path(path, i.second)
            )
        }
        ast::Variant::Function(ast::Function(path, _, _, args, _, ret, _)) |
        ExternalFunction(ast::ExternalFunction(path, _, _, args, _, ret, _)) {
            return emit_func_declaration(
                    path, i.second, args, ret, i.first.source
                ) 
                |> concat(";\n\n")
        }
        GlobalVariable(ast::GlobalVariable(path, _, _, type, _)) {
            return "static _ _;\n\n" |> fmt(
                emit_type(type.type),
                mangle_path(path, i.second)
            )
        }
        _ { return "" }
    } })
    |> join("")

// Emits all symbols defined by the given symbol table as a complete C file
// dependent on the Quill C runtime.
pub fun emit(table: SymbolTable, main: List[String]) -> String {
    // 1. struct / enum layouts,
    //    (external?) function pre-declarations,
    //    global variable declarations
    // 2. struct / enum free handler implementations
    // 3. (external?) function implementations
    // 4. global variable initialization function
    // 5. main function (calls globals init and quill main)
    return HEADER
        |> concat(emit_declarations(table))
}