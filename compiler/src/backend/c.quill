
mod quill::codegen::c

use quill::*
use quill::types::*

pub val HEADER: String = "
// C code generated from Quill source code by the Quill compiler
// https://github.com/schwalbe-t/quill

#include <quill.h>

"

// Returns a list of all instances of all symbols in the given symbol table.
fun all_instances_of(table: SymbolTable) -> mut Sequence[Triplet[TypedNode, Int, List[Type]]]
    = table.symbols 
    |> values() 
    |> map[Symbol, mut Sequence[Triplet[TypedNode, Int, List[Type]]]](
        |s| s.instances |> values()
    )
    |> flatten()

// Turns a Quill path and instance id into a valid C symbol name.
// This function makes sure that the same combination of path and id will always
// result in the same, unique name.
pub fun mangle_path(path: List[String], id: Int) -> String
    = path |> values()
    |> map[String, String](|s| s |> replace("_", "__"))
    |> join("_")
    |> concat("_")
    |> concat(id |> as_string())

// Looks up the id and typed node of the symbol instance with the given type arguments
// from the symbol with the given path from the given symbol table.
pub fun find_instance_with(
    path: List[String], t_args: List[Type], table: SymbolTable
) -> Triplet[TypedNode, Int, List[Type]] {
    val s: Symbol = table.symbols |> get(path) 
        |> expect("unknown path should've been rejected during checking")
    val i: SymbolInstance = SymbolInstance(path, t_args)
    return s.instances |> get(i |> key())
        |> expect("instance should've been instantiated during checking")
}

// Turns a Quill type into a valid C type name.
pub fun emit_type(t: Type) -> String {
    match t.value {
        Unit { return "quill_unit_t" }
        Integer { return "quill_int_t" }
        Float { return "quill_float_t" }
        Boolean { return "quill_bool_t" }
        String { return "quill_string_t" }
        Struct(_) { return "quill_struct_t" }
        Enum(_) { return "quill_enum_t" }
        Function(_) { return "quill_closure_t" }
        List(_) { return "quill_list_t" }
        
        Invalid { return panic("invalid type generated by type checker") }
    }
}

// Given a list of member names and types, returns the C code for the body
// of the equivalent type definition.
fun emit_type_members(members: List[Pair[String, TypedNode]]) -> String {
    if 0 == (members |> length()) { return "    quill_unit_t empty;" }
    return members 
        |> values()
        |> map[Pair[String, TypedNode], String](|m|
            "    _ m__;" |> fmt(emit_type(m.second.type), "_", m.first)
        )
        |> join("\n")
}

// Given a path, an id, a list of argument names and types and a return type,
// returns the C code for the equivalent function signature declaration.
fun emit_func_signature(
    path: List[String], id: Int, 
    args: List[Pair[String, TypedNode]], ret: Option[TypedNode],
    source: Source
) -> String {
    val ret_t: Type = ret
        |> map[TypedNode, Type](|r| r.type)
        |> unwrap_or_else(|| Type(Variant::Unit, !IS_MUTABLE, source))
    val args_s: String 
        = args |> indices() 
        |> map[Int, String](|i| "_ param_" |> fmt(
            emit_type((args |> at(i)).second.type), 
            i |> as_string()
        ))
        |> join(", ")
    return "static _ _(_)" |> fmt(
        emit_type(ret_t), 
        mangle_path(path, id),
        args_s
    )
}

// Emits all declarations required for function bodies and global variable values
// from the given symbol table, including type definitions, function pre-declarations
// and global variable declarations.
pub fun emit_declarations(table: SymbolTable) -> String 
    = all_instances_of(table)
    |> map[Triplet[TypedNode, Int, List[Type]], String](|i| { match i.first.value {
        Structure(ast::CustomType(path, _, _, members)) {
            return "typedef struct {\n_\n} _;\n\n" |> fmt(
                emit_type_members(members),
                mangle_path(path, i.second)
            )
        }
        Enumeration(ast::CustomType(path, _, _, members)) {
            return "typedef struct {\n_ tag;\nunion {\n_\n} value;\n} _;\n\n" |> fmt(
                "uint32_t",
                emit_type_members(members),
                mangle_path(path, i.second)
            )
        }
        ast::Variant::Function(ast::Function(path, _, _, args, _, ret, _)) |
        ExternalFunction(ast::ExternalFunction(path, _, _, args, _, ret, _)) {
            return emit_func_signature(
                    path, i.second, args, ret, i.first.source
                ) 
                |> concat(";\n\n")
        }
        GlobalVariable(ast::GlobalVariable(path, _, _, type, _)) {
            return "static _ _;\n\n" |> fmt(
                emit_type(type.type),
                mangle_path(path, i.second)
            )
        }
        _ { return "" }
    } })
    |> join("")

// Emits an instruction responsible for increasing the reference count of the given
// value. If the given value does not have a reference count to be increased,
// an empty string is returned.
pub fun emit_rc_add(value: String, type: Type) -> String {
    match type.value {
        Unit | Integer | Float | Boolean { 
            return "" 
        }
        String | Function(_) {
            return "_((_).alloc);\n" |> fmt("quill_rc_add", value)
        }
        Struct(_) | Enum(_) | List(_) {
            return "_(_);\n" |> fmt("quill_rc_add", value)
        }
        Invalid {
            return panic("invalid type generated by type checker")
        }
    }
}

// Emits an instruction responsible for decreasing the reference count of the given
// value. If the given value does not have a reference count to be decreased,
// an empty string is returned.
pub fun emit_rc_dec(value: String, type: Type) -> String {
    match type.value {
        Unit | Integer | Float | Boolean { 
            return "" 
        }
        String | Function(_) {
            return "_((_).alloc);\n" |> fmt("quill_rc_dec", value)
        }
        Struct(_) | Enum(_) | List(_) {
            return "_(_);\n" |> fmt("quill_rc_dec", value)
        }
        Invalid {
            return panic("invalid type generated by type checker")
        }
    }
}

// Emits the default value for each respective type. This is important mostly
// for reference types, since RC calls may be done on uninitialized variables.
pub fun emit_default_value(type: Type) -> String {
    match type.value {
        Unit { return "QUILL_UNIT" }
        Integer { return "0" }
        Float { return "0.0" }
        Boolean { return "QUILL_FALSE" }
        String { return "QUILL_EMPTY_STRING" }
        Struct(_) { return "QUILL_NULL_STRUCT" }
        Enum(_) { return "QUILL_NULL_ENUM" }
        Function(_) { return "QUILL_NULL_CLOSURE" }
        List(_) { return "QUILL_NULL_LIST" }

        Invalid { return panic("invalid type generated by type checker") }
    }
}

// Emits free handlers required for struct and enum types.
// When the reference count of a structure, enum or closure reaches zero,
// before the buffer is deallocated, a function is invoked that decreases 
// all reference counts of contained references. The functions generated by
// this function are responsible for this.
pub fun emit_type_deconstructors(table: SymbolTable) -> String {
    val emit_decl: Fun(String, String) -> String
        = |path, body| "static __(_ *alloc) {\n_}\n\n"
            |> fmt(path, "_deconstruct", "quill_alloc_t", body)
    return all_instances_of(table)
        |> map[Triplet[TypedNode, Int, List[Type]], String](|i| { match i.first.value {
            Structure(ast::CustomType(path, _, _, members)) {
                val p: String = mangle_path(path, i.second)
                val body_start: String = "_ *m = (_ *) alloc->data;\n"
                    |> fmt(p, p)
                val body_mems: String = members 
                    |> values()
                    |> map[Pair[String, TypedNode], String](|m| emit_rc_dec(
                        "m->m_" |> concat(m.first), m.second.type
                    ))
                    |> join("")
                return emit_decl(p, body_start |> concat(body_mems))
            }
            Enumeration(ast::CustomType(path, _, _, members)) {
                val p: String = mangle_path(path, i.second)
                val body_start: String = "_ *m = (_ *) alloc->data;\n"
                    |> fmt(p, p)
                val branches: String = members
                    |> indices()
                    |> map[Int, String](|m_i| {
                        val m: Pair[String, TypedNode] = members |> at(m_i)
                        val d: String = emit_rc_dec(
                            "m->value.m_" |> concat(m.first), m.second.type
                        )
                        if 0 == (d |> length()) { return "" }
                        return "case _:\n_break;\n" 
                            |> fmt(m_i |> as_string(), d)
                    })
                    |> join("")
                val body: String = body_start 
                    |> concat("switch(m->tag) {\n")
                    |> concat(branches)
                    |> concat("}\n")
                return emit_decl(p, body)
            }
            _ { return "" }
        } })
        |> join("")
}

// Attempts to expand macros such as `#var(...)`, `#type(...)` and `#fun(...)`
// in the given external function body, returning the expanded result.
pub fun expand_external_body(
    og_body: String, 
    args: List[Pair[String, TypedNode]],
    t_args: mut Map[String, Type],
    context: ModuleContext,
    table: SymbolTable
) -> String {
    val expand_macro: Fun(String, String, Fun(String) -> String) -> String
    = |before_body, macro, f| {
        mut rem: String = before_body
        val repl: String 
            = Sequence::new[Int](|| rem |> find(macro) |> next())
            |> fold("", |repl, i| {
                val at: String = rem |> slice_from(i + (macro |> length()))
                val closing: Int = at |> find(")") |> next() 
                    |> expect("Unclosed macro in external function body")
                val before: String = rem |> slice_to(i)
                val inner: String = at |> slice_to(closing)
                rem = at |> slice_from(closing + 1)
                return repl |> concat(before) |> concat(f(inner))
            })
        return repl |> concat(rem)
    }
    return og_body
        |> expand_macro("#var(", |n| {
            val i: Int = args |> indices() 
                |> find(|i| (args |> at(i)).first == n)
                |> unwrap_or_else(
                    || "External function body used '#var' to reference '"
                    |> concat(n)
                    |> concat("', which is not a known argument")
                    |> panic()
                )
            return "param" |> concat(i |> as_string())
        })
        |> expand_macro("#type(", |t| {
            val sources: Map[String, String] 
                = Map::of(Pair("ext_macro.quill", t))
            val messages: mut List[Message] = List::empty()
            val tokens: mut Stream[token::Token] 
                = lexer::tokenize("ext_macro.quill", t, messages)
            val node: ast::UntypedNode = parser::Parser::from(tokens, messages) 
                |> parser::parse_type()
            val checker = checker::Checker(
                List::empty(), t_args, table, context, List::empty(),
                messages
            )
            val checked: TypedNode = checker
                |> checker::Checker::check_annotation(node)
            messages |> values() 
                |> map[Message, String](|m| m |> display(sources) |> concat("\n")) 
                |> for_each(println)
            if messages |> values() |> any(Message::is_error) {
                return panic("Error in macro in external function body")
            }
            return emit_type(checked.type)
        })
        |> expand_macro("#fun(", |f| {
            // TODO!
            return panic("not yet implemented")
        })
}

// Emits the full implementations of the functions in the given table.
pub fun emit_func_implementations(table: SymbolTable) -> String 
    = table.symbols |> values() |> map[Symbol, String](
        |s| s.instances |> values() |> map[Triplet[TypedNode, Int, List[Type]], String](
            |i| { match i.first.value {
                ast::Variant::Function(ast::Function(
                    path, _, _, args, _, ret, body
                )) {
                    val signature: String = emit_func_signature(
                        path, i.second, args, ret, i.first.source
                    )
                    val body_s: String = ""
                    return signature |> concat(" {\n")
                        |> concat(body_s)
                        |> concat("}\n\n")
                }
                ExternalFunction(ast::ExternalFunction(
                    path, _, t_arg_names, args, _, ret, body
                )) {
                    val signature: String = emit_func_signature(
                        path, i.second, args, ret, i.first.source
                    )
                    val t_args: mut Map[String, Type] = t_arg_names |> values()
                        |> zip(i.third |> values(), |n, t| Pair(n, t))
                        |> Map::collect()
                    val body_s: String = expand_external_body(
                        body, args, t_args, s.context, table
                    )
                    return signature |> concat(" {")
                        |> concat(body_s)
                        |> concat("}\n\n")
                }
                _ { return "" }
            } }
        ) |> join("")
    ) |> join("")

pub struct Generator(
    start: String,
    body: String,
    end: String,
    locals: mut Map[String, String],
    capturable: Set[String],
    captured: mut Map[String, Type],
    next_local_id: mut Box[Int],
    table: SymbolTable
)

pub fun Generator::new(table: SymbolTable) -> mut Generator
    = Generator(
        "", "", "",
        Map::empty(), Set::empty(), Map::empty(), Box(0),
        table
    )

// Creates a new generator in a new scope under the scope of the given exisiting
// generator. Local variables are copied, but captures, symbols and local variable
// indices are shared with the parent scope.
pub fun Generator::under(existing: Generator) -> mut Generator
    = Generator(
        "", "", "", 
        existing.locals |> clone(), existing.capturable, existing.captured, 
        existing.next_local_id, 
        existing.table
    )

// Inserts the given text in the beginning section of the generator scope.
pub fun Generator::at_start(self: mut Generator, s: String) {
    self.start = self.start |> concat(s)
}

// Inserts the given text in the body section of the generator scope.
pub fun Generator::in_body(self: mut Generator, s: String) {
    self.body = self.body |> concat(s)
}

// Inserts the given text at the end of the generator scope.
pub fun Generator::at_end(self: mut Generator, s: String) {
    self.end = self.end |> concat(s)
}

// Allocates a new local variable with the given type in the generator scope,
// adding a definition at the start of the scope and RC handling at the end of it.
pub fun Generator::alloc(self: mut Generator, t: Type) -> String {
    val id: Int = self.next_local_id.value
    val name: String = "local" |> concat(id |> as_string())
    val v: String = emit_default_value(t)
    self |> at_start("_ _ = _;\n" |> fmt(emit_type(t), name, v))
    self |> at_end(emit_rc_dec(name, t))
    self.next_local_id.value = id + 1
    return name
}

// Emits code that writes the value prodived by 'value' to the location specified
// by 'dest', provided that the type of 'dest' matches the given type 't'.
// This function is mainly used for the automatic insertion of RC handling
// before and after the assignment, depending on the type of the variable.
// The code is emitted at the end of the body section of the generator.
// In the case that the given type requires RC handling, the string given for
// 'value' may be emitted more than once.
pub fun Generator::assign_to(
    self: mut Generator, dest: String, t: Type, value: String
) {
    self |> in_body(emit_rc_add(value, t))
    self |> in_body(emit_rc_dec(dest, t))
    self |> in_body("_ = _;\n" |> fmt(dest, value))
}

// Emits a local statement as the equivalent C code.
pub fun emit_statement(gen: mut Generator, node: TypedNode) {
    match node.value {
        LocalVariable(_) {

        }
        Assignment(_) {

        }
        Return(_) {
            // increase RC of value before returning
        }
        Continue {

        }
        Break {

        }
        If(_) {

        }
        While(_) {

        }
        For(_) {

        }
        Match(_) {
            // just abuse the ðŸ¦† out of 'goto'
        }
        _ { return panic("encountered unexpected AST node type") }
    }
}

// Emits the entire given statement list as the equivalent C code, NOT including
// opening and closing braces.
pub fun emit_statement_list(gen: mut Generator, nodes: List[TypedNode])
    = nodes |> values() |> for_each(|n| gen |> emit_statement(n))

// Emits the equivalent lowered C code for the given expression.
pub fun emit_expression(gen: mut Generator, node: TypedNode, into: String) {
    match node.value {
        PathRef(_) {

        }
        VariableRef(_) {

        }
        FunctionRef(_) {

        }
        Int(_) {

        }
        Float(_) {

        }
        Bool(_) {

        }
        Unit {}
        String(_) {

        }
        Closure(_) {

        }
        Member(_) {

        }
        Call(_) {
            // 1. increase RCs of all arguments
            // 2. decrease RC of into
            //     - cannot cause RC to drop to 0 because same reference,
            //       since the reference must have been passed to the function
            //       and the function increases the RC before returning
            // 3. call and manually (without 'assign_to') put result into 'into'
        }
        NamedCall(_) {
            // 1. increase RCs of all arguments
            // 2. decrease RC of into
            //     - cannot cause RC to drop to 0 because same reference,
            //       since the reference must have been passed to the function
            //       and the function increases the RC before returning
            // 3. call and manually (without 'assign_to') put result into 'into'
        }
        StructInit(_) {
            // 1. increase RCs of values
            // 2. decrease RC of into
            // 3. allocate new object, put values and put into 'into' (without 'assign_to')
        }
        EnumInit(_) {
            // 1. increase RCs of values
            // 2. decrease RC of into
            // 3. allocate new object, put values and put into 'into' (without 'assign_to')
        }
        IfExpr(_) {
            
        }
        _ { return panic("encountered unexpected AST node type") }
    }
}

// Emits all symbols defined by the given symbol table as a complete C file
// dependent on the Quill C runtime.
pub fun emit(table: SymbolTable, main: List[String]) -> String {
    // 1. struct / enum layouts,
    //    (external?) function pre-declarations,
    //    global variable declarations,
    //    closure capture data layouts
    // 2. struct / enum free handler implementations,
    //    closure capture free handlers
    // 3. (external?) function implementations
    // 4. global variable initialization function
    // 5. main function (calls globals init and quill main)
    return HEADER
        |> concat(emit_declarations(table))
        |> concat(emit_type_deconstructors(table))
        |> concat(emit_func_implementations(table))
}